schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

# expression to compare columns of type Boolean. All fields are combined with logical 'AND'.
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

# columns and relationships of "chat"
type chat {
  id: Int!
  image: String

  # An array relationship
  messages(
    # distinct select on columns
    distinct_on: [message_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [message_order_by!]

    # filter the rows returned
    where: message_bool_exp
  ): [message!]!

  # An aggregated array relationship
  messages_aggregate(
    # distinct select on columns
    distinct_on: [message_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [message_order_by!]

    # filter the rows returned
    where: message_bool_exp
  ): message_aggregate!
  name: String

  # An array relationship
  participants(
    # distinct select on columns
    distinct_on: [chatUserView_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [chatUserView_order_by!]

    # filter the rows returned
    where: chatUserView_bool_exp
  ): [chatUserView!]!

  # An aggregated array relationship
  participants_aggregate(
    # distinct select on columns
    distinct_on: [chatUserView_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [chatUserView_order_by!]

    # filter the rows returned
    where: chatUserView_bool_exp
  ): chatUserView_aggregate!
  unsubscribable: Boolean!

  # An array relationship
  users(
    # distinct select on columns
    distinct_on: [userChat_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userChat_order_by!]

    # filter the rows returned
    where: userChat_bool_exp
  ): [userChat!]!

  # An aggregated array relationship
  users_aggregate(
    # distinct select on columns
    distinct_on: [userChat_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userChat_order_by!]

    # filter the rows returned
    where: userChat_bool_exp
  ): userChat_aggregate!
}

# aggregated selection of "chat"
type chat_aggregate {
  aggregate: chat_aggregate_fields
  nodes: [chat!]!
}

# aggregate fields of "chat"
type chat_aggregate_fields {
  avg: chat_avg_fields
  count(columns: [chat_select_column!], distinct: Boolean): Int
  max: chat_max_fields
  min: chat_min_fields
  stddev: chat_stddev_fields
  stddev_pop: chat_stddev_pop_fields
  stddev_samp: chat_stddev_samp_fields
  sum: chat_sum_fields
  var_pop: chat_var_pop_fields
  var_samp: chat_var_samp_fields
  variance: chat_variance_fields
}

# order by aggregate values of table "chat"
input chat_aggregate_order_by {
  avg: chat_avg_order_by
  count: order_by
  max: chat_max_order_by
  min: chat_min_order_by
  stddev: chat_stddev_order_by
  stddev_pop: chat_stddev_pop_order_by
  stddev_samp: chat_stddev_samp_order_by
  sum: chat_sum_order_by
  var_pop: chat_var_pop_order_by
  var_samp: chat_var_samp_order_by
  variance: chat_variance_order_by
}

# input type for inserting array relation for remote table "chat"
input chat_arr_rel_insert_input {
  data: [chat_insert_input!]!
  on_conflict: chat_on_conflict
}

# aggregate avg on columns
type chat_avg_fields {
  id: Float
}

# order by avg() on columns of table "chat"
input chat_avg_order_by {
  id: order_by
}

# Boolean expression to filter rows from the table "chat". All fields are combined with a logical 'AND'.
input chat_bool_exp {
  _and: [chat_bool_exp]
  _not: chat_bool_exp
  _or: [chat_bool_exp]
  id: Int_comparison_exp
  image: String_comparison_exp
  messages: message_bool_exp
  name: String_comparison_exp
  participants: chatUserView_bool_exp
  unsubscribable: Boolean_comparison_exp
  users: userChat_bool_exp
}

# unique or primary key constraints on table "chat"
enum chat_constraint {
  # unique or primary key constraint
  chat_pkey
}

# input type for incrementing integer column in table "chat"
input chat_inc_input {
  id: Int
}

# input type for inserting data into table "chat"
input chat_insert_input {
  id: Int
  image: String
  messages: message_arr_rel_insert_input
  name: String
  unsubscribable: Boolean
  users: userChat_arr_rel_insert_input
}

# aggregate max on columns
type chat_max_fields {
  id: Int
  image: String
  name: String
}

# order by max() on columns of table "chat"
input chat_max_order_by {
  id: order_by
  image: order_by
  name: order_by
}

# aggregate min on columns
type chat_min_fields {
  id: Int
  image: String
  name: String
}

# order by min() on columns of table "chat"
input chat_min_order_by {
  id: order_by
  image: order_by
  name: order_by
}

# response of any mutation on the table "chat"
type chat_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [chat!]!
}

# input type for inserting object relation for remote table "chat"
input chat_obj_rel_insert_input {
  data: chat_insert_input!
  on_conflict: chat_on_conflict
}

# on conflict condition type for table "chat"
input chat_on_conflict {
  constraint: chat_constraint!
  update_columns: [chat_update_column!]!
  where: chat_bool_exp
}

# ordering options when selecting data from "chat"
input chat_order_by {
  id: order_by
  image: order_by
  messages_aggregate: message_aggregate_order_by
  name: order_by
  participants_aggregate: chatUserView_aggregate_order_by
  unsubscribable: order_by
  users_aggregate: userChat_aggregate_order_by
}

# primary key columns input for table: "chat"
input chat_pk_columns_input {
  id: Int!
}

# select columns of table "chat"
enum chat_select_column {
  # column name
  id

  # column name
  image

  # column name
  name

  # column name
  unsubscribable
}

# input type for updating data in table "chat"
input chat_set_input {
  id: Int
  image: String
  name: String
  unsubscribable: Boolean
}

# aggregate stddev on columns
type chat_stddev_fields {
  id: Float
}

# order by stddev() on columns of table "chat"
input chat_stddev_order_by {
  id: order_by
}

# aggregate stddev_pop on columns
type chat_stddev_pop_fields {
  id: Float
}

# order by stddev_pop() on columns of table "chat"
input chat_stddev_pop_order_by {
  id: order_by
}

# aggregate stddev_samp on columns
type chat_stddev_samp_fields {
  id: Float
}

# order by stddev_samp() on columns of table "chat"
input chat_stddev_samp_order_by {
  id: order_by
}

# aggregate sum on columns
type chat_sum_fields {
  id: Int
}

# order by sum() on columns of table "chat"
input chat_sum_order_by {
  id: order_by
}

# update columns of table "chat"
enum chat_update_column {
  # column name
  id

  # column name
  image

  # column name
  name

  # column name
  unsubscribable
}

# aggregate var_pop on columns
type chat_var_pop_fields {
  id: Float
}

# order by var_pop() on columns of table "chat"
input chat_var_pop_order_by {
  id: order_by
}

# aggregate var_samp on columns
type chat_var_samp_fields {
  id: Float
}

# order by var_samp() on columns of table "chat"
input chat_var_samp_order_by {
  id: order_by
}

# aggregate variance on columns
type chat_variance_fields {
  id: Float
}

# order by variance() on columns of table "chat"
input chat_variance_order_by {
  id: order_by
}

# columns and relationships of "chatUserView"
type chatUserView {
  chatId: Int
  college: String
  description: String
  email: String
  id: String
  image: String
  isOfficial: Boolean
  links(
    # JSON select path
    path: String
  ): jsonb
  name: String
  notificationToken: String
  year: Int
}

# aggregated selection of "chatUserView"
type chatUserView_aggregate {
  aggregate: chatUserView_aggregate_fields
  nodes: [chatUserView!]!
}

# aggregate fields of "chatUserView"
type chatUserView_aggregate_fields {
  avg: chatUserView_avg_fields
  count(columns: [chatUserView_select_column!], distinct: Boolean): Int
  max: chatUserView_max_fields
  min: chatUserView_min_fields
  stddev: chatUserView_stddev_fields
  stddev_pop: chatUserView_stddev_pop_fields
  stddev_samp: chatUserView_stddev_samp_fields
  sum: chatUserView_sum_fields
  var_pop: chatUserView_var_pop_fields
  var_samp: chatUserView_var_samp_fields
  variance: chatUserView_variance_fields
}

# order by aggregate values of table "chatUserView"
input chatUserView_aggregate_order_by {
  avg: chatUserView_avg_order_by
  count: order_by
  max: chatUserView_max_order_by
  min: chatUserView_min_order_by
  stddev: chatUserView_stddev_order_by
  stddev_pop: chatUserView_stddev_pop_order_by
  stddev_samp: chatUserView_stddev_samp_order_by
  sum: chatUserView_sum_order_by
  var_pop: chatUserView_var_pop_order_by
  var_samp: chatUserView_var_samp_order_by
  variance: chatUserView_variance_order_by
}

# append existing jsonb value of filtered columns with new jsonb value
input chatUserView_append_input {
  links: jsonb
}

# aggregate avg on columns
type chatUserView_avg_fields {
  chatId: Float
  year: Float
}

# order by avg() on columns of table "chatUserView"
input chatUserView_avg_order_by {
  chatId: order_by
  year: order_by
}

# Boolean expression to filter rows from the table "chatUserView". All fields are combined with a logical 'AND'.
input chatUserView_bool_exp {
  _and: [chatUserView_bool_exp]
  _not: chatUserView_bool_exp
  _or: [chatUserView_bool_exp]
  chatId: Int_comparison_exp
  college: String_comparison_exp
  description: String_comparison_exp
  email: String_comparison_exp
  id: String_comparison_exp
  image: String_comparison_exp
  isOfficial: Boolean_comparison_exp
  links: jsonb_comparison_exp
  name: String_comparison_exp
  notificationToken: String_comparison_exp
  year: Int_comparison_exp
}

# delete the field or element with specified path (for JSON arrays, negative integers count from the end)
input chatUserView_delete_at_path_input {
  links: [String]
}

# delete the array element with specified index (negative integers count from the
# end). throws an error if top level container is not an array
input chatUserView_delete_elem_input {
  links: Int
}

# delete key/value pair or string element. key/value pairs are matched based on their key value
input chatUserView_delete_key_input {
  links: String
}

# aggregate max on columns
type chatUserView_max_fields {
  chatId: Int
  college: String
  description: String
  email: String
  id: String
  image: String
  name: String
  notificationToken: String
  year: Int
}

# order by max() on columns of table "chatUserView"
input chatUserView_max_order_by {
  chatId: order_by
  college: order_by
  description: order_by
  email: order_by
  id: order_by
  image: order_by
  name: order_by
  notificationToken: order_by
  year: order_by
}

# aggregate min on columns
type chatUserView_min_fields {
  chatId: Int
  college: String
  description: String
  email: String
  id: String
  image: String
  name: String
  notificationToken: String
  year: Int
}

# order by min() on columns of table "chatUserView"
input chatUserView_min_order_by {
  chatId: order_by
  college: order_by
  description: order_by
  email: order_by
  id: order_by
  image: order_by
  name: order_by
  notificationToken: order_by
  year: order_by
}

# ordering options when selecting data from "chatUserView"
input chatUserView_order_by {
  chatId: order_by
  college: order_by
  description: order_by
  email: order_by
  id: order_by
  image: order_by
  isOfficial: order_by
  links: order_by
  name: order_by
  notificationToken: order_by
  year: order_by
}

# prepend existing jsonb value of filtered columns with new jsonb value
input chatUserView_prepend_input {
  links: jsonb
}

# select columns of table "chatUserView"
enum chatUserView_select_column {
  # column name
  chatId

  # column name
  college

  # column name
  description

  # column name
  email

  # column name
  id

  # column name
  image

  # column name
  isOfficial

  # column name
  links

  # column name
  name

  # column name
  notificationToken

  # column name
  year
}

# aggregate stddev on columns
type chatUserView_stddev_fields {
  chatId: Float
  year: Float
}

# order by stddev() on columns of table "chatUserView"
input chatUserView_stddev_order_by {
  chatId: order_by
  year: order_by
}

# aggregate stddev_pop on columns
type chatUserView_stddev_pop_fields {
  chatId: Float
  year: Float
}

# order by stddev_pop() on columns of table "chatUserView"
input chatUserView_stddev_pop_order_by {
  chatId: order_by
  year: order_by
}

# aggregate stddev_samp on columns
type chatUserView_stddev_samp_fields {
  chatId: Float
  year: Float
}

# order by stddev_samp() on columns of table "chatUserView"
input chatUserView_stddev_samp_order_by {
  chatId: order_by
  year: order_by
}

# aggregate sum on columns
type chatUserView_sum_fields {
  chatId: Int
  year: Int
}

# order by sum() on columns of table "chatUserView"
input chatUserView_sum_order_by {
  chatId: order_by
  year: order_by
}

# aggregate var_pop on columns
type chatUserView_var_pop_fields {
  chatId: Float
  year: Float
}

# order by var_pop() on columns of table "chatUserView"
input chatUserView_var_pop_order_by {
  chatId: order_by
  year: order_by
}

# aggregate var_samp on columns
type chatUserView_var_samp_fields {
  chatId: Float
  year: Float
}

# order by var_samp() on columns of table "chatUserView"
input chatUserView_var_samp_order_by {
  chatId: order_by
  year: order_by
}

# aggregate variance on columns
type chatUserView_variance_fields {
  chatId: Float
  year: Float
}

# order by variance() on columns of table "chatUserView"
input chatUserView_variance_order_by {
  chatId: order_by
  year: order_by
}

type ConfirmFriendRequestOutput {
  recipient: String!
}

# columns and relationships of "event"
type event {
  # An array relationship
  attendees(
    # distinct select on columns
    distinct_on: [userEvent_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userEvent_order_by!]

    # filter the rows returned
    where: userEvent_bool_exp
  ): [userEvent!]!

  # An aggregated array relationship
  attendees_aggregate(
    # distinct select on columns
    distinct_on: [userEvent_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userEvent_order_by!]

    # filter the rows returned
    where: userEvent_bool_exp
  ): userEvent_aggregate!
  description: String
  email: String!
  endDate: timestamptz!
  gallery(
    # JSON select path
    path: String
  ): jsonb!

  # An array relationship
  hosts(
    # distinct select on columns
    distinct_on: [groupEvent_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupEvent_order_by!]

    # filter the rows returned
    where: groupEvent_bool_exp
  ): [groupEvent!]!

  # An aggregated array relationship
  hosts_aggregate(
    # distinct select on columns
    distinct_on: [groupEvent_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupEvent_order_by!]

    # filter the rows returned
    where: groupEvent_bool_exp
  ): groupEvent_aggregate!
  id: uuid!
  image: String!
  isOfficial: Boolean!
  links(
    # JSON select path
    path: String
  ): jsonb!
  location(
    # JSON select path
    path: String
  ): jsonb!
  name: String!

  # An array relationship
  questions(
    # distinct select on columns
    distinct_on: [eventQuestion_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [eventQuestion_order_by!]

    # filter the rows returned
    where: eventQuestion_bool_exp
  ): [eventQuestion!]!

  # An aggregated array relationship
  questions_aggregate(
    # distinct select on columns
    distinct_on: [eventQuestion_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [eventQuestion_order_by!]

    # filter the rows returned
    where: eventQuestion_bool_exp
  ): eventQuestion_aggregate!
  startDate: timestamptz!
  website: String
}

# aggregated selection of "event"
type event_aggregate {
  aggregate: event_aggregate_fields
  nodes: [event!]!
}

# aggregate fields of "event"
type event_aggregate_fields {
  count(columns: [event_select_column!], distinct: Boolean): Int
  max: event_max_fields
  min: event_min_fields
}

# order by aggregate values of table "event"
input event_aggregate_order_by {
  count: order_by
  max: event_max_order_by
  min: event_min_order_by
}

# append existing jsonb value of filtered columns with new jsonb value
input event_append_input {
  gallery: jsonb
  links: jsonb
  location: jsonb
}

# input type for inserting array relation for remote table "event"
input event_arr_rel_insert_input {
  data: [event_insert_input!]!
  on_conflict: event_on_conflict
}

# Boolean expression to filter rows from the table "event". All fields are combined with a logical 'AND'.
input event_bool_exp {
  _and: [event_bool_exp]
  _not: event_bool_exp
  _or: [event_bool_exp]
  attendees: userEvent_bool_exp
  description: String_comparison_exp
  email: String_comparison_exp
  endDate: timestamptz_comparison_exp
  gallery: jsonb_comparison_exp
  hosts: groupEvent_bool_exp
  id: uuid_comparison_exp
  image: String_comparison_exp
  isOfficial: Boolean_comparison_exp
  links: jsonb_comparison_exp
  location: jsonb_comparison_exp
  name: String_comparison_exp
  questions: eventQuestion_bool_exp
  startDate: timestamptz_comparison_exp
  website: String_comparison_exp
}

# unique or primary key constraints on table "event"
enum event_constraint {
  # unique or primary key constraint
  event_id_key

  # unique or primary key constraint
  event_pkey
}

# delete the field or element with specified path (for JSON arrays, negative integers count from the end)
input event_delete_at_path_input {
  gallery: [String]
  links: [String]
  location: [String]
}

# delete the array element with specified index (negative integers count from the
# end). throws an error if top level container is not an array
input event_delete_elem_input {
  gallery: Int
  links: Int
  location: Int
}

# delete key/value pair or string element. key/value pairs are matched based on their key value
input event_delete_key_input {
  gallery: String
  links: String
  location: String
}

# input type for inserting data into table "event"
input event_insert_input {
  attendees: userEvent_arr_rel_insert_input
  description: String
  email: String
  endDate: timestamptz
  gallery: jsonb
  hosts: groupEvent_arr_rel_insert_input
  id: uuid
  image: String
  isOfficial: Boolean
  links: jsonb
  location: jsonb
  name: String
  questions: eventQuestion_arr_rel_insert_input
  startDate: timestamptz
  website: String
}

# aggregate max on columns
type event_max_fields {
  description: String
  email: String
  endDate: timestamptz
  id: uuid
  image: String
  name: String
  startDate: timestamptz
  website: String
}

# order by max() on columns of table "event"
input event_max_order_by {
  description: order_by
  email: order_by
  endDate: order_by
  id: order_by
  image: order_by
  name: order_by
  startDate: order_by
  website: order_by
}

# aggregate min on columns
type event_min_fields {
  description: String
  email: String
  endDate: timestamptz
  id: uuid
  image: String
  name: String
  startDate: timestamptz
  website: String
}

# order by min() on columns of table "event"
input event_min_order_by {
  description: order_by
  email: order_by
  endDate: order_by
  id: order_by
  image: order_by
  name: order_by
  startDate: order_by
  website: order_by
}

# response of any mutation on the table "event"
type event_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [event!]!
}

# input type for inserting object relation for remote table "event"
input event_obj_rel_insert_input {
  data: event_insert_input!
  on_conflict: event_on_conflict
}

# on conflict condition type for table "event"
input event_on_conflict {
  constraint: event_constraint!
  update_columns: [event_update_column!]!
  where: event_bool_exp
}

# ordering options when selecting data from "event"
input event_order_by {
  attendees_aggregate: userEvent_aggregate_order_by
  description: order_by
  email: order_by
  endDate: order_by
  gallery: order_by
  hosts_aggregate: groupEvent_aggregate_order_by
  id: order_by
  image: order_by
  isOfficial: order_by
  links: order_by
  location: order_by
  name: order_by
  questions_aggregate: eventQuestion_aggregate_order_by
  startDate: order_by
  website: order_by
}

# primary key columns input for table: "event"
input event_pk_columns_input {
  id: uuid!
}

# prepend existing jsonb value of filtered columns with new jsonb value
input event_prepend_input {
  gallery: jsonb
  links: jsonb
  location: jsonb
}

# select columns of table "event"
enum event_select_column {
  # column name
  description

  # column name
  email

  # column name
  endDate

  # column name
  gallery

  # column name
  id

  # column name
  image

  # column name
  isOfficial

  # column name
  links

  # column name
  location

  # column name
  name

  # column name
  startDate

  # column name
  website
}

# input type for updating data in table "event"
input event_set_input {
  description: String
  email: String
  endDate: timestamptz
  gallery: jsonb
  id: uuid
  image: String
  isOfficial: Boolean
  links: jsonb
  location: jsonb
  name: String
  startDate: timestamptz
  website: String
}

# update columns of table "event"
enum event_update_column {
  # column name
  description

  # column name
  email

  # column name
  endDate

  # column name
  gallery

  # column name
  id

  # column name
  image

  # column name
  isOfficial

  # column name
  links

  # column name
  location

  # column name
  name

  # column name
  startDate

  # column name
  website
}

# columns and relationships of "eventQuestion"
type eventQuestion {
  # An object relationship
  event: event!
  eventId: uuid!

  # An object relationship
  question: question!
  questionId: Int!
}

# aggregated selection of "eventQuestion"
type eventQuestion_aggregate {
  aggregate: eventQuestion_aggregate_fields
  nodes: [eventQuestion!]!
}

# aggregate fields of "eventQuestion"
type eventQuestion_aggregate_fields {
  avg: eventQuestion_avg_fields
  count(columns: [eventQuestion_select_column!], distinct: Boolean): Int
  max: eventQuestion_max_fields
  min: eventQuestion_min_fields
  stddev: eventQuestion_stddev_fields
  stddev_pop: eventQuestion_stddev_pop_fields
  stddev_samp: eventQuestion_stddev_samp_fields
  sum: eventQuestion_sum_fields
  var_pop: eventQuestion_var_pop_fields
  var_samp: eventQuestion_var_samp_fields
  variance: eventQuestion_variance_fields
}

# order by aggregate values of table "eventQuestion"
input eventQuestion_aggregate_order_by {
  avg: eventQuestion_avg_order_by
  count: order_by
  max: eventQuestion_max_order_by
  min: eventQuestion_min_order_by
  stddev: eventQuestion_stddev_order_by
  stddev_pop: eventQuestion_stddev_pop_order_by
  stddev_samp: eventQuestion_stddev_samp_order_by
  sum: eventQuestion_sum_order_by
  var_pop: eventQuestion_var_pop_order_by
  var_samp: eventQuestion_var_samp_order_by
  variance: eventQuestion_variance_order_by
}

# input type for inserting array relation for remote table "eventQuestion"
input eventQuestion_arr_rel_insert_input {
  data: [eventQuestion_insert_input!]!
  on_conflict: eventQuestion_on_conflict
}

# aggregate avg on columns
type eventQuestion_avg_fields {
  questionId: Float
}

# order by avg() on columns of table "eventQuestion"
input eventQuestion_avg_order_by {
  questionId: order_by
}

# Boolean expression to filter rows from the table "eventQuestion". All fields are combined with a logical 'AND'.
input eventQuestion_bool_exp {
  _and: [eventQuestion_bool_exp]
  _not: eventQuestion_bool_exp
  _or: [eventQuestion_bool_exp]
  event: event_bool_exp
  eventId: uuid_comparison_exp
  question: question_bool_exp
  questionId: Int_comparison_exp
}

# unique or primary key constraints on table "eventQuestion"
enum eventQuestion_constraint {
  # unique or primary key constraint
  eventQuestion_pkey
}

# input type for incrementing integer column in table "eventQuestion"
input eventQuestion_inc_input {
  questionId: Int
}

# input type for inserting data into table "eventQuestion"
input eventQuestion_insert_input {
  event: event_obj_rel_insert_input
  eventId: uuid
  question: question_obj_rel_insert_input
  questionId: Int
}

# aggregate max on columns
type eventQuestion_max_fields {
  eventId: uuid
  questionId: Int
}

# order by max() on columns of table "eventQuestion"
input eventQuestion_max_order_by {
  eventId: order_by
  questionId: order_by
}

# aggregate min on columns
type eventQuestion_min_fields {
  eventId: uuid
  questionId: Int
}

# order by min() on columns of table "eventQuestion"
input eventQuestion_min_order_by {
  eventId: order_by
  questionId: order_by
}

# response of any mutation on the table "eventQuestion"
type eventQuestion_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [eventQuestion!]!
}

# input type for inserting object relation for remote table "eventQuestion"
input eventQuestion_obj_rel_insert_input {
  data: eventQuestion_insert_input!
  on_conflict: eventQuestion_on_conflict
}

# on conflict condition type for table "eventQuestion"
input eventQuestion_on_conflict {
  constraint: eventQuestion_constraint!
  update_columns: [eventQuestion_update_column!]!
  where: eventQuestion_bool_exp
}

# ordering options when selecting data from "eventQuestion"
input eventQuestion_order_by {
  event: event_order_by
  eventId: order_by
  question: question_order_by
  questionId: order_by
}

# primary key columns input for table: "eventQuestion"
input eventQuestion_pk_columns_input {
  eventId: uuid!
  questionId: Int!
}

# select columns of table "eventQuestion"
enum eventQuestion_select_column {
  # column name
  eventId

  # column name
  questionId
}

# input type for updating data in table "eventQuestion"
input eventQuestion_set_input {
  eventId: uuid
  questionId: Int
}

# aggregate stddev on columns
type eventQuestion_stddev_fields {
  questionId: Float
}

# order by stddev() on columns of table "eventQuestion"
input eventQuestion_stddev_order_by {
  questionId: order_by
}

# aggregate stddev_pop on columns
type eventQuestion_stddev_pop_fields {
  questionId: Float
}

# order by stddev_pop() on columns of table "eventQuestion"
input eventQuestion_stddev_pop_order_by {
  questionId: order_by
}

# aggregate stddev_samp on columns
type eventQuestion_stddev_samp_fields {
  questionId: Float
}

# order by stddev_samp() on columns of table "eventQuestion"
input eventQuestion_stddev_samp_order_by {
  questionId: order_by
}

# aggregate sum on columns
type eventQuestion_sum_fields {
  questionId: Int
}

# order by sum() on columns of table "eventQuestion"
input eventQuestion_sum_order_by {
  questionId: order_by
}

# update columns of table "eventQuestion"
enum eventQuestion_update_column {
  # column name
  eventId

  # column name
  questionId
}

# aggregate var_pop on columns
type eventQuestion_var_pop_fields {
  questionId: Float
}

# order by var_pop() on columns of table "eventQuestion"
input eventQuestion_var_pop_order_by {
  questionId: order_by
}

# aggregate var_samp on columns
type eventQuestion_var_samp_fields {
  questionId: Float
}

# order by var_samp() on columns of table "eventQuestion"
input eventQuestion_var_samp_order_by {
  questionId: order_by
}

# aggregate variance on columns
type eventQuestion_variance_fields {
  questionId: Float
}

# order by variance() on columns of table "eventQuestion"
input eventQuestion_variance_order_by {
  questionId: order_by
}

# columns and relationships of "friend"
type friend {
  # An object relationship
  friend: user!
  friendId: String!
  original: Boolean!

  # An object relationship
  user: user!
  userId: String!
}

# aggregated selection of "friend"
type friend_aggregate {
  aggregate: friend_aggregate_fields
  nodes: [friend!]!
}

# aggregate fields of "friend"
type friend_aggregate_fields {
  count(columns: [friend_select_column!], distinct: Boolean): Int
  max: friend_max_fields
  min: friend_min_fields
}

# order by aggregate values of table "friend"
input friend_aggregate_order_by {
  count: order_by
  max: friend_max_order_by
  min: friend_min_order_by
}

# input type for inserting array relation for remote table "friend"
input friend_arr_rel_insert_input {
  data: [friend_insert_input!]!
  on_conflict: friend_on_conflict
}

# Boolean expression to filter rows from the table "friend". All fields are combined with a logical 'AND'.
input friend_bool_exp {
  _and: [friend_bool_exp]
  _not: friend_bool_exp
  _or: [friend_bool_exp]
  friend: user_bool_exp
  friendId: String_comparison_exp
  original: Boolean_comparison_exp
  user: user_bool_exp
  userId: String_comparison_exp
}

# unique or primary key constraints on table "friend"
enum friend_constraint {
  # unique or primary key constraint
  friend_pkey
}

# input type for inserting data into table "friend"
input friend_insert_input {
  friend: user_obj_rel_insert_input
  friendId: String
  original: Boolean
  user: user_obj_rel_insert_input
  userId: String
}

# aggregate max on columns
type friend_max_fields {
  friendId: String
  userId: String
}

# order by max() on columns of table "friend"
input friend_max_order_by {
  friendId: order_by
  userId: order_by
}

# aggregate min on columns
type friend_min_fields {
  friendId: String
  userId: String
}

# order by min() on columns of table "friend"
input friend_min_order_by {
  friendId: order_by
  userId: order_by
}

# response of any mutation on the table "friend"
type friend_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [friend!]!
}

# input type for inserting object relation for remote table "friend"
input friend_obj_rel_insert_input {
  data: friend_insert_input!
  on_conflict: friend_on_conflict
}

# on conflict condition type for table "friend"
input friend_on_conflict {
  constraint: friend_constraint!
  update_columns: [friend_update_column!]!
  where: friend_bool_exp
}

# ordering options when selecting data from "friend"
input friend_order_by {
  friend: user_order_by
  friendId: order_by
  original: order_by
  user: user_order_by
  userId: order_by
}

# primary key columns input for table: "friend"
input friend_pk_columns_input {
  friendId: String!
  userId: String!
}

# select columns of table "friend"
enum friend_select_column {
  # column name
  friendId

  # column name
  original

  # column name
  userId
}

# input type for updating data in table "friend"
input friend_set_input {
  friendId: String
  original: Boolean
  userId: String
}

# update columns of table "friend"
enum friend_update_column {
  # column name
  friendId

  # column name
  original

  # column name
  userId
}

# columns and relationships of "friendRequest"
type friendRequest {
  date: timestamptz!
  recipient: String!
  sender: String!

  # An object relationship
  user: user!

  # An object relationship
  userByRecipient: user!
}

# aggregated selection of "friendRequest"
type friendRequest_aggregate {
  aggregate: friendRequest_aggregate_fields
  nodes: [friendRequest!]!
}

# aggregate fields of "friendRequest"
type friendRequest_aggregate_fields {
  count(columns: [friendRequest_select_column!], distinct: Boolean): Int
  max: friendRequest_max_fields
  min: friendRequest_min_fields
}

# order by aggregate values of table "friendRequest"
input friendRequest_aggregate_order_by {
  count: order_by
  max: friendRequest_max_order_by
  min: friendRequest_min_order_by
}

# input type for inserting array relation for remote table "friendRequest"
input friendRequest_arr_rel_insert_input {
  data: [friendRequest_insert_input!]!
  on_conflict: friendRequest_on_conflict
}

# Boolean expression to filter rows from the table "friendRequest". All fields are combined with a logical 'AND'.
input friendRequest_bool_exp {
  _and: [friendRequest_bool_exp]
  _not: friendRequest_bool_exp
  _or: [friendRequest_bool_exp]
  date: timestamptz_comparison_exp
  recipient: String_comparison_exp
  sender: String_comparison_exp
  user: user_bool_exp
  userByRecipient: user_bool_exp
}

# unique or primary key constraints on table "friendRequest"
enum friendRequest_constraint {
  # unique or primary key constraint
  pendingFriend_pkey
}

# input type for inserting data into table "friendRequest"
input friendRequest_insert_input {
  date: timestamptz
  recipient: String
  sender: String
  user: user_obj_rel_insert_input
  userByRecipient: user_obj_rel_insert_input
}

# aggregate max on columns
type friendRequest_max_fields {
  date: timestamptz
  recipient: String
  sender: String
}

# order by max() on columns of table "friendRequest"
input friendRequest_max_order_by {
  date: order_by
  recipient: order_by
  sender: order_by
}

# aggregate min on columns
type friendRequest_min_fields {
  date: timestamptz
  recipient: String
  sender: String
}

# order by min() on columns of table "friendRequest"
input friendRequest_min_order_by {
  date: order_by
  recipient: order_by
  sender: order_by
}

# response of any mutation on the table "friendRequest"
type friendRequest_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [friendRequest!]!
}

# input type for inserting object relation for remote table "friendRequest"
input friendRequest_obj_rel_insert_input {
  data: friendRequest_insert_input!
  on_conflict: friendRequest_on_conflict
}

# on conflict condition type for table "friendRequest"
input friendRequest_on_conflict {
  constraint: friendRequest_constraint!
  update_columns: [friendRequest_update_column!]!
  where: friendRequest_bool_exp
}

# ordering options when selecting data from "friendRequest"
input friendRequest_order_by {
  date: order_by
  recipient: order_by
  sender: order_by
  user: user_order_by
  userByRecipient: user_order_by
}

# primary key columns input for table: "friendRequest"
input friendRequest_pk_columns_input {
  recipient: String!
  sender: String!
}

# select columns of table "friendRequest"
enum friendRequest_select_column {
  # column name
  date

  # column name
  recipient

  # column name
  sender
}

# input type for updating data in table "friendRequest"
input friendRequest_set_input {
  date: timestamptz
  recipient: String
  sender: String
}

# update columns of table "friendRequest"
enum friendRequest_update_column {
  # column name
  date

  # column name
  recipient

  # column name
  sender
}

# columns and relationships of "friendView"
type friendView {
  college: String
  description: String
  email: String
  id: String
  image: String
  isOfficial: Boolean
  links(
    # JSON select path
    path: String
  ): jsonb
  name: String
  userId: String
  year: Int
}

# aggregated selection of "friendView"
type friendView_aggregate {
  aggregate: friendView_aggregate_fields
  nodes: [friendView!]!
}

# aggregate fields of "friendView"
type friendView_aggregate_fields {
  avg: friendView_avg_fields
  count(columns: [friendView_select_column!], distinct: Boolean): Int
  max: friendView_max_fields
  min: friendView_min_fields
  stddev: friendView_stddev_fields
  stddev_pop: friendView_stddev_pop_fields
  stddev_samp: friendView_stddev_samp_fields
  sum: friendView_sum_fields
  var_pop: friendView_var_pop_fields
  var_samp: friendView_var_samp_fields
  variance: friendView_variance_fields
}

# order by aggregate values of table "friendView"
input friendView_aggregate_order_by {
  avg: friendView_avg_order_by
  count: order_by
  max: friendView_max_order_by
  min: friendView_min_order_by
  stddev: friendView_stddev_order_by
  stddev_pop: friendView_stddev_pop_order_by
  stddev_samp: friendView_stddev_samp_order_by
  sum: friendView_sum_order_by
  var_pop: friendView_var_pop_order_by
  var_samp: friendView_var_samp_order_by
  variance: friendView_variance_order_by
}

# append existing jsonb value of filtered columns with new jsonb value
input friendView_append_input {
  links: jsonb
}

# aggregate avg on columns
type friendView_avg_fields {
  year: Float
}

# order by avg() on columns of table "friendView"
input friendView_avg_order_by {
  year: order_by
}

# Boolean expression to filter rows from the table "friendView". All fields are combined with a logical 'AND'.
input friendView_bool_exp {
  _and: [friendView_bool_exp]
  _not: friendView_bool_exp
  _or: [friendView_bool_exp]
  college: String_comparison_exp
  description: String_comparison_exp
  email: String_comparison_exp
  id: String_comparison_exp
  image: String_comparison_exp
  isOfficial: Boolean_comparison_exp
  links: jsonb_comparison_exp
  name: String_comparison_exp
  userId: String_comparison_exp
  year: Int_comparison_exp
}

# delete the field or element with specified path (for JSON arrays, negative integers count from the end)
input friendView_delete_at_path_input {
  links: [String]
}

# delete the array element with specified index (negative integers count from the
# end). throws an error if top level container is not an array
input friendView_delete_elem_input {
  links: Int
}

# delete key/value pair or string element. key/value pairs are matched based on their key value
input friendView_delete_key_input {
  links: String
}

# aggregate max on columns
type friendView_max_fields {
  college: String
  description: String
  email: String
  id: String
  image: String
  name: String
  userId: String
  year: Int
}

# order by max() on columns of table "friendView"
input friendView_max_order_by {
  college: order_by
  description: order_by
  email: order_by
  id: order_by
  image: order_by
  name: order_by
  userId: order_by
  year: order_by
}

# aggregate min on columns
type friendView_min_fields {
  college: String
  description: String
  email: String
  id: String
  image: String
  name: String
  userId: String
  year: Int
}

# order by min() on columns of table "friendView"
input friendView_min_order_by {
  college: order_by
  description: order_by
  email: order_by
  id: order_by
  image: order_by
  name: order_by
  userId: order_by
  year: order_by
}

# ordering options when selecting data from "friendView"
input friendView_order_by {
  college: order_by
  description: order_by
  email: order_by
  id: order_by
  image: order_by
  isOfficial: order_by
  links: order_by
  name: order_by
  userId: order_by
  year: order_by
}

# prepend existing jsonb value of filtered columns with new jsonb value
input friendView_prepend_input {
  links: jsonb
}

# select columns of table "friendView"
enum friendView_select_column {
  # column name
  college

  # column name
  description

  # column name
  email

  # column name
  id

  # column name
  image

  # column name
  isOfficial

  # column name
  links

  # column name
  name

  # column name
  userId

  # column name
  year
}

# aggregate stddev on columns
type friendView_stddev_fields {
  year: Float
}

# order by stddev() on columns of table "friendView"
input friendView_stddev_order_by {
  year: order_by
}

# aggregate stddev_pop on columns
type friendView_stddev_pop_fields {
  year: Float
}

# order by stddev_pop() on columns of table "friendView"
input friendView_stddev_pop_order_by {
  year: order_by
}

# aggregate stddev_samp on columns
type friendView_stddev_samp_fields {
  year: Float
}

# order by stddev_samp() on columns of table "friendView"
input friendView_stddev_samp_order_by {
  year: order_by
}

# aggregate sum on columns
type friendView_sum_fields {
  year: Int
}

# order by sum() on columns of table "friendView"
input friendView_sum_order_by {
  year: order_by
}

# aggregate var_pop on columns
type friendView_var_pop_fields {
  year: Float
}

# order by var_pop() on columns of table "friendView"
input friendView_var_pop_order_by {
  year: order_by
}

# aggregate var_samp on columns
type friendView_var_samp_fields {
  year: Float
}

# order by var_samp() on columns of table "friendView"
input friendView_var_samp_order_by {
  year: order_by
}

# aggregate variance on columns
type friendView_variance_fields {
  year: Float
}

# order by variance() on columns of table "friendView"
input friendView_variance_order_by {
  year: order_by
}

# columns and relationships of "group"
type group {
  description: String
  email: String!

  # An array relationship
  events(
    # distinct select on columns
    distinct_on: [groupEvent_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupEvent_order_by!]

    # filter the rows returned
    where: groupEvent_bool_exp
  ): [groupEvent!]!

  # An aggregated array relationship
  events_aggregate(
    # distinct select on columns
    distinct_on: [groupEvent_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupEvent_order_by!]

    # filter the rows returned
    where: groupEvent_bool_exp
  ): groupEvent_aggregate!
  gallery(
    # JSON select path
    path: String
  ): jsonb!
  id: uuid!
  image: String!
  links(
    # JSON select path
    path: String
  ): jsonb!

  # An array relationship
  members(
    # distinct select on columns
    distinct_on: [userMember_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userMember_order_by!]

    # filter the rows returned
    where: userMember_bool_exp
  ): [userMember!]!

  # An aggregated array relationship
  members_aggregate(
    # distinct select on columns
    distinct_on: [userMember_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userMember_order_by!]

    # filter the rows returned
    where: userMember_bool_exp
  ): userMember_aggregate!
  name: String!

  # An array relationship
  owners(
    # distinct select on columns
    distinct_on: [userOwner_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userOwner_order_by!]

    # filter the rows returned
    where: userOwner_bool_exp
  ): [userOwner!]!

  # An aggregated array relationship
  owners_aggregate(
    # distinct select on columns
    distinct_on: [userOwner_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userOwner_order_by!]

    # filter the rows returned
    where: userOwner_bool_exp
  ): userOwner_aggregate!

  # An array relationship
  questions(
    # distinct select on columns
    distinct_on: [groupQuestion_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupQuestion_order_by!]

    # filter the rows returned
    where: groupQuestion_bool_exp
  ): [groupQuestion!]!

  # An aggregated array relationship
  questions_aggregate(
    # distinct select on columns
    distinct_on: [groupQuestion_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupQuestion_order_by!]

    # filter the rows returned
    where: groupQuestion_bool_exp
  ): groupQuestion_aggregate!

  # An array relationship
  reviews(
    # distinct select on columns
    distinct_on: [review_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [review_order_by!]

    # filter the rows returned
    where: review_bool_exp
  ): [review!]!

  # An aggregated array relationship
  reviews_aggregate(
    # distinct select on columns
    distinct_on: [review_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [review_order_by!]

    # filter the rows returned
    where: review_bool_exp
  ): review_aggregate!

  # An array relationship
  tags(
    # distinct select on columns
    distinct_on: [groupInterest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupInterest_order_by!]

    # filter the rows returned
    where: groupInterest_bool_exp
  ): [groupInterest!]!

  # An aggregated array relationship
  tags_aggregate(
    # distinct select on columns
    distinct_on: [groupInterest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupInterest_order_by!]

    # filter the rows returned
    where: groupInterest_bool_exp
  ): groupInterest_aggregate!

  # An array relationship
  trophies(
    # distinct select on columns
    distinct_on: [trophyGroupView_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [trophyGroupView_order_by!]

    # filter the rows returned
    where: trophyGroupView_bool_exp
  ): [trophyGroupView!]!

  # An aggregated array relationship
  trophies_aggregate(
    # distinct select on columns
    distinct_on: [trophyGroupView_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [trophyGroupView_order_by!]

    # filter the rows returned
    where: trophyGroupView_bool_exp
  ): trophyGroupView_aggregate!
  unsubscribable: Boolean!
  website: String
}

# aggregated selection of "group"
type group_aggregate {
  aggregate: group_aggregate_fields
  nodes: [group!]!
}

# aggregate fields of "group"
type group_aggregate_fields {
  count(columns: [group_select_column!], distinct: Boolean): Int
  max: group_max_fields
  min: group_min_fields
}

# order by aggregate values of table "group"
input group_aggregate_order_by {
  count: order_by
  max: group_max_order_by
  min: group_min_order_by
}

# append existing jsonb value of filtered columns with new jsonb value
input group_append_input {
  gallery: jsonb
  links: jsonb
}

# input type for inserting array relation for remote table "group"
input group_arr_rel_insert_input {
  data: [group_insert_input!]!
  on_conflict: group_on_conflict
}

# Boolean expression to filter rows from the table "group". All fields are combined with a logical 'AND'.
input group_bool_exp {
  _and: [group_bool_exp]
  _not: group_bool_exp
  _or: [group_bool_exp]
  description: String_comparison_exp
  email: String_comparison_exp
  events: groupEvent_bool_exp
  gallery: jsonb_comparison_exp
  id: uuid_comparison_exp
  image: String_comparison_exp
  links: jsonb_comparison_exp
  members: userMember_bool_exp
  name: String_comparison_exp
  owners: userOwner_bool_exp
  questions: groupQuestion_bool_exp
  reviews: review_bool_exp
  tags: groupInterest_bool_exp
  trophies: trophyGroupView_bool_exp
  unsubscribable: Boolean_comparison_exp
  website: String_comparison_exp
}

# unique or primary key constraints on table "group"
enum group_constraint {
  # unique or primary key constraint
  group_id_key

  # unique or primary key constraint
  group_pkey
}

# delete the field or element with specified path (for JSON arrays, negative integers count from the end)
input group_delete_at_path_input {
  gallery: [String]
  links: [String]
}

# delete the array element with specified index (negative integers count from the
# end). throws an error if top level container is not an array
input group_delete_elem_input {
  gallery: Int
  links: Int
}

# delete key/value pair or string element. key/value pairs are matched based on their key value
input group_delete_key_input {
  gallery: String
  links: String
}

# input type for inserting data into table "group"
input group_insert_input {
  description: String
  email: String
  events: groupEvent_arr_rel_insert_input
  gallery: jsonb
  id: uuid
  image: String
  links: jsonb
  members: userMember_arr_rel_insert_input
  name: String
  owners: userOwner_arr_rel_insert_input
  questions: groupQuestion_arr_rel_insert_input
  reviews: review_arr_rel_insert_input
  tags: groupInterest_arr_rel_insert_input
  unsubscribable: Boolean
  website: String
}

# aggregate max on columns
type group_max_fields {
  description: String
  email: String
  id: uuid
  image: String
  name: String
  website: String
}

# order by max() on columns of table "group"
input group_max_order_by {
  description: order_by
  email: order_by
  id: order_by
  image: order_by
  name: order_by
  website: order_by
}

# aggregate min on columns
type group_min_fields {
  description: String
  email: String
  id: uuid
  image: String
  name: String
  website: String
}

# order by min() on columns of table "group"
input group_min_order_by {
  description: order_by
  email: order_by
  id: order_by
  image: order_by
  name: order_by
  website: order_by
}

# response of any mutation on the table "group"
type group_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [group!]!
}

# input type for inserting object relation for remote table "group"
input group_obj_rel_insert_input {
  data: group_insert_input!
  on_conflict: group_on_conflict
}

# on conflict condition type for table "group"
input group_on_conflict {
  constraint: group_constraint!
  update_columns: [group_update_column!]!
  where: group_bool_exp
}

# ordering options when selecting data from "group"
input group_order_by {
  description: order_by
  email: order_by
  events_aggregate: groupEvent_aggregate_order_by
  gallery: order_by
  id: order_by
  image: order_by
  links: order_by
  members_aggregate: userMember_aggregate_order_by
  name: order_by
  owners_aggregate: userOwner_aggregate_order_by
  questions_aggregate: groupQuestion_aggregate_order_by
  reviews_aggregate: review_aggregate_order_by
  tags_aggregate: groupInterest_aggregate_order_by
  trophies_aggregate: trophyGroupView_aggregate_order_by
  unsubscribable: order_by
  website: order_by
}

# primary key columns input for table: "group"
input group_pk_columns_input {
  id: uuid!
}

# prepend existing jsonb value of filtered columns with new jsonb value
input group_prepend_input {
  gallery: jsonb
  links: jsonb
}

# select columns of table "group"
enum group_select_column {
  # column name
  description

  # column name
  email

  # column name
  gallery

  # column name
  id

  # column name
  image

  # column name
  links

  # column name
  name

  # column name
  unsubscribable

  # column name
  website
}

# input type for updating data in table "group"
input group_set_input {
  description: String
  email: String
  gallery: jsonb
  id: uuid
  image: String
  links: jsonb
  name: String
  unsubscribable: Boolean
  website: String
}

# update columns of table "group"
enum group_update_column {
  # column name
  description

  # column name
  email

  # column name
  gallery

  # column name
  id

  # column name
  image

  # column name
  links

  # column name
  name

  # column name
  unsubscribable

  # column name
  website
}

# columns and relationships of "groupEvent"
type groupEvent {
  # An object relationship
  event: event!
  eventId: uuid!

  # An object relationship
  group: group!
  groupId: uuid!
}

# aggregated selection of "groupEvent"
type groupEvent_aggregate {
  aggregate: groupEvent_aggregate_fields
  nodes: [groupEvent!]!
}

# aggregate fields of "groupEvent"
type groupEvent_aggregate_fields {
  count(columns: [groupEvent_select_column!], distinct: Boolean): Int
  max: groupEvent_max_fields
  min: groupEvent_min_fields
}

# order by aggregate values of table "groupEvent"
input groupEvent_aggregate_order_by {
  count: order_by
  max: groupEvent_max_order_by
  min: groupEvent_min_order_by
}

# input type for inserting array relation for remote table "groupEvent"
input groupEvent_arr_rel_insert_input {
  data: [groupEvent_insert_input!]!
  on_conflict: groupEvent_on_conflict
}

# Boolean expression to filter rows from the table "groupEvent". All fields are combined with a logical 'AND'.
input groupEvent_bool_exp {
  _and: [groupEvent_bool_exp]
  _not: groupEvent_bool_exp
  _or: [groupEvent_bool_exp]
  event: event_bool_exp
  eventId: uuid_comparison_exp
  group: group_bool_exp
  groupId: uuid_comparison_exp
}

# unique or primary key constraints on table "groupEvent"
enum groupEvent_constraint {
  # unique or primary key constraint
  groupEvent_pkey
}

# input type for inserting data into table "groupEvent"
input groupEvent_insert_input {
  event: event_obj_rel_insert_input
  eventId: uuid
  group: group_obj_rel_insert_input
  groupId: uuid
}

# aggregate max on columns
type groupEvent_max_fields {
  eventId: uuid
  groupId: uuid
}

# order by max() on columns of table "groupEvent"
input groupEvent_max_order_by {
  eventId: order_by
  groupId: order_by
}

# aggregate min on columns
type groupEvent_min_fields {
  eventId: uuid
  groupId: uuid
}

# order by min() on columns of table "groupEvent"
input groupEvent_min_order_by {
  eventId: order_by
  groupId: order_by
}

# response of any mutation on the table "groupEvent"
type groupEvent_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [groupEvent!]!
}

# input type for inserting object relation for remote table "groupEvent"
input groupEvent_obj_rel_insert_input {
  data: groupEvent_insert_input!
  on_conflict: groupEvent_on_conflict
}

# on conflict condition type for table "groupEvent"
input groupEvent_on_conflict {
  constraint: groupEvent_constraint!
  update_columns: [groupEvent_update_column!]!
  where: groupEvent_bool_exp
}

# ordering options when selecting data from "groupEvent"
input groupEvent_order_by {
  event: event_order_by
  eventId: order_by
  group: group_order_by
  groupId: order_by
}

# primary key columns input for table: "groupEvent"
input groupEvent_pk_columns_input {
  eventId: uuid!
  groupId: uuid!
}

# select columns of table "groupEvent"
enum groupEvent_select_column {
  # column name
  eventId

  # column name
  groupId
}

# input type for updating data in table "groupEvent"
input groupEvent_set_input {
  eventId: uuid
  groupId: uuid
}

# update columns of table "groupEvent"
enum groupEvent_update_column {
  # column name
  eventId

  # column name
  groupId
}

# columns and relationships of "groupInterest"
type groupInterest {
  # An object relationship
  group: group!
  groupId: uuid!

  # An object relationship
  interest: interest!
  interestId: Int!
}

# aggregated selection of "groupInterest"
type groupInterest_aggregate {
  aggregate: groupInterest_aggregate_fields
  nodes: [groupInterest!]!
}

# aggregate fields of "groupInterest"
type groupInterest_aggregate_fields {
  avg: groupInterest_avg_fields
  count(columns: [groupInterest_select_column!], distinct: Boolean): Int
  max: groupInterest_max_fields
  min: groupInterest_min_fields
  stddev: groupInterest_stddev_fields
  stddev_pop: groupInterest_stddev_pop_fields
  stddev_samp: groupInterest_stddev_samp_fields
  sum: groupInterest_sum_fields
  var_pop: groupInterest_var_pop_fields
  var_samp: groupInterest_var_samp_fields
  variance: groupInterest_variance_fields
}

# order by aggregate values of table "groupInterest"
input groupInterest_aggregate_order_by {
  avg: groupInterest_avg_order_by
  count: order_by
  max: groupInterest_max_order_by
  min: groupInterest_min_order_by
  stddev: groupInterest_stddev_order_by
  stddev_pop: groupInterest_stddev_pop_order_by
  stddev_samp: groupInterest_stddev_samp_order_by
  sum: groupInterest_sum_order_by
  var_pop: groupInterest_var_pop_order_by
  var_samp: groupInterest_var_samp_order_by
  variance: groupInterest_variance_order_by
}

# input type for inserting array relation for remote table "groupInterest"
input groupInterest_arr_rel_insert_input {
  data: [groupInterest_insert_input!]!
  on_conflict: groupInterest_on_conflict
}

# aggregate avg on columns
type groupInterest_avg_fields {
  interestId: Float
}

# order by avg() on columns of table "groupInterest"
input groupInterest_avg_order_by {
  interestId: order_by
}

# Boolean expression to filter rows from the table "groupInterest". All fields are combined with a logical 'AND'.
input groupInterest_bool_exp {
  _and: [groupInterest_bool_exp]
  _not: groupInterest_bool_exp
  _or: [groupInterest_bool_exp]
  group: group_bool_exp
  groupId: uuid_comparison_exp
  interest: interest_bool_exp
  interestId: Int_comparison_exp
}

# unique or primary key constraints on table "groupInterest"
enum groupInterest_constraint {
  # unique or primary key constraint
  groupInterest_pkey
}

# input type for incrementing integer column in table "groupInterest"
input groupInterest_inc_input {
  interestId: Int
}

# input type for inserting data into table "groupInterest"
input groupInterest_insert_input {
  group: group_obj_rel_insert_input
  groupId: uuid
  interest: interest_obj_rel_insert_input
  interestId: Int
}

# aggregate max on columns
type groupInterest_max_fields {
  groupId: uuid
  interestId: Int
}

# order by max() on columns of table "groupInterest"
input groupInterest_max_order_by {
  groupId: order_by
  interestId: order_by
}

# aggregate min on columns
type groupInterest_min_fields {
  groupId: uuid
  interestId: Int
}

# order by min() on columns of table "groupInterest"
input groupInterest_min_order_by {
  groupId: order_by
  interestId: order_by
}

# response of any mutation on the table "groupInterest"
type groupInterest_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [groupInterest!]!
}

# input type for inserting object relation for remote table "groupInterest"
input groupInterest_obj_rel_insert_input {
  data: groupInterest_insert_input!
  on_conflict: groupInterest_on_conflict
}

# on conflict condition type for table "groupInterest"
input groupInterest_on_conflict {
  constraint: groupInterest_constraint!
  update_columns: [groupInterest_update_column!]!
  where: groupInterest_bool_exp
}

# ordering options when selecting data from "groupInterest"
input groupInterest_order_by {
  group: group_order_by
  groupId: order_by
  interest: interest_order_by
  interestId: order_by
}

# primary key columns input for table: "groupInterest"
input groupInterest_pk_columns_input {
  groupId: uuid!
  interestId: Int!
}

# select columns of table "groupInterest"
enum groupInterest_select_column {
  # column name
  groupId

  # column name
  interestId
}

# input type for updating data in table "groupInterest"
input groupInterest_set_input {
  groupId: uuid
  interestId: Int
}

# aggregate stddev on columns
type groupInterest_stddev_fields {
  interestId: Float
}

# order by stddev() on columns of table "groupInterest"
input groupInterest_stddev_order_by {
  interestId: order_by
}

# aggregate stddev_pop on columns
type groupInterest_stddev_pop_fields {
  interestId: Float
}

# order by stddev_pop() on columns of table "groupInterest"
input groupInterest_stddev_pop_order_by {
  interestId: order_by
}

# aggregate stddev_samp on columns
type groupInterest_stddev_samp_fields {
  interestId: Float
}

# order by stddev_samp() on columns of table "groupInterest"
input groupInterest_stddev_samp_order_by {
  interestId: order_by
}

# aggregate sum on columns
type groupInterest_sum_fields {
  interestId: Int
}

# order by sum() on columns of table "groupInterest"
input groupInterest_sum_order_by {
  interestId: order_by
}

# update columns of table "groupInterest"
enum groupInterest_update_column {
  # column name
  groupId

  # column name
  interestId
}

# aggregate var_pop on columns
type groupInterest_var_pop_fields {
  interestId: Float
}

# order by var_pop() on columns of table "groupInterest"
input groupInterest_var_pop_order_by {
  interestId: order_by
}

# aggregate var_samp on columns
type groupInterest_var_samp_fields {
  interestId: Float
}

# order by var_samp() on columns of table "groupInterest"
input groupInterest_var_samp_order_by {
  interestId: order_by
}

# aggregate variance on columns
type groupInterest_variance_fields {
  interestId: Float
}

# order by variance() on columns of table "groupInterest"
input groupInterest_variance_order_by {
  interestId: order_by
}

# columns and relationships of "groupQuestion"
type groupQuestion {
  # An object relationship
  group: group!
  groupId: uuid!

  # An object relationship
  question: question!
  questionId: Int!
}

# aggregated selection of "groupQuestion"
type groupQuestion_aggregate {
  aggregate: groupQuestion_aggregate_fields
  nodes: [groupQuestion!]!
}

# aggregate fields of "groupQuestion"
type groupQuestion_aggregate_fields {
  avg: groupQuestion_avg_fields
  count(columns: [groupQuestion_select_column!], distinct: Boolean): Int
  max: groupQuestion_max_fields
  min: groupQuestion_min_fields
  stddev: groupQuestion_stddev_fields
  stddev_pop: groupQuestion_stddev_pop_fields
  stddev_samp: groupQuestion_stddev_samp_fields
  sum: groupQuestion_sum_fields
  var_pop: groupQuestion_var_pop_fields
  var_samp: groupQuestion_var_samp_fields
  variance: groupQuestion_variance_fields
}

# order by aggregate values of table "groupQuestion"
input groupQuestion_aggregate_order_by {
  avg: groupQuestion_avg_order_by
  count: order_by
  max: groupQuestion_max_order_by
  min: groupQuestion_min_order_by
  stddev: groupQuestion_stddev_order_by
  stddev_pop: groupQuestion_stddev_pop_order_by
  stddev_samp: groupQuestion_stddev_samp_order_by
  sum: groupQuestion_sum_order_by
  var_pop: groupQuestion_var_pop_order_by
  var_samp: groupQuestion_var_samp_order_by
  variance: groupQuestion_variance_order_by
}

# input type for inserting array relation for remote table "groupQuestion"
input groupQuestion_arr_rel_insert_input {
  data: [groupQuestion_insert_input!]!
  on_conflict: groupQuestion_on_conflict
}

# aggregate avg on columns
type groupQuestion_avg_fields {
  questionId: Float
}

# order by avg() on columns of table "groupQuestion"
input groupQuestion_avg_order_by {
  questionId: order_by
}

# Boolean expression to filter rows from the table "groupQuestion". All fields are combined with a logical 'AND'.
input groupQuestion_bool_exp {
  _and: [groupQuestion_bool_exp]
  _not: groupQuestion_bool_exp
  _or: [groupQuestion_bool_exp]
  group: group_bool_exp
  groupId: uuid_comparison_exp
  question: question_bool_exp
  questionId: Int_comparison_exp
}

# unique or primary key constraints on table "groupQuestion"
enum groupQuestion_constraint {
  # unique or primary key constraint
  groupQuestion_pkey
}

# input type for incrementing integer column in table "groupQuestion"
input groupQuestion_inc_input {
  questionId: Int
}

# input type for inserting data into table "groupQuestion"
input groupQuestion_insert_input {
  group: group_obj_rel_insert_input
  groupId: uuid
  question: question_obj_rel_insert_input
  questionId: Int
}

# aggregate max on columns
type groupQuestion_max_fields {
  groupId: uuid
  questionId: Int
}

# order by max() on columns of table "groupQuestion"
input groupQuestion_max_order_by {
  groupId: order_by
  questionId: order_by
}

# aggregate min on columns
type groupQuestion_min_fields {
  groupId: uuid
  questionId: Int
}

# order by min() on columns of table "groupQuestion"
input groupQuestion_min_order_by {
  groupId: order_by
  questionId: order_by
}

# response of any mutation on the table "groupQuestion"
type groupQuestion_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [groupQuestion!]!
}

# input type for inserting object relation for remote table "groupQuestion"
input groupQuestion_obj_rel_insert_input {
  data: groupQuestion_insert_input!
  on_conflict: groupQuestion_on_conflict
}

# on conflict condition type for table "groupQuestion"
input groupQuestion_on_conflict {
  constraint: groupQuestion_constraint!
  update_columns: [groupQuestion_update_column!]!
  where: groupQuestion_bool_exp
}

# ordering options when selecting data from "groupQuestion"
input groupQuestion_order_by {
  group: group_order_by
  groupId: order_by
  question: question_order_by
  questionId: order_by
}

# primary key columns input for table: "groupQuestion"
input groupQuestion_pk_columns_input {
  groupId: uuid!
  questionId: Int!
}

# select columns of table "groupQuestion"
enum groupQuestion_select_column {
  # column name
  groupId

  # column name
  questionId
}

# input type for updating data in table "groupQuestion"
input groupQuestion_set_input {
  groupId: uuid
  questionId: Int
}

# aggregate stddev on columns
type groupQuestion_stddev_fields {
  questionId: Float
}

# order by stddev() on columns of table "groupQuestion"
input groupQuestion_stddev_order_by {
  questionId: order_by
}

# aggregate stddev_pop on columns
type groupQuestion_stddev_pop_fields {
  questionId: Float
}

# order by stddev_pop() on columns of table "groupQuestion"
input groupQuestion_stddev_pop_order_by {
  questionId: order_by
}

# aggregate stddev_samp on columns
type groupQuestion_stddev_samp_fields {
  questionId: Float
}

# order by stddev_samp() on columns of table "groupQuestion"
input groupQuestion_stddev_samp_order_by {
  questionId: order_by
}

# aggregate sum on columns
type groupQuestion_sum_fields {
  questionId: Int
}

# order by sum() on columns of table "groupQuestion"
input groupQuestion_sum_order_by {
  questionId: order_by
}

# update columns of table "groupQuestion"
enum groupQuestion_update_column {
  # column name
  groupId

  # column name
  questionId
}

# aggregate var_pop on columns
type groupQuestion_var_pop_fields {
  questionId: Float
}

# order by var_pop() on columns of table "groupQuestion"
input groupQuestion_var_pop_order_by {
  questionId: order_by
}

# aggregate var_samp on columns
type groupQuestion_var_samp_fields {
  questionId: Float
}

# order by var_samp() on columns of table "groupQuestion"
input groupQuestion_var_samp_order_by {
  questionId: order_by
}

# aggregate variance on columns
type groupQuestion_variance_fields {
  questionId: Float
}

# order by variance() on columns of table "groupQuestion"
input groupQuestion_variance_order_by {
  questionId: order_by
}

# columns and relationships of "groupTrophy"
type groupTrophy {
  # An object relationship
  group: group!
  groupId: uuid!

  # An object relationship
  trophy: trophy!
  trophyId: uuid!
}

# aggregated selection of "groupTrophy"
type groupTrophy_aggregate {
  aggregate: groupTrophy_aggregate_fields
  nodes: [groupTrophy!]!
}

# aggregate fields of "groupTrophy"
type groupTrophy_aggregate_fields {
  count(columns: [groupTrophy_select_column!], distinct: Boolean): Int
  max: groupTrophy_max_fields
  min: groupTrophy_min_fields
}

# order by aggregate values of table "groupTrophy"
input groupTrophy_aggregate_order_by {
  count: order_by
  max: groupTrophy_max_order_by
  min: groupTrophy_min_order_by
}

# input type for inserting array relation for remote table "groupTrophy"
input groupTrophy_arr_rel_insert_input {
  data: [groupTrophy_insert_input!]!
  on_conflict: groupTrophy_on_conflict
}

# Boolean expression to filter rows from the table "groupTrophy". All fields are combined with a logical 'AND'.
input groupTrophy_bool_exp {
  _and: [groupTrophy_bool_exp]
  _not: groupTrophy_bool_exp
  _or: [groupTrophy_bool_exp]
  group: group_bool_exp
  groupId: uuid_comparison_exp
  trophy: trophy_bool_exp
  trophyId: uuid_comparison_exp
}

# unique or primary key constraints on table "groupTrophy"
enum groupTrophy_constraint {
  # unique or primary key constraint
  groupTrophy_pkey
}

# input type for inserting data into table "groupTrophy"
input groupTrophy_insert_input {
  group: group_obj_rel_insert_input
  groupId: uuid
  trophy: trophy_obj_rel_insert_input
  trophyId: uuid
}

# aggregate max on columns
type groupTrophy_max_fields {
  groupId: uuid
  trophyId: uuid
}

# order by max() on columns of table "groupTrophy"
input groupTrophy_max_order_by {
  groupId: order_by
  trophyId: order_by
}

# aggregate min on columns
type groupTrophy_min_fields {
  groupId: uuid
  trophyId: uuid
}

# order by min() on columns of table "groupTrophy"
input groupTrophy_min_order_by {
  groupId: order_by
  trophyId: order_by
}

# response of any mutation on the table "groupTrophy"
type groupTrophy_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [groupTrophy!]!
}

# input type for inserting object relation for remote table "groupTrophy"
input groupTrophy_obj_rel_insert_input {
  data: groupTrophy_insert_input!
  on_conflict: groupTrophy_on_conflict
}

# on conflict condition type for table "groupTrophy"
input groupTrophy_on_conflict {
  constraint: groupTrophy_constraint!
  update_columns: [groupTrophy_update_column!]!
  where: groupTrophy_bool_exp
}

# ordering options when selecting data from "groupTrophy"
input groupTrophy_order_by {
  group: group_order_by
  groupId: order_by
  trophy: trophy_order_by
  trophyId: order_by
}

# primary key columns input for table: "groupTrophy"
input groupTrophy_pk_columns_input {
  groupId: uuid!
  trophyId: uuid!
}

# select columns of table "groupTrophy"
enum groupTrophy_select_column {
  # column name
  groupId

  # column name
  trophyId
}

# input type for updating data in table "groupTrophy"
input groupTrophy_set_input {
  groupId: uuid
  trophyId: uuid
}

# update columns of table "groupTrophy"
enum groupTrophy_update_column {
  # column name
  groupId

  # column name
  trophyId
}

# expression to compare columns of type Int. All fields are combined with logical 'AND'.
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

# columns and relationships of "interest"
type interest {
  aliases(
    # JSON select path
    path: String
  ): jsonb!

  # An array relationship
  groupInterests(
    # distinct select on columns
    distinct_on: [groupInterest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupInterest_order_by!]

    # filter the rows returned
    where: groupInterest_bool_exp
  ): [groupInterest!]!

  # An aggregated array relationship
  groupInterests_aggregate(
    # distinct select on columns
    distinct_on: [groupInterest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupInterest_order_by!]

    # filter the rows returned
    where: groupInterest_bool_exp
  ): groupInterest_aggregate!
  id: Int!
  name: String!

  # An array relationship
  userInterests(
    # distinct select on columns
    distinct_on: [userInterest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userInterest_order_by!]

    # filter the rows returned
    where: userInterest_bool_exp
  ): [userInterest!]!

  # An aggregated array relationship
  userInterests_aggregate(
    # distinct select on columns
    distinct_on: [userInterest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userInterest_order_by!]

    # filter the rows returned
    where: userInterest_bool_exp
  ): userInterest_aggregate!
}

# aggregated selection of "interest"
type interest_aggregate {
  aggregate: interest_aggregate_fields
  nodes: [interest!]!
}

# aggregate fields of "interest"
type interest_aggregate_fields {
  avg: interest_avg_fields
  count(columns: [interest_select_column!], distinct: Boolean): Int
  max: interest_max_fields
  min: interest_min_fields
  stddev: interest_stddev_fields
  stddev_pop: interest_stddev_pop_fields
  stddev_samp: interest_stddev_samp_fields
  sum: interest_sum_fields
  var_pop: interest_var_pop_fields
  var_samp: interest_var_samp_fields
  variance: interest_variance_fields
}

# order by aggregate values of table "interest"
input interest_aggregate_order_by {
  avg: interest_avg_order_by
  count: order_by
  max: interest_max_order_by
  min: interest_min_order_by
  stddev: interest_stddev_order_by
  stddev_pop: interest_stddev_pop_order_by
  stddev_samp: interest_stddev_samp_order_by
  sum: interest_sum_order_by
  var_pop: interest_var_pop_order_by
  var_samp: interest_var_samp_order_by
  variance: interest_variance_order_by
}

# append existing jsonb value of filtered columns with new jsonb value
input interest_append_input {
  aliases: jsonb
}

# input type for inserting array relation for remote table "interest"
input interest_arr_rel_insert_input {
  data: [interest_insert_input!]!
  on_conflict: interest_on_conflict
}

# aggregate avg on columns
type interest_avg_fields {
  id: Float
}

# order by avg() on columns of table "interest"
input interest_avg_order_by {
  id: order_by
}

# Boolean expression to filter rows from the table "interest". All fields are combined with a logical 'AND'.
input interest_bool_exp {
  _and: [interest_bool_exp]
  _not: interest_bool_exp
  _or: [interest_bool_exp]
  aliases: jsonb_comparison_exp
  groupInterests: groupInterest_bool_exp
  id: Int_comparison_exp
  name: String_comparison_exp
  userInterests: userInterest_bool_exp
}

# unique or primary key constraints on table "interest"
enum interest_constraint {
  # unique or primary key constraint
  interest_id_key

  # unique or primary key constraint
  interests_pkey
}

# delete the field or element with specified path (for JSON arrays, negative integers count from the end)
input interest_delete_at_path_input {
  aliases: [String]
}

# delete the array element with specified index (negative integers count from the
# end). throws an error if top level container is not an array
input interest_delete_elem_input {
  aliases: Int
}

# delete key/value pair or string element. key/value pairs are matched based on their key value
input interest_delete_key_input {
  aliases: String
}

# input type for incrementing integer column in table "interest"
input interest_inc_input {
  id: Int
}

# input type for inserting data into table "interest"
input interest_insert_input {
  aliases: jsonb
  groupInterests: groupInterest_arr_rel_insert_input
  id: Int
  name: String
  userInterests: userInterest_arr_rel_insert_input
}

# aggregate max on columns
type interest_max_fields {
  id: Int
  name: String
}

# order by max() on columns of table "interest"
input interest_max_order_by {
  id: order_by
  name: order_by
}

# aggregate min on columns
type interest_min_fields {
  id: Int
  name: String
}

# order by min() on columns of table "interest"
input interest_min_order_by {
  id: order_by
  name: order_by
}

# response of any mutation on the table "interest"
type interest_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [interest!]!
}

# input type for inserting object relation for remote table "interest"
input interest_obj_rel_insert_input {
  data: interest_insert_input!
  on_conflict: interest_on_conflict
}

# on conflict condition type for table "interest"
input interest_on_conflict {
  constraint: interest_constraint!
  update_columns: [interest_update_column!]!
  where: interest_bool_exp
}

# ordering options when selecting data from "interest"
input interest_order_by {
  aliases: order_by
  groupInterests_aggregate: groupInterest_aggregate_order_by
  id: order_by
  name: order_by
  userInterests_aggregate: userInterest_aggregate_order_by
}

# primary key columns input for table: "interest"
input interest_pk_columns_input {
  name: String!
}

# prepend existing jsonb value of filtered columns with new jsonb value
input interest_prepend_input {
  aliases: jsonb
}

# select columns of table "interest"
enum interest_select_column {
  # column name
  aliases

  # column name
  id

  # column name
  name
}

# input type for updating data in table "interest"
input interest_set_input {
  aliases: jsonb
  id: Int
  name: String
}

# aggregate stddev on columns
type interest_stddev_fields {
  id: Float
}

# order by stddev() on columns of table "interest"
input interest_stddev_order_by {
  id: order_by
}

# aggregate stddev_pop on columns
type interest_stddev_pop_fields {
  id: Float
}

# order by stddev_pop() on columns of table "interest"
input interest_stddev_pop_order_by {
  id: order_by
}

# aggregate stddev_samp on columns
type interest_stddev_samp_fields {
  id: Float
}

# order by stddev_samp() on columns of table "interest"
input interest_stddev_samp_order_by {
  id: order_by
}

# aggregate sum on columns
type interest_sum_fields {
  id: Int
}

# order by sum() on columns of table "interest"
input interest_sum_order_by {
  id: order_by
}

# update columns of table "interest"
enum interest_update_column {
  # column name
  aliases

  # column name
  id

  # column name
  name
}

# aggregate var_pop on columns
type interest_var_pop_fields {
  id: Float
}

# order by var_pop() on columns of table "interest"
input interest_var_pop_order_by {
  id: order_by
}

# aggregate var_samp on columns
type interest_var_samp_fields {
  id: Float
}

# order by var_samp() on columns of table "interest"
input interest_var_samp_order_by {
  id: order_by
}

# aggregate variance on columns
type interest_variance_fields {
  id: Float
}

# order by variance() on columns of table "interest"
input interest_variance_order_by {
  id: order_by
}

scalar json

# expression to compare columns of type json. All fields are combined with logical 'AND'.
input json_comparison_exp {
  _eq: json
  _gt: json
  _gte: json
  _in: [json!]
  _is_null: Boolean
  _lt: json
  _lte: json
  _neq: json
  _nin: [json!]
}

scalar jsonb

# expression to compare columns of type jsonb. All fields are combined with logical 'AND'.
input jsonb_comparison_exp {
  # is the column contained in the given json value
  _contained_in: jsonb

  # does the column contain the given json value at the top level
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  # does the string exist as a top-level key in the column
  _has_key: String

  # do all of these strings exist as top-level keys in the column
  _has_keys_all: [String!]

  # do any of these strings exist as top-level keys in the column
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

# columns and relationships of "message"
type message {
  body: String!

  # An object relationship
  chat: chat!
  chatId: Int!
  date: timestamptz!
  id: Int!

  # An object relationship
  sender: user!
  senderId: String!
}

# aggregated selection of "message"
type message_aggregate {
  aggregate: message_aggregate_fields
  nodes: [message!]!
}

# aggregate fields of "message"
type message_aggregate_fields {
  avg: message_avg_fields
  count(columns: [message_select_column!], distinct: Boolean): Int
  max: message_max_fields
  min: message_min_fields
  stddev: message_stddev_fields
  stddev_pop: message_stddev_pop_fields
  stddev_samp: message_stddev_samp_fields
  sum: message_sum_fields
  var_pop: message_var_pop_fields
  var_samp: message_var_samp_fields
  variance: message_variance_fields
}

# order by aggregate values of table "message"
input message_aggregate_order_by {
  avg: message_avg_order_by
  count: order_by
  max: message_max_order_by
  min: message_min_order_by
  stddev: message_stddev_order_by
  stddev_pop: message_stddev_pop_order_by
  stddev_samp: message_stddev_samp_order_by
  sum: message_sum_order_by
  var_pop: message_var_pop_order_by
  var_samp: message_var_samp_order_by
  variance: message_variance_order_by
}

# input type for inserting array relation for remote table "message"
input message_arr_rel_insert_input {
  data: [message_insert_input!]!
  on_conflict: message_on_conflict
}

# aggregate avg on columns
type message_avg_fields {
  chatId: Float
  id: Float
}

# order by avg() on columns of table "message"
input message_avg_order_by {
  chatId: order_by
  id: order_by
}

# Boolean expression to filter rows from the table "message". All fields are combined with a logical 'AND'.
input message_bool_exp {
  _and: [message_bool_exp]
  _not: message_bool_exp
  _or: [message_bool_exp]
  body: String_comparison_exp
  chat: chat_bool_exp
  chatId: Int_comparison_exp
  date: timestamptz_comparison_exp
  id: Int_comparison_exp
  sender: user_bool_exp
  senderId: String_comparison_exp
}

# unique or primary key constraints on table "message"
enum message_constraint {
  # unique or primary key constraint
  message_pkey
}

# input type for incrementing integer column in table "message"
input message_inc_input {
  chatId: Int
  id: Int
}

# input type for inserting data into table "message"
input message_insert_input {
  body: String
  chat: chat_obj_rel_insert_input
  chatId: Int
  date: timestamptz
  id: Int
  sender: user_obj_rel_insert_input
  senderId: String
}

# aggregate max on columns
type message_max_fields {
  body: String
  chatId: Int
  date: timestamptz
  id: Int
  senderId: String
}

# order by max() on columns of table "message"
input message_max_order_by {
  body: order_by
  chatId: order_by
  date: order_by
  id: order_by
  senderId: order_by
}

# aggregate min on columns
type message_min_fields {
  body: String
  chatId: Int
  date: timestamptz
  id: Int
  senderId: String
}

# order by min() on columns of table "message"
input message_min_order_by {
  body: order_by
  chatId: order_by
  date: order_by
  id: order_by
  senderId: order_by
}

# response of any mutation on the table "message"
type message_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [message!]!
}

# input type for inserting object relation for remote table "message"
input message_obj_rel_insert_input {
  data: message_insert_input!
  on_conflict: message_on_conflict
}

# on conflict condition type for table "message"
input message_on_conflict {
  constraint: message_constraint!
  update_columns: [message_update_column!]!
  where: message_bool_exp
}

# ordering options when selecting data from "message"
input message_order_by {
  body: order_by
  chat: chat_order_by
  chatId: order_by
  date: order_by
  id: order_by
  sender: user_order_by
  senderId: order_by
}

# primary key columns input for table: "message"
input message_pk_columns_input {
  id: Int!
}

# select columns of table "message"
enum message_select_column {
  # column name
  body

  # column name
  chatId

  # column name
  date

  # column name
  id

  # column name
  senderId
}

# input type for updating data in table "message"
input message_set_input {
  body: String
  chatId: Int
  date: timestamptz
  id: Int
  senderId: String
}

# aggregate stddev on columns
type message_stddev_fields {
  chatId: Float
  id: Float
}

# order by stddev() on columns of table "message"
input message_stddev_order_by {
  chatId: order_by
  id: order_by
}

# aggregate stddev_pop on columns
type message_stddev_pop_fields {
  chatId: Float
  id: Float
}

# order by stddev_pop() on columns of table "message"
input message_stddev_pop_order_by {
  chatId: order_by
  id: order_by
}

# aggregate stddev_samp on columns
type message_stddev_samp_fields {
  chatId: Float
  id: Float
}

# order by stddev_samp() on columns of table "message"
input message_stddev_samp_order_by {
  chatId: order_by
  id: order_by
}

# aggregate sum on columns
type message_sum_fields {
  chatId: Int
  id: Int
}

# order by sum() on columns of table "message"
input message_sum_order_by {
  chatId: order_by
  id: order_by
}

# update columns of table "message"
enum message_update_column {
  # column name
  body

  # column name
  chatId

  # column name
  date

  # column name
  id

  # column name
  senderId
}

# aggregate var_pop on columns
type message_var_pop_fields {
  chatId: Float
  id: Float
}

# order by var_pop() on columns of table "message"
input message_var_pop_order_by {
  chatId: order_by
  id: order_by
}

# aggregate var_samp on columns
type message_var_samp_fields {
  chatId: Float
  id: Float
}

# order by var_samp() on columns of table "message"
input message_var_samp_order_by {
  chatId: order_by
  id: order_by
}

# aggregate variance on columns
type message_variance_fields {
  chatId: Float
  id: Float
}

# order by variance() on columns of table "message"
input message_variance_order_by {
  chatId: order_by
  id: order_by
}

# mutation root
type mutation_root {
  # insert a single row into the table: "friend"
  addFriend(
    # the row to be inserted
    object: friend_insert_input!

    # on conflict condition
    on_conflict: friend_on_conflict
  ): friend

  # insert a single row into the table: "groupEvent"
  addHostToEvent(
    # the row to be inserted
    object: groupEvent_insert_input!

    # on conflict condition
    on_conflict: groupEvent_on_conflict
  ): groupEvent

  # insert a single row into the table: "userInterest"
  addInterestForUser(
    # the row to be inserted
    object: userInterest_insert_input!

    # on conflict condition
    on_conflict: userInterest_on_conflict
  ): userInterest

  # insert a single row into the table: "eventQuestion"
  addQuestionToEvent(
    # the row to be inserted
    object: eventQuestion_insert_input!

    # on conflict condition
    on_conflict: eventQuestion_on_conflict
  ): eventQuestion

  # insert a single row into the table: "groupQuestion"
  addQuestionToGroup(
    # the row to be inserted
    object: groupQuestion_insert_input!

    # on conflict condition
    on_conflict: groupQuestion_on_conflict
  ): groupQuestion

  # insert a single row into the table: "groupInterest"
  addTagToGroup(
    # the row to be inserted
    object: groupInterest_insert_input!

    # on conflict condition
    on_conflict: groupInterest_on_conflict
  ): groupInterest

  # insert a single row into the table: "groupTrophy"
  awardTrophy(
    # the row to be inserted
    object: groupTrophy_insert_input!

    # on conflict condition
    on_conflict: groupTrophy_on_conflict
  ): groupTrophy

  # update single row of the table: "userEvent"
  confirmEventInvite(
    # sets the columns of the filtered rows to the given values
    _set: userEvent_set_input
    pk_columns: userEvent_pk_columns_input!
  ): userEvent

  # perform the action: "confirmFriendRequest"
  confirmFriendRequest(recipient: String!, sender: String!): ConfirmFriendRequestOutput

  # insert a single row into the table: "chat"
  createChat(
    # the row to be inserted
    object: chat_insert_input!

    # on conflict condition
    on_conflict: chat_on_conflict
  ): chat

  # insert a single row into the table: "event"
  createEvent(
    # the row to be inserted
    object: event_insert_input!

    # on conflict condition
    on_conflict: event_on_conflict
  ): event

  # insert a single row into the table: "group"
  createGroup(
    # the row to be inserted
    object: group_insert_input!

    # on conflict condition
    on_conflict: group_on_conflict
  ): group

  # insert a single row into the table: "review"
  createReview(
    # the row to be inserted
    object: review_insert_input!

    # on conflict condition
    on_conflict: review_on_conflict
  ): review

  # insert a single row into the table: "user"
  createUser(
    # the row to be inserted
    object: user_insert_input!

    # on conflict condition
    on_conflict: user_on_conflict
  ): user

  # delete single row from the table: "chat"
  deleteChat(id: Int!): chat

  # delete single row from the table: "event"
  deleteEvent(id: uuid!): event

  # delete single row from the table: "friendRequest"
  deleteFriendRequest(recipient: String!, sender: String!): friendRequest

  # delete single row from the table: "group"
  deleteGroup(id: uuid!): group

  # delete single row from the table: "notification"
  deleteNotification(id: Int!): notification

  # delete single row from the table: "review"
  deleteReview(id: Int!): review

  # delete single row from the table: "user"
  deleteUser(id: String!): user

  # delete data from the table: "chat"
  delete_chat(
    # filter the rows which have to be deleted
    where: chat_bool_exp!
  ): chat_mutation_response

  # delete data from the table: "event"
  delete_event(
    # filter the rows which have to be deleted
    where: event_bool_exp!
  ): event_mutation_response

  # delete data from the table: "eventQuestion"
  delete_eventQuestion(
    # filter the rows which have to be deleted
    where: eventQuestion_bool_exp!
  ): eventQuestion_mutation_response

  # delete data from the table: "friend"
  delete_friend(
    # filter the rows which have to be deleted
    where: friend_bool_exp!
  ): friend_mutation_response

  # delete data from the table: "friendRequest"
  delete_friendRequest(
    # filter the rows which have to be deleted
    where: friendRequest_bool_exp!
  ): friendRequest_mutation_response

  # delete data from the table: "group"
  delete_group(
    # filter the rows which have to be deleted
    where: group_bool_exp!
  ): group_mutation_response

  # delete data from the table: "groupEvent"
  delete_groupEvent(
    # filter the rows which have to be deleted
    where: groupEvent_bool_exp!
  ): groupEvent_mutation_response

  # delete data from the table: "groupInterest"
  delete_groupInterest(
    # filter the rows which have to be deleted
    where: groupInterest_bool_exp!
  ): groupInterest_mutation_response

  # delete data from the table: "groupQuestion"
  delete_groupQuestion(
    # filter the rows which have to be deleted
    where: groupQuestion_bool_exp!
  ): groupQuestion_mutation_response

  # delete data from the table: "groupTrophy"
  delete_groupTrophy(
    # filter the rows which have to be deleted
    where: groupTrophy_bool_exp!
  ): groupTrophy_mutation_response

  # delete data from the table: "interest"
  delete_interest(
    # filter the rows which have to be deleted
    where: interest_bool_exp!
  ): interest_mutation_response

  # delete single row from the table: "interest"
  delete_interest_by_pk(name: String!): interest

  # delete data from the table: "message"
  delete_message(
    # filter the rows which have to be deleted
    where: message_bool_exp!
  ): message_mutation_response

  # delete single row from the table: "message"
  delete_message_by_pk(id: Int!): message

  # delete data from the table: "notification"
  delete_notification(
    # filter the rows which have to be deleted
    where: notification_bool_exp!
  ): notification_mutation_response

  # delete data from the table: "program"
  delete_program(
    # filter the rows which have to be deleted
    where: program_bool_exp!
  ): program_mutation_response

  # delete single row from the table: "program"
  delete_program_by_pk(name: String!): program

  # delete data from the table: "question"
  delete_question(
    # filter the rows which have to be deleted
    where: question_bool_exp!
  ): question_mutation_response

  # delete single row from the table: "question"
  delete_question_by_pk(id: Int!): question

  # delete data from the table: "review"
  delete_review(
    # filter the rows which have to be deleted
    where: review_bool_exp!
  ): review_mutation_response

  # delete data from the table: "trophy"
  delete_trophy(
    # filter the rows which have to be deleted
    where: trophy_bool_exp!
  ): trophy_mutation_response

  # delete single row from the table: "trophy"
  delete_trophy_by_pk(id: uuid!): trophy

  # delete data from the table: "user"
  delete_user(
    # filter the rows which have to be deleted
    where: user_bool_exp!
  ): user_mutation_response

  # delete data from the table: "userChat"
  delete_userChat(
    # filter the rows which have to be deleted
    where: userChat_bool_exp!
  ): userChat_mutation_response

  # delete data from the table: "userEvent"
  delete_userEvent(
    # filter the rows which have to be deleted
    where: userEvent_bool_exp!
  ): userEvent_mutation_response

  # delete data from the table: "userInterest"
  delete_userInterest(
    # filter the rows which have to be deleted
    where: userInterest_bool_exp!
  ): userInterest_mutation_response

  # delete data from the table: "userMember"
  delete_userMember(
    # filter the rows which have to be deleted
    where: userMember_bool_exp!
  ): userMember_mutation_response

  # delete data from the table: "userOwner"
  delete_userOwner(
    # filter the rows which have to be deleted
    where: userOwner_bool_exp!
  ): userOwner_mutation_response

  # delete data from the table: "userProgram"
  delete_userProgram(
    # filter the rows which have to be deleted
    where: userProgram_bool_exp!
  ): userProgram_mutation_response

  # insert data into the table: "chat"
  insert_chat(
    # the rows to be inserted
    objects: [chat_insert_input!]!

    # on conflict condition
    on_conflict: chat_on_conflict
  ): chat_mutation_response

  # insert data into the table: "event"
  insert_event(
    # the rows to be inserted
    objects: [event_insert_input!]!

    # on conflict condition
    on_conflict: event_on_conflict
  ): event_mutation_response

  # insert data into the table: "eventQuestion"
  insert_eventQuestion(
    # the rows to be inserted
    objects: [eventQuestion_insert_input!]!

    # on conflict condition
    on_conflict: eventQuestion_on_conflict
  ): eventQuestion_mutation_response

  # insert data into the table: "friend"
  insert_friend(
    # the rows to be inserted
    objects: [friend_insert_input!]!

    # on conflict condition
    on_conflict: friend_on_conflict
  ): friend_mutation_response

  # insert data into the table: "friendRequest"
  insert_friendRequest(
    # the rows to be inserted
    objects: [friendRequest_insert_input!]!

    # on conflict condition
    on_conflict: friendRequest_on_conflict
  ): friendRequest_mutation_response

  # insert data into the table: "group"
  insert_group(
    # the rows to be inserted
    objects: [group_insert_input!]!

    # on conflict condition
    on_conflict: group_on_conflict
  ): group_mutation_response

  # insert data into the table: "groupEvent"
  insert_groupEvent(
    # the rows to be inserted
    objects: [groupEvent_insert_input!]!

    # on conflict condition
    on_conflict: groupEvent_on_conflict
  ): groupEvent_mutation_response

  # insert data into the table: "groupInterest"
  insert_groupInterest(
    # the rows to be inserted
    objects: [groupInterest_insert_input!]!

    # on conflict condition
    on_conflict: groupInterest_on_conflict
  ): groupInterest_mutation_response

  # insert data into the table: "groupQuestion"
  insert_groupQuestion(
    # the rows to be inserted
    objects: [groupQuestion_insert_input!]!

    # on conflict condition
    on_conflict: groupQuestion_on_conflict
  ): groupQuestion_mutation_response

  # insert data into the table: "groupTrophy"
  insert_groupTrophy(
    # the rows to be inserted
    objects: [groupTrophy_insert_input!]!

    # on conflict condition
    on_conflict: groupTrophy_on_conflict
  ): groupTrophy_mutation_response

  # insert data into the table: "interest"
  insert_interest(
    # the rows to be inserted
    objects: [interest_insert_input!]!

    # on conflict condition
    on_conflict: interest_on_conflict
  ): interest_mutation_response

  # insert a single row into the table: "interest"
  insert_interest_one(
    # the row to be inserted
    object: interest_insert_input!

    # on conflict condition
    on_conflict: interest_on_conflict
  ): interest

  # insert data into the table: "message"
  insert_message(
    # the rows to be inserted
    objects: [message_insert_input!]!

    # on conflict condition
    on_conflict: message_on_conflict
  ): message_mutation_response

  # insert data into the table: "notification"
  insert_notification(
    # the rows to be inserted
    objects: [notification_insert_input!]!

    # on conflict condition
    on_conflict: notification_on_conflict
  ): notification_mutation_response

  # insert data into the table: "program"
  insert_program(
    # the rows to be inserted
    objects: [program_insert_input!]!

    # on conflict condition
    on_conflict: program_on_conflict
  ): program_mutation_response

  # insert a single row into the table: "program"
  insert_program_one(
    # the row to be inserted
    object: program_insert_input!

    # on conflict condition
    on_conflict: program_on_conflict
  ): program

  # insert data into the table: "question"
  insert_question(
    # the rows to be inserted
    objects: [question_insert_input!]!

    # on conflict condition
    on_conflict: question_on_conflict
  ): question_mutation_response

  # insert a single row into the table: "question"
  insert_question_one(
    # the row to be inserted
    object: question_insert_input!

    # on conflict condition
    on_conflict: question_on_conflict
  ): question

  # insert data into the table: "review"
  insert_review(
    # the rows to be inserted
    objects: [review_insert_input!]!

    # on conflict condition
    on_conflict: review_on_conflict
  ): review_mutation_response

  # insert data into the table: "trophy"
  insert_trophy(
    # the rows to be inserted
    objects: [trophy_insert_input!]!

    # on conflict condition
    on_conflict: trophy_on_conflict
  ): trophy_mutation_response

  # insert a single row into the table: "trophy"
  insert_trophy_one(
    # the row to be inserted
    object: trophy_insert_input!

    # on conflict condition
    on_conflict: trophy_on_conflict
  ): trophy

  # insert data into the table: "user"
  insert_user(
    # the rows to be inserted
    objects: [user_insert_input!]!

    # on conflict condition
    on_conflict: user_on_conflict
  ): user_mutation_response

  # insert data into the table: "userChat"
  insert_userChat(
    # the rows to be inserted
    objects: [userChat_insert_input!]!

    # on conflict condition
    on_conflict: userChat_on_conflict
  ): userChat_mutation_response

  # insert data into the table: "userEvent"
  insert_userEvent(
    # the rows to be inserted
    objects: [userEvent_insert_input!]!

    # on conflict condition
    on_conflict: userEvent_on_conflict
  ): userEvent_mutation_response

  # insert data into the table: "userInterest"
  insert_userInterest(
    # the rows to be inserted
    objects: [userInterest_insert_input!]!

    # on conflict condition
    on_conflict: userInterest_on_conflict
  ): userInterest_mutation_response

  # insert data into the table: "userMember"
  insert_userMember(
    # the rows to be inserted
    objects: [userMember_insert_input!]!

    # on conflict condition
    on_conflict: userMember_on_conflict
  ): userMember_mutation_response

  # insert data into the table: "userOwner"
  insert_userOwner(
    # the rows to be inserted
    objects: [userOwner_insert_input!]!

    # on conflict condition
    on_conflict: userOwner_on_conflict
  ): userOwner_mutation_response

  # insert data into the table: "userProgram"
  insert_userProgram(
    # the rows to be inserted
    objects: [userProgram_insert_input!]!

    # on conflict condition
    on_conflict: userProgram_on_conflict
  ): userProgram_mutation_response

  # insert a single row into the table: "userMember"
  joinClub(
    # the row to be inserted
    object: userMember_insert_input!

    # on conflict condition
    on_conflict: userMember_on_conflict
  ): userMember

  # delete single row from the table: "userMember"
  leaveClub(groupId: uuid!, userId: String!): userMember

  # insert a single row into the table: "userProgram"
  registerUserForProgram(
    # the row to be inserted
    object: userProgram_insert_input!

    # on conflict condition
    on_conflict: userProgram_on_conflict
  ): userProgram

  # delete single row from the table: "friend"
  removeFriend(friendId: String!, userId: String!): friend

  # delete single row from the table: "groupEvent"
  removeHostFromEvent(eventId: uuid!, groupId: uuid!): groupEvent

  # delete single row from the table: "userInterest"
  removeInterestFromUser(interestId: Int!, userId: String!): userInterest

  # delete single row from the table: "userOwner"
  removeOwnerOfClub(groupId: uuid!, userId: String!): userOwner

  # delete single row from the table: "eventQuestion"
  removeQuestionFromEvent(eventId: uuid!, questionId: Int!): eventQuestion

  # delete single row from the table: "groupQuestion"
  removeQuestionFromGroup(groupId: uuid!, questionId: Int!): groupQuestion

  # delete single row from the table: "groupInterest"
  removeTagFromGroup(groupId: uuid!, interestId: Int!): groupInterest

  # delete single row from the table: "groupTrophy"
  removeTrophy(groupId: uuid!, trophyId: uuid!): groupTrophy

  # delete single row from the table: "userEvent"
  removeUserFromEvent(eventId: uuid!, userId: String!): userEvent

  # delete single row from the table: "userProgram"
  removeUserFromProgram(programId: Int!, userId: String!): userProgram

  # insert a single row into the table: "friendRequest"
  sendFriendRequest(
    # the row to be inserted
    object: friendRequest_insert_input!

    # on conflict condition
    on_conflict: friendRequest_on_conflict
  ): friendRequest

  # insert a single row into the table: "message"
  sendMessage(
    # the row to be inserted
    object: message_insert_input!

    # on conflict condition
    on_conflict: message_on_conflict
  ): message

  # insert a single row into the table: "notification"
  sendNotification(
    # the row to be inserted
    object: notification_insert_input!

    # on conflict condition
    on_conflict: notification_on_conflict
  ): notification

  # insert a single row into the table: "userOwner"
  setOwnerOfClub(
    # the row to be inserted
    object: userOwner_insert_input!

    # on conflict condition
    on_conflict: userOwner_on_conflict
  ): userOwner

  # insert a single row into the table: "userEvent"
  signUpUserForEvent(
    # the row to be inserted
    object: userEvent_insert_input!

    # on conflict condition
    on_conflict: userEvent_on_conflict
  ): userEvent

  # insert a single row into the table: "userChat"
  subscribeToChat(
    # the row to be inserted
    object: userChat_insert_input!

    # on conflict condition
    on_conflict: userChat_on_conflict
  ): userChat

  # delete single row from the table: "userChat"
  unsubscribeFromChat(chatId: Int!, userId: String!): userChat

  # update single row of the table: "event"
  updateEvent(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: event_append_input

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _delete_at_path: event_delete_at_path_input

    # delete the array element with specified index (negative integers count from
    # the end). throws an error if top level container is not an array
    _delete_elem: event_delete_elem_input

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _delete_key: event_delete_key_input

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: event_prepend_input

    # sets the columns of the filtered rows to the given values
    _set: event_set_input
    pk_columns: event_pk_columns_input!
  ): event

  # update single row of the table: "group"
  updateGroup(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: group_append_input

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _delete_at_path: group_delete_at_path_input

    # delete the array element with specified index (negative integers count from
    # the end). throws an error if top level container is not an array
    _delete_elem: group_delete_elem_input

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _delete_key: group_delete_key_input

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: group_prepend_input

    # sets the columns of the filtered rows to the given values
    _set: group_set_input
    pk_columns: group_pk_columns_input!
  ): group

  # update single row of the table: "user"
  updateUser(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: user_append_input

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _delete_at_path: user_delete_at_path_input

    # delete the array element with specified index (negative integers count from
    # the end). throws an error if top level container is not an array
    _delete_elem: user_delete_elem_input

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _delete_key: user_delete_key_input

    # increments the integer columns with given value of the filtered values
    _inc: user_inc_input

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: user_prepend_input

    # sets the columns of the filtered rows to the given values
    _set: user_set_input
    pk_columns: user_pk_columns_input!
  ): user

  # update data of the table: "chat"
  update_chat(
    # increments the integer columns with given value of the filtered values
    _inc: chat_inc_input

    # sets the columns of the filtered rows to the given values
    _set: chat_set_input

    # filter the rows which have to be updated
    where: chat_bool_exp!
  ): chat_mutation_response

  # update single row of the table: "chat"
  update_chat_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: chat_inc_input

    # sets the columns of the filtered rows to the given values
    _set: chat_set_input
    pk_columns: chat_pk_columns_input!
  ): chat

  # update data of the table: "event"
  update_event(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: event_append_input

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _delete_at_path: event_delete_at_path_input

    # delete the array element with specified index (negative integers count from
    # the end). throws an error if top level container is not an array
    _delete_elem: event_delete_elem_input

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _delete_key: event_delete_key_input

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: event_prepend_input

    # sets the columns of the filtered rows to the given values
    _set: event_set_input

    # filter the rows which have to be updated
    where: event_bool_exp!
  ): event_mutation_response

  # update data of the table: "eventQuestion"
  update_eventQuestion(
    # increments the integer columns with given value of the filtered values
    _inc: eventQuestion_inc_input

    # sets the columns of the filtered rows to the given values
    _set: eventQuestion_set_input

    # filter the rows which have to be updated
    where: eventQuestion_bool_exp!
  ): eventQuestion_mutation_response

  # update single row of the table: "eventQuestion"
  update_eventQuestion_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: eventQuestion_inc_input

    # sets the columns of the filtered rows to the given values
    _set: eventQuestion_set_input
    pk_columns: eventQuestion_pk_columns_input!
  ): eventQuestion

  # update data of the table: "friend"
  update_friend(
    # sets the columns of the filtered rows to the given values
    _set: friend_set_input

    # filter the rows which have to be updated
    where: friend_bool_exp!
  ): friend_mutation_response

  # update data of the table: "friendRequest"
  update_friendRequest(
    # sets the columns of the filtered rows to the given values
    _set: friendRequest_set_input

    # filter the rows which have to be updated
    where: friendRequest_bool_exp!
  ): friendRequest_mutation_response

  # update single row of the table: "friendRequest"
  update_friendRequest_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: friendRequest_set_input
    pk_columns: friendRequest_pk_columns_input!
  ): friendRequest

  # update single row of the table: "friend"
  update_friend_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: friend_set_input
    pk_columns: friend_pk_columns_input!
  ): friend

  # update data of the table: "group"
  update_group(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: group_append_input

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _delete_at_path: group_delete_at_path_input

    # delete the array element with specified index (negative integers count from
    # the end). throws an error if top level container is not an array
    _delete_elem: group_delete_elem_input

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _delete_key: group_delete_key_input

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: group_prepend_input

    # sets the columns of the filtered rows to the given values
    _set: group_set_input

    # filter the rows which have to be updated
    where: group_bool_exp!
  ): group_mutation_response

  # update data of the table: "groupEvent"
  update_groupEvent(
    # sets the columns of the filtered rows to the given values
    _set: groupEvent_set_input

    # filter the rows which have to be updated
    where: groupEvent_bool_exp!
  ): groupEvent_mutation_response

  # update single row of the table: "groupEvent"
  update_groupEvent_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: groupEvent_set_input
    pk_columns: groupEvent_pk_columns_input!
  ): groupEvent

  # update data of the table: "groupInterest"
  update_groupInterest(
    # increments the integer columns with given value of the filtered values
    _inc: groupInterest_inc_input

    # sets the columns of the filtered rows to the given values
    _set: groupInterest_set_input

    # filter the rows which have to be updated
    where: groupInterest_bool_exp!
  ): groupInterest_mutation_response

  # update single row of the table: "groupInterest"
  update_groupInterest_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: groupInterest_inc_input

    # sets the columns of the filtered rows to the given values
    _set: groupInterest_set_input
    pk_columns: groupInterest_pk_columns_input!
  ): groupInterest

  # update data of the table: "groupQuestion"
  update_groupQuestion(
    # increments the integer columns with given value of the filtered values
    _inc: groupQuestion_inc_input

    # sets the columns of the filtered rows to the given values
    _set: groupQuestion_set_input

    # filter the rows which have to be updated
    where: groupQuestion_bool_exp!
  ): groupQuestion_mutation_response

  # update single row of the table: "groupQuestion"
  update_groupQuestion_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: groupQuestion_inc_input

    # sets the columns of the filtered rows to the given values
    _set: groupQuestion_set_input
    pk_columns: groupQuestion_pk_columns_input!
  ): groupQuestion

  # update data of the table: "groupTrophy"
  update_groupTrophy(
    # sets the columns of the filtered rows to the given values
    _set: groupTrophy_set_input

    # filter the rows which have to be updated
    where: groupTrophy_bool_exp!
  ): groupTrophy_mutation_response

  # update single row of the table: "groupTrophy"
  update_groupTrophy_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: groupTrophy_set_input
    pk_columns: groupTrophy_pk_columns_input!
  ): groupTrophy

  # update data of the table: "interest"
  update_interest(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: interest_append_input

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _delete_at_path: interest_delete_at_path_input

    # delete the array element with specified index (negative integers count from
    # the end). throws an error if top level container is not an array
    _delete_elem: interest_delete_elem_input

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _delete_key: interest_delete_key_input

    # increments the integer columns with given value of the filtered values
    _inc: interest_inc_input

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: interest_prepend_input

    # sets the columns of the filtered rows to the given values
    _set: interest_set_input

    # filter the rows which have to be updated
    where: interest_bool_exp!
  ): interest_mutation_response

  # update single row of the table: "interest"
  update_interest_by_pk(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: interest_append_input

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _delete_at_path: interest_delete_at_path_input

    # delete the array element with specified index (negative integers count from
    # the end). throws an error if top level container is not an array
    _delete_elem: interest_delete_elem_input

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _delete_key: interest_delete_key_input

    # increments the integer columns with given value of the filtered values
    _inc: interest_inc_input

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: interest_prepend_input

    # sets the columns of the filtered rows to the given values
    _set: interest_set_input
    pk_columns: interest_pk_columns_input!
  ): interest

  # update data of the table: "message"
  update_message(
    # increments the integer columns with given value of the filtered values
    _inc: message_inc_input

    # sets the columns of the filtered rows to the given values
    _set: message_set_input

    # filter the rows which have to be updated
    where: message_bool_exp!
  ): message_mutation_response

  # update single row of the table: "message"
  update_message_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: message_inc_input

    # sets the columns of the filtered rows to the given values
    _set: message_set_input
    pk_columns: message_pk_columns_input!
  ): message

  # update data of the table: "notification"
  update_notification(
    # increments the integer columns with given value of the filtered values
    _inc: notification_inc_input

    # sets the columns of the filtered rows to the given values
    _set: notification_set_input

    # filter the rows which have to be updated
    where: notification_bool_exp!
  ): notification_mutation_response

  # update single row of the table: "notification"
  update_notification_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: notification_inc_input

    # sets the columns of the filtered rows to the given values
    _set: notification_set_input
    pk_columns: notification_pk_columns_input!
  ): notification

  # update data of the table: "program"
  update_program(
    # increments the integer columns with given value of the filtered values
    _inc: program_inc_input

    # sets the columns of the filtered rows to the given values
    _set: program_set_input

    # filter the rows which have to be updated
    where: program_bool_exp!
  ): program_mutation_response

  # update single row of the table: "program"
  update_program_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: program_inc_input

    # sets the columns of the filtered rows to the given values
    _set: program_set_input
    pk_columns: program_pk_columns_input!
  ): program

  # update data of the table: "question"
  update_question(
    # increments the integer columns with given value of the filtered values
    _inc: question_inc_input

    # sets the columns of the filtered rows to the given values
    _set: question_set_input

    # filter the rows which have to be updated
    where: question_bool_exp!
  ): question_mutation_response

  # update single row of the table: "question"
  update_question_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: question_inc_input

    # sets the columns of the filtered rows to the given values
    _set: question_set_input
    pk_columns: question_pk_columns_input!
  ): question

  # update data of the table: "review"
  update_review(
    # increments the integer columns with given value of the filtered values
    _inc: review_inc_input

    # sets the columns of the filtered rows to the given values
    _set: review_set_input

    # filter the rows which have to be updated
    where: review_bool_exp!
  ): review_mutation_response

  # update single row of the table: "review"
  update_review_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: review_inc_input

    # sets the columns of the filtered rows to the given values
    _set: review_set_input
    pk_columns: review_pk_columns_input!
  ): review

  # update data of the table: "trophy"
  update_trophy(
    # increments the integer columns with given value of the filtered values
    _inc: trophy_inc_input

    # sets the columns of the filtered rows to the given values
    _set: trophy_set_input

    # filter the rows which have to be updated
    where: trophy_bool_exp!
  ): trophy_mutation_response

  # update single row of the table: "trophy"
  update_trophy_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: trophy_inc_input

    # sets the columns of the filtered rows to the given values
    _set: trophy_set_input
    pk_columns: trophy_pk_columns_input!
  ): trophy

  # update data of the table: "user"
  update_user(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: user_append_input

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _delete_at_path: user_delete_at_path_input

    # delete the array element with specified index (negative integers count from
    # the end). throws an error if top level container is not an array
    _delete_elem: user_delete_elem_input

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _delete_key: user_delete_key_input

    # increments the integer columns with given value of the filtered values
    _inc: user_inc_input

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: user_prepend_input

    # sets the columns of the filtered rows to the given values
    _set: user_set_input

    # filter the rows which have to be updated
    where: user_bool_exp!
  ): user_mutation_response

  # update data of the table: "userChat"
  update_userChat(
    # increments the integer columns with given value of the filtered values
    _inc: userChat_inc_input

    # sets the columns of the filtered rows to the given values
    _set: userChat_set_input

    # filter the rows which have to be updated
    where: userChat_bool_exp!
  ): userChat_mutation_response

  # update single row of the table: "userChat"
  update_userChat_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: userChat_inc_input

    # sets the columns of the filtered rows to the given values
    _set: userChat_set_input
    pk_columns: userChat_pk_columns_input!
  ): userChat

  # update data of the table: "userEvent"
  update_userEvent(
    # sets the columns of the filtered rows to the given values
    _set: userEvent_set_input

    # filter the rows which have to be updated
    where: userEvent_bool_exp!
  ): userEvent_mutation_response

  # update data of the table: "userInterest"
  update_userInterest(
    # increments the integer columns with given value of the filtered values
    _inc: userInterest_inc_input

    # sets the columns of the filtered rows to the given values
    _set: userInterest_set_input

    # filter the rows which have to be updated
    where: userInterest_bool_exp!
  ): userInterest_mutation_response

  # update single row of the table: "userInterest"
  update_userInterest_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: userInterest_inc_input

    # sets the columns of the filtered rows to the given values
    _set: userInterest_set_input
    pk_columns: userInterest_pk_columns_input!
  ): userInterest

  # update data of the table: "userMember"
  update_userMember(
    # sets the columns of the filtered rows to the given values
    _set: userMember_set_input

    # filter the rows which have to be updated
    where: userMember_bool_exp!
  ): userMember_mutation_response

  # update single row of the table: "userMember"
  update_userMember_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: userMember_set_input
    pk_columns: userMember_pk_columns_input!
  ): userMember

  # update data of the table: "userOwner"
  update_userOwner(
    # sets the columns of the filtered rows to the given values
    _set: userOwner_set_input

    # filter the rows which have to be updated
    where: userOwner_bool_exp!
  ): userOwner_mutation_response

  # update single row of the table: "userOwner"
  update_userOwner_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: userOwner_set_input
    pk_columns: userOwner_pk_columns_input!
  ): userOwner

  # update data of the table: "userProgram"
  update_userProgram(
    # increments the integer columns with given value of the filtered values
    _inc: userProgram_inc_input

    # sets the columns of the filtered rows to the given values
    _set: userProgram_set_input

    # filter the rows which have to be updated
    where: userProgram_bool_exp!
  ): userProgram_mutation_response

  # update single row of the table: "userProgram"
  update_userProgram_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: userProgram_inc_input

    # sets the columns of the filtered rows to the given values
    _set: userProgram_set_input
    pk_columns: userProgram_pk_columns_input!
  ): userProgram
}

# columns and relationships of "notification"
type notification {
  id: Int!
  image: String!
  link: String!
  message: String!
  recipient: String!
  timestamp: timestamptz!
  title: String!

  # An object relationship
  user: user!
}

# aggregated selection of "notification"
type notification_aggregate {
  aggregate: notification_aggregate_fields
  nodes: [notification!]!
}

# aggregate fields of "notification"
type notification_aggregate_fields {
  avg: notification_avg_fields
  count(columns: [notification_select_column!], distinct: Boolean): Int
  max: notification_max_fields
  min: notification_min_fields
  stddev: notification_stddev_fields
  stddev_pop: notification_stddev_pop_fields
  stddev_samp: notification_stddev_samp_fields
  sum: notification_sum_fields
  var_pop: notification_var_pop_fields
  var_samp: notification_var_samp_fields
  variance: notification_variance_fields
}

# order by aggregate values of table "notification"
input notification_aggregate_order_by {
  avg: notification_avg_order_by
  count: order_by
  max: notification_max_order_by
  min: notification_min_order_by
  stddev: notification_stddev_order_by
  stddev_pop: notification_stddev_pop_order_by
  stddev_samp: notification_stddev_samp_order_by
  sum: notification_sum_order_by
  var_pop: notification_var_pop_order_by
  var_samp: notification_var_samp_order_by
  variance: notification_variance_order_by
}

# input type for inserting array relation for remote table "notification"
input notification_arr_rel_insert_input {
  data: [notification_insert_input!]!
  on_conflict: notification_on_conflict
}

# aggregate avg on columns
type notification_avg_fields {
  id: Float
}

# order by avg() on columns of table "notification"
input notification_avg_order_by {
  id: order_by
}

# Boolean expression to filter rows from the table "notification". All fields are combined with a logical 'AND'.
input notification_bool_exp {
  _and: [notification_bool_exp]
  _not: notification_bool_exp
  _or: [notification_bool_exp]
  id: Int_comparison_exp
  image: String_comparison_exp
  link: String_comparison_exp
  message: String_comparison_exp
  recipient: String_comparison_exp
  timestamp: timestamptz_comparison_exp
  title: String_comparison_exp
  user: user_bool_exp
}

# unique or primary key constraints on table "notification"
enum notification_constraint {
  # unique or primary key constraint
  notifications_pkey
}

# input type for incrementing integer column in table "notification"
input notification_inc_input {
  id: Int
}

# input type for inserting data into table "notification"
input notification_insert_input {
  id: Int
  image: String
  link: String
  message: String
  recipient: String
  timestamp: timestamptz
  title: String
  user: user_obj_rel_insert_input
}

# aggregate max on columns
type notification_max_fields {
  id: Int
  image: String
  link: String
  message: String
  recipient: String
  timestamp: timestamptz
  title: String
}

# order by max() on columns of table "notification"
input notification_max_order_by {
  id: order_by
  image: order_by
  link: order_by
  message: order_by
  recipient: order_by
  timestamp: order_by
  title: order_by
}

# aggregate min on columns
type notification_min_fields {
  id: Int
  image: String
  link: String
  message: String
  recipient: String
  timestamp: timestamptz
  title: String
}

# order by min() on columns of table "notification"
input notification_min_order_by {
  id: order_by
  image: order_by
  link: order_by
  message: order_by
  recipient: order_by
  timestamp: order_by
  title: order_by
}

# response of any mutation on the table "notification"
type notification_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [notification!]!
}

# input type for inserting object relation for remote table "notification"
input notification_obj_rel_insert_input {
  data: notification_insert_input!
  on_conflict: notification_on_conflict
}

# on conflict condition type for table "notification"
input notification_on_conflict {
  constraint: notification_constraint!
  update_columns: [notification_update_column!]!
  where: notification_bool_exp
}

# ordering options when selecting data from "notification"
input notification_order_by {
  id: order_by
  image: order_by
  link: order_by
  message: order_by
  recipient: order_by
  timestamp: order_by
  title: order_by
  user: user_order_by
}

# primary key columns input for table: "notification"
input notification_pk_columns_input {
  id: Int!
}

# select columns of table "notification"
enum notification_select_column {
  # column name
  id

  # column name
  image

  # column name
  link

  # column name
  message

  # column name
  recipient

  # column name
  timestamp

  # column name
  title
}

# input type for updating data in table "notification"
input notification_set_input {
  id: Int
  image: String
  link: String
  message: String
  recipient: String
  timestamp: timestamptz
  title: String
}

# aggregate stddev on columns
type notification_stddev_fields {
  id: Float
}

# order by stddev() on columns of table "notification"
input notification_stddev_order_by {
  id: order_by
}

# aggregate stddev_pop on columns
type notification_stddev_pop_fields {
  id: Float
}

# order by stddev_pop() on columns of table "notification"
input notification_stddev_pop_order_by {
  id: order_by
}

# aggregate stddev_samp on columns
type notification_stddev_samp_fields {
  id: Float
}

# order by stddev_samp() on columns of table "notification"
input notification_stddev_samp_order_by {
  id: order_by
}

# aggregate sum on columns
type notification_sum_fields {
  id: Int
}

# order by sum() on columns of table "notification"
input notification_sum_order_by {
  id: order_by
}

# update columns of table "notification"
enum notification_update_column {
  # column name
  id

  # column name
  image

  # column name
  link

  # column name
  message

  # column name
  recipient

  # column name
  timestamp

  # column name
  title
}

# aggregate var_pop on columns
type notification_var_pop_fields {
  id: Float
}

# order by var_pop() on columns of table "notification"
input notification_var_pop_order_by {
  id: order_by
}

# aggregate var_samp on columns
type notification_var_samp_fields {
  id: Float
}

# order by var_samp() on columns of table "notification"
input notification_var_samp_order_by {
  id: order_by
}

# aggregate variance on columns
type notification_variance_fields {
  id: Float
}

# order by variance() on columns of table "notification"
input notification_variance_order_by {
  id: order_by
}

# column ordering options
enum order_by {
  # in the ascending order, nulls last
  asc

  # in the ascending order, nulls first
  asc_nulls_first

  # in the ascending order, nulls last
  asc_nulls_last

  # in the descending order, nulls first
  desc

  # in the descending order, nulls first
  desc_nulls_first

  # in the descending order, nulls last
  desc_nulls_last
}

# columns and relationships of "program"
type program {
  id: Int!
  name: String!

  # An array relationship
  users(
    # distinct select on columns
    distinct_on: [userProgram_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userProgram_order_by!]

    # filter the rows returned
    where: userProgram_bool_exp
  ): [userProgram!]!

  # An aggregated array relationship
  users_aggregate(
    # distinct select on columns
    distinct_on: [userProgram_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userProgram_order_by!]

    # filter the rows returned
    where: userProgram_bool_exp
  ): userProgram_aggregate!
}

# aggregated selection of "program"
type program_aggregate {
  aggregate: program_aggregate_fields
  nodes: [program!]!
}

# aggregate fields of "program"
type program_aggregate_fields {
  avg: program_avg_fields
  count(columns: [program_select_column!], distinct: Boolean): Int
  max: program_max_fields
  min: program_min_fields
  stddev: program_stddev_fields
  stddev_pop: program_stddev_pop_fields
  stddev_samp: program_stddev_samp_fields
  sum: program_sum_fields
  var_pop: program_var_pop_fields
  var_samp: program_var_samp_fields
  variance: program_variance_fields
}

# order by aggregate values of table "program"
input program_aggregate_order_by {
  avg: program_avg_order_by
  count: order_by
  max: program_max_order_by
  min: program_min_order_by
  stddev: program_stddev_order_by
  stddev_pop: program_stddev_pop_order_by
  stddev_samp: program_stddev_samp_order_by
  sum: program_sum_order_by
  var_pop: program_var_pop_order_by
  var_samp: program_var_samp_order_by
  variance: program_variance_order_by
}

# input type for inserting array relation for remote table "program"
input program_arr_rel_insert_input {
  data: [program_insert_input!]!
  on_conflict: program_on_conflict
}

# aggregate avg on columns
type program_avg_fields {
  id: Float
}

# order by avg() on columns of table "program"
input program_avg_order_by {
  id: order_by
}

# Boolean expression to filter rows from the table "program". All fields are combined with a logical 'AND'.
input program_bool_exp {
  _and: [program_bool_exp]
  _not: program_bool_exp
  _or: [program_bool_exp]
  id: Int_comparison_exp
  name: String_comparison_exp
  users: userProgram_bool_exp
}

# unique or primary key constraints on table "program"
enum program_constraint {
  # unique or primary key constraint
  program_id_key

  # unique or primary key constraint
  program_name_key

  # unique or primary key constraint
  program_pkey
}

# input type for incrementing integer column in table "program"
input program_inc_input {
  id: Int
}

# input type for inserting data into table "program"
input program_insert_input {
  id: Int
  name: String
  users: userProgram_arr_rel_insert_input
}

# aggregate max on columns
type program_max_fields {
  id: Int
  name: String
}

# order by max() on columns of table "program"
input program_max_order_by {
  id: order_by
  name: order_by
}

# aggregate min on columns
type program_min_fields {
  id: Int
  name: String
}

# order by min() on columns of table "program"
input program_min_order_by {
  id: order_by
  name: order_by
}

# response of any mutation on the table "program"
type program_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [program!]!
}

# input type for inserting object relation for remote table "program"
input program_obj_rel_insert_input {
  data: program_insert_input!
  on_conflict: program_on_conflict
}

# on conflict condition type for table "program"
input program_on_conflict {
  constraint: program_constraint!
  update_columns: [program_update_column!]!
  where: program_bool_exp
}

# ordering options when selecting data from "program"
input program_order_by {
  id: order_by
  name: order_by
  users_aggregate: userProgram_aggregate_order_by
}

# primary key columns input for table: "program"
input program_pk_columns_input {
  name: String!
}

# select columns of table "program"
enum program_select_column {
  # column name
  id

  # column name
  name
}

# input type for updating data in table "program"
input program_set_input {
  id: Int
  name: String
}

# aggregate stddev on columns
type program_stddev_fields {
  id: Float
}

# order by stddev() on columns of table "program"
input program_stddev_order_by {
  id: order_by
}

# aggregate stddev_pop on columns
type program_stddev_pop_fields {
  id: Float
}

# order by stddev_pop() on columns of table "program"
input program_stddev_pop_order_by {
  id: order_by
}

# aggregate stddev_samp on columns
type program_stddev_samp_fields {
  id: Float
}

# order by stddev_samp() on columns of table "program"
input program_stddev_samp_order_by {
  id: order_by
}

# aggregate sum on columns
type program_sum_fields {
  id: Int
}

# order by sum() on columns of table "program"
input program_sum_order_by {
  id: order_by
}

# update columns of table "program"
enum program_update_column {
  # column name
  id

  # column name
  name
}

# aggregate var_pop on columns
type program_var_pop_fields {
  id: Float
}

# order by var_pop() on columns of table "program"
input program_var_pop_order_by {
  id: order_by
}

# aggregate var_samp on columns
type program_var_samp_fields {
  id: Float
}

# order by var_samp() on columns of table "program"
input program_var_samp_order_by {
  id: order_by
}

# aggregate variance on columns
type program_variance_fields {
  id: Float
}

# order by variance() on columns of table "program"
input program_variance_order_by {
  id: order_by
}

# query root
type query_root {
  # fetch data from the table: "chat" using primary key columns
  chat(id: Int!): chat

  # fetch data from the table: "chatUserView"
  chatUserView(
    # distinct select on columns
    distinct_on: [chatUserView_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [chatUserView_order_by!]

    # filter the rows returned
    where: chatUserView_bool_exp
  ): [chatUserView!]!

  # fetch aggregated fields from the table: "chatUserView"
  chatUserView_aggregate(
    # distinct select on columns
    distinct_on: [chatUserView_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [chatUserView_order_by!]

    # filter the rows returned
    where: chatUserView_bool_exp
  ): chatUserView_aggregate!

  # fetch aggregated fields from the table: "chat"
  chat_aggregate(
    # distinct select on columns
    distinct_on: [chat_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [chat_order_by!]

    # filter the rows returned
    where: chat_bool_exp
  ): chat_aggregate!

  # fetch data from the table: "chat"
  chats(
    # distinct select on columns
    distinct_on: [chat_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [chat_order_by!]

    # filter the rows returned
    where: chat_bool_exp
  ): [chat!]!

  # fetch data from the table: "event" using primary key columns
  event(id: uuid!): event

  # fetch data from the table: "eventQuestion"
  eventQuestion(
    # distinct select on columns
    distinct_on: [eventQuestion_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [eventQuestion_order_by!]

    # filter the rows returned
    where: eventQuestion_bool_exp
  ): [eventQuestion!]!

  # fetch aggregated fields from the table: "eventQuestion"
  eventQuestion_aggregate(
    # distinct select on columns
    distinct_on: [eventQuestion_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [eventQuestion_order_by!]

    # filter the rows returned
    where: eventQuestion_bool_exp
  ): eventQuestion_aggregate!

  # fetch data from the table: "eventQuestion" using primary key columns
  eventQuestion_by_pk(eventId: uuid!, questionId: Int!): eventQuestion

  # fetch aggregated fields from the table: "event"
  event_aggregate(
    # distinct select on columns
    distinct_on: [event_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [event_order_by!]

    # filter the rows returned
    where: event_bool_exp
  ): event_aggregate!

  # fetch data from the table: "event"
  events(
    # distinct select on columns
    distinct_on: [event_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [event_order_by!]

    # filter the rows returned
    where: event_bool_exp
  ): [event!]!

  # fetch data from the table: "friend"
  friend(
    # distinct select on columns
    distinct_on: [friend_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [friend_order_by!]

    # filter the rows returned
    where: friend_bool_exp
  ): [friend!]!

  # fetch data from the table: "friendRequest"
  friendRequest(
    # distinct select on columns
    distinct_on: [friendRequest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [friendRequest_order_by!]

    # filter the rows returned
    where: friendRequest_bool_exp
  ): [friendRequest!]!

  # fetch aggregated fields from the table: "friendRequest"
  friendRequest_aggregate(
    # distinct select on columns
    distinct_on: [friendRequest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [friendRequest_order_by!]

    # filter the rows returned
    where: friendRequest_bool_exp
  ): friendRequest_aggregate!

  # fetch data from the table: "friendRequest" using primary key columns
  friendRequest_by_pk(recipient: String!, sender: String!): friendRequest

  # fetch aggregated fields from the table: "friendView"
  friendView_aggregate(
    # distinct select on columns
    distinct_on: [friendView_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [friendView_order_by!]

    # filter the rows returned
    where: friendView_bool_exp
  ): friendView_aggregate!

  # fetch aggregated fields from the table: "friend"
  friend_aggregate(
    # distinct select on columns
    distinct_on: [friend_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [friend_order_by!]

    # filter the rows returned
    where: friend_bool_exp
  ): friend_aggregate!

  # fetch data from the table: "friend" using primary key columns
  friend_by_pk(friendId: String!, userId: String!): friend

  # fetch data from the table: "friendView"
  friends(
    # distinct select on columns
    distinct_on: [friendView_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [friendView_order_by!]

    # filter the rows returned
    where: friendView_bool_exp
  ): [friendView!]!

  # fetch data from the table: "groupTrophy"
  getTrophies(
    # distinct select on columns
    distinct_on: [groupTrophy_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupTrophy_order_by!]

    # filter the rows returned
    where: groupTrophy_bool_exp
  ): [groupTrophy!]!

  # fetch data from the table: "group" using primary key columns
  group(id: uuid!): group

  # fetch data from the table: "groupEvent"
  groupEvent(
    # distinct select on columns
    distinct_on: [groupEvent_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupEvent_order_by!]

    # filter the rows returned
    where: groupEvent_bool_exp
  ): [groupEvent!]!

  # fetch aggregated fields from the table: "groupEvent"
  groupEvent_aggregate(
    # distinct select on columns
    distinct_on: [groupEvent_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupEvent_order_by!]

    # filter the rows returned
    where: groupEvent_bool_exp
  ): groupEvent_aggregate!

  # fetch data from the table: "groupEvent" using primary key columns
  groupEvent_by_pk(eventId: uuid!, groupId: uuid!): groupEvent

  # fetch data from the table: "groupInterest"
  groupInterest(
    # distinct select on columns
    distinct_on: [groupInterest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupInterest_order_by!]

    # filter the rows returned
    where: groupInterest_bool_exp
  ): [groupInterest!]!

  # fetch aggregated fields from the table: "groupInterest"
  groupInterest_aggregate(
    # distinct select on columns
    distinct_on: [groupInterest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupInterest_order_by!]

    # filter the rows returned
    where: groupInterest_bool_exp
  ): groupInterest_aggregate!

  # fetch data from the table: "groupInterest" using primary key columns
  groupInterest_by_pk(groupId: uuid!, interestId: Int!): groupInterest

  # fetch data from the table: "groupQuestion"
  groupQuestion(
    # distinct select on columns
    distinct_on: [groupQuestion_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupQuestion_order_by!]

    # filter the rows returned
    where: groupQuestion_bool_exp
  ): [groupQuestion!]!

  # fetch aggregated fields from the table: "groupQuestion"
  groupQuestion_aggregate(
    # distinct select on columns
    distinct_on: [groupQuestion_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupQuestion_order_by!]

    # filter the rows returned
    where: groupQuestion_bool_exp
  ): groupQuestion_aggregate!

  # fetch data from the table: "groupQuestion" using primary key columns
  groupQuestion_by_pk(groupId: uuid!, questionId: Int!): groupQuestion

  # fetch aggregated fields from the table: "groupTrophy"
  groupTrophy_aggregate(
    # distinct select on columns
    distinct_on: [groupTrophy_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupTrophy_order_by!]

    # filter the rows returned
    where: groupTrophy_bool_exp
  ): groupTrophy_aggregate!

  # fetch data from the table: "groupTrophy" using primary key columns
  groupTrophy_by_pk(groupId: uuid!, trophyId: uuid!): groupTrophy

  # fetch aggregated fields from the table: "group"
  group_aggregate(
    # distinct select on columns
    distinct_on: [group_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [group_order_by!]

    # filter the rows returned
    where: group_bool_exp
  ): group_aggregate!

  # fetch data from the table: "group"
  groups(
    # distinct select on columns
    distinct_on: [group_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [group_order_by!]

    # filter the rows returned
    where: group_bool_exp
  ): [group!]!

  # fetch data from the table: "interest" using primary key columns
  interest(name: String!): interest

  # fetch aggregated fields from the table: "interest"
  interest_aggregate(
    # distinct select on columns
    distinct_on: [interest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [interest_order_by!]

    # filter the rows returned
    where: interest_bool_exp
  ): interest_aggregate!

  # fetch data from the table: "interest"
  interests(
    # distinct select on columns
    distinct_on: [interest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [interest_order_by!]

    # filter the rows returned
    where: interest_bool_exp
  ): [interest!]!

  # fetch data from the table: "message" using primary key columns
  message(id: Int!): message

  # fetch aggregated fields from the table: "message"
  message_aggregate(
    # distinct select on columns
    distinct_on: [message_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [message_order_by!]

    # filter the rows returned
    where: message_bool_exp
  ): message_aggregate!

  # fetch data from the table: "message"
  messages(
    # distinct select on columns
    distinct_on: [message_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [message_order_by!]

    # filter the rows returned
    where: message_bool_exp
  ): [message!]!

  # fetch aggregated fields from the table: "notification"
  notification_aggregate(
    # distinct select on columns
    distinct_on: [notification_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [notification_order_by!]

    # filter the rows returned
    where: notification_bool_exp
  ): notification_aggregate!

  # fetch data from the table: "notification" using primary key columns
  notification_by_pk(id: Int!): notification

  # fetch data from the table: "notification"
  notifications(
    # distinct select on columns
    distinct_on: [notification_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [notification_order_by!]

    # filter the rows returned
    where: notification_bool_exp
  ): [notification!]!

  # fetch data from the table: "program" using primary key columns
  program(name: String!): program

  # fetch aggregated fields from the table: "program"
  program_aggregate(
    # distinct select on columns
    distinct_on: [program_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [program_order_by!]

    # filter the rows returned
    where: program_bool_exp
  ): program_aggregate!

  # fetch data from the table: "program"
  programs(
    # distinct select on columns
    distinct_on: [program_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [program_order_by!]

    # filter the rows returned
    where: program_bool_exp
  ): [program!]!

  # fetch aggregated fields from the table: "question"
  question_aggregate(
    # distinct select on columns
    distinct_on: [question_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [question_order_by!]

    # filter the rows returned
    where: question_bool_exp
  ): question_aggregate!

  # fetch data from the table: "question" using primary key columns
  question_by_pk(id: Int!): question

  # fetch data from the table: "question"
  questions(
    # distinct select on columns
    distinct_on: [question_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [question_order_by!]

    # filter the rows returned
    where: question_bool_exp
  ): [question!]!

  # fetch data from the table: "review"
  review(
    # distinct select on columns
    distinct_on: [review_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [review_order_by!]

    # filter the rows returned
    where: review_bool_exp
  ): [review!]!

  # fetch aggregated fields from the table: "review"
  review_aggregate(
    # distinct select on columns
    distinct_on: [review_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [review_order_by!]

    # filter the rows returned
    where: review_bool_exp
  ): review_aggregate!

  # fetch data from the table: "review" using primary key columns
  review_by_pk(id: Int!): review

  # fetch data from the table: "trophy"
  trophy(
    # distinct select on columns
    distinct_on: [trophy_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [trophy_order_by!]

    # filter the rows returned
    where: trophy_bool_exp
  ): [trophy!]!

  # fetch data from the table: "trophyGroupView"
  trophyGroupView(
    # distinct select on columns
    distinct_on: [trophyGroupView_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [trophyGroupView_order_by!]

    # filter the rows returned
    where: trophyGroupView_bool_exp
  ): [trophyGroupView!]!

  # fetch aggregated fields from the table: "trophyGroupView"
  trophyGroupView_aggregate(
    # distinct select on columns
    distinct_on: [trophyGroupView_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [trophyGroupView_order_by!]

    # filter the rows returned
    where: trophyGroupView_bool_exp
  ): trophyGroupView_aggregate!

  # fetch aggregated fields from the table: "trophy"
  trophy_aggregate(
    # distinct select on columns
    distinct_on: [trophy_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [trophy_order_by!]

    # filter the rows returned
    where: trophy_bool_exp
  ): trophy_aggregate!

  # fetch data from the table: "trophy" using primary key columns
  trophy_by_pk(id: uuid!): trophy

  # fetch data from the table: "user" using primary key columns
  user(id: String!): user

  # fetch data from the table: "userChat"
  userChat(
    # distinct select on columns
    distinct_on: [userChat_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userChat_order_by!]

    # filter the rows returned
    where: userChat_bool_exp
  ): [userChat!]!

  # fetch aggregated fields from the table: "userChat"
  userChat_aggregate(
    # distinct select on columns
    distinct_on: [userChat_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userChat_order_by!]

    # filter the rows returned
    where: userChat_bool_exp
  ): userChat_aggregate!

  # fetch data from the table: "userChat" using primary key columns
  userChat_by_pk(chatId: Int!, userId: String!): userChat

  # fetch data from the table: "userEvent"
  userEvent(
    # distinct select on columns
    distinct_on: [userEvent_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userEvent_order_by!]

    # filter the rows returned
    where: userEvent_bool_exp
  ): [userEvent!]!

  # fetch aggregated fields from the table: "userEvent"
  userEvent_aggregate(
    # distinct select on columns
    distinct_on: [userEvent_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userEvent_order_by!]

    # filter the rows returned
    where: userEvent_bool_exp
  ): userEvent_aggregate!

  # fetch data from the table: "userEvent" using primary key columns
  userEvent_by_pk(eventId: uuid!, userId: String!): userEvent

  # fetch data from the table: "userInterest"
  userInterest(
    # distinct select on columns
    distinct_on: [userInterest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userInterest_order_by!]

    # filter the rows returned
    where: userInterest_bool_exp
  ): [userInterest!]!

  # fetch aggregated fields from the table: "userInterest"
  userInterest_aggregate(
    # distinct select on columns
    distinct_on: [userInterest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userInterest_order_by!]

    # filter the rows returned
    where: userInterest_bool_exp
  ): userInterest_aggregate!

  # fetch data from the table: "userInterest" using primary key columns
  userInterest_by_pk(interestId: Int!, userId: String!): userInterest

  # fetch data from the table: "userMember"
  userMember(
    # distinct select on columns
    distinct_on: [userMember_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userMember_order_by!]

    # filter the rows returned
    where: userMember_bool_exp
  ): [userMember!]!

  # fetch aggregated fields from the table: "userMember"
  userMember_aggregate(
    # distinct select on columns
    distinct_on: [userMember_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userMember_order_by!]

    # filter the rows returned
    where: userMember_bool_exp
  ): userMember_aggregate!

  # fetch data from the table: "userMember" using primary key columns
  userMember_by_pk(groupId: uuid!, userId: String!): userMember

  # fetch data from the table: "userOwner"
  userOwner(
    # distinct select on columns
    distinct_on: [userOwner_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userOwner_order_by!]

    # filter the rows returned
    where: userOwner_bool_exp
  ): [userOwner!]!

  # fetch aggregated fields from the table: "userOwner"
  userOwner_aggregate(
    # distinct select on columns
    distinct_on: [userOwner_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userOwner_order_by!]

    # filter the rows returned
    where: userOwner_bool_exp
  ): userOwner_aggregate!

  # fetch data from the table: "userOwner" using primary key columns
  userOwner_by_pk(groupId: uuid!, userId: String!): userOwner

  # fetch data from the table: "userProgram"
  userProgram(
    # distinct select on columns
    distinct_on: [userProgram_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userProgram_order_by!]

    # filter the rows returned
    where: userProgram_bool_exp
  ): [userProgram!]!

  # fetch aggregated fields from the table: "userProgram"
  userProgram_aggregate(
    # distinct select on columns
    distinct_on: [userProgram_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userProgram_order_by!]

    # filter the rows returned
    where: userProgram_bool_exp
  ): userProgram_aggregate!

  # fetch data from the table: "userProgram" using primary key columns
  userProgram_by_pk(programId: Int!, userId: String!): userProgram

  # fetch aggregated fields from the table: "user"
  user_aggregate(
    # distinct select on columns
    distinct_on: [user_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [user_order_by!]

    # filter the rows returned
    where: user_bool_exp
  ): user_aggregate!

  # fetch data from the table: "user"
  users(
    # distinct select on columns
    distinct_on: [user_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [user_order_by!]

    # filter the rows returned
    where: user_bool_exp
  ): [user!]!
}

# columns and relationships of "question"
type question {
  answer: String!
  author: String!

  # An array relationship
  eventQuestions(
    # distinct select on columns
    distinct_on: [eventQuestion_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [eventQuestion_order_by!]

    # filter the rows returned
    where: eventQuestion_bool_exp
  ): [eventQuestion!]!

  # An aggregated array relationship
  eventQuestions_aggregate(
    # distinct select on columns
    distinct_on: [eventQuestion_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [eventQuestion_order_by!]

    # filter the rows returned
    where: eventQuestion_bool_exp
  ): eventQuestion_aggregate!

  # An array relationship
  groupQuestions(
    # distinct select on columns
    distinct_on: [groupQuestion_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupQuestion_order_by!]

    # filter the rows returned
    where: groupQuestion_bool_exp
  ): [groupQuestion!]!

  # An aggregated array relationship
  groupQuestions_aggregate(
    # distinct select on columns
    distinct_on: [groupQuestion_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupQuestion_order_by!]

    # filter the rows returned
    where: groupQuestion_bool_exp
  ): groupQuestion_aggregate!
  id: Int!
  question: String!

  # An object relationship
  user: user!
}

# aggregated selection of "question"
type question_aggregate {
  aggregate: question_aggregate_fields
  nodes: [question!]!
}

# aggregate fields of "question"
type question_aggregate_fields {
  avg: question_avg_fields
  count(columns: [question_select_column!], distinct: Boolean): Int
  max: question_max_fields
  min: question_min_fields
  stddev: question_stddev_fields
  stddev_pop: question_stddev_pop_fields
  stddev_samp: question_stddev_samp_fields
  sum: question_sum_fields
  var_pop: question_var_pop_fields
  var_samp: question_var_samp_fields
  variance: question_variance_fields
}

# order by aggregate values of table "question"
input question_aggregate_order_by {
  avg: question_avg_order_by
  count: order_by
  max: question_max_order_by
  min: question_min_order_by
  stddev: question_stddev_order_by
  stddev_pop: question_stddev_pop_order_by
  stddev_samp: question_stddev_samp_order_by
  sum: question_sum_order_by
  var_pop: question_var_pop_order_by
  var_samp: question_var_samp_order_by
  variance: question_variance_order_by
}

# input type for inserting array relation for remote table "question"
input question_arr_rel_insert_input {
  data: [question_insert_input!]!
  on_conflict: question_on_conflict
}

# aggregate avg on columns
type question_avg_fields {
  id: Float
}

# order by avg() on columns of table "question"
input question_avg_order_by {
  id: order_by
}

# Boolean expression to filter rows from the table "question". All fields are combined with a logical 'AND'.
input question_bool_exp {
  _and: [question_bool_exp]
  _not: question_bool_exp
  _or: [question_bool_exp]
  answer: String_comparison_exp
  author: String_comparison_exp
  eventQuestions: eventQuestion_bool_exp
  groupQuestions: groupQuestion_bool_exp
  id: Int_comparison_exp
  question: String_comparison_exp
  user: user_bool_exp
}

# unique or primary key constraints on table "question"
enum question_constraint {
  # unique or primary key constraint
  question_pkey
}

# input type for incrementing integer column in table "question"
input question_inc_input {
  id: Int
}

# input type for inserting data into table "question"
input question_insert_input {
  answer: String
  author: String
  eventQuestions: eventQuestion_arr_rel_insert_input
  groupQuestions: groupQuestion_arr_rel_insert_input
  id: Int
  question: String
  user: user_obj_rel_insert_input
}

# aggregate max on columns
type question_max_fields {
  answer: String
  author: String
  id: Int
  question: String
}

# order by max() on columns of table "question"
input question_max_order_by {
  answer: order_by
  author: order_by
  id: order_by
  question: order_by
}

# aggregate min on columns
type question_min_fields {
  answer: String
  author: String
  id: Int
  question: String
}

# order by min() on columns of table "question"
input question_min_order_by {
  answer: order_by
  author: order_by
  id: order_by
  question: order_by
}

# response of any mutation on the table "question"
type question_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [question!]!
}

# input type for inserting object relation for remote table "question"
input question_obj_rel_insert_input {
  data: question_insert_input!
  on_conflict: question_on_conflict
}

# on conflict condition type for table "question"
input question_on_conflict {
  constraint: question_constraint!
  update_columns: [question_update_column!]!
  where: question_bool_exp
}

# ordering options when selecting data from "question"
input question_order_by {
  answer: order_by
  author: order_by
  eventQuestions_aggregate: eventQuestion_aggregate_order_by
  groupQuestions_aggregate: groupQuestion_aggregate_order_by
  id: order_by
  question: order_by
  user: user_order_by
}

# primary key columns input for table: "question"
input question_pk_columns_input {
  id: Int!
}

# select columns of table "question"
enum question_select_column {
  # column name
  answer

  # column name
  author

  # column name
  id

  # column name
  question
}

# input type for updating data in table "question"
input question_set_input {
  answer: String
  author: String
  id: Int
  question: String
}

# aggregate stddev on columns
type question_stddev_fields {
  id: Float
}

# order by stddev() on columns of table "question"
input question_stddev_order_by {
  id: order_by
}

# aggregate stddev_pop on columns
type question_stddev_pop_fields {
  id: Float
}

# order by stddev_pop() on columns of table "question"
input question_stddev_pop_order_by {
  id: order_by
}

# aggregate stddev_samp on columns
type question_stddev_samp_fields {
  id: Float
}

# order by stddev_samp() on columns of table "question"
input question_stddev_samp_order_by {
  id: order_by
}

# aggregate sum on columns
type question_sum_fields {
  id: Int
}

# order by sum() on columns of table "question"
input question_sum_order_by {
  id: order_by
}

# update columns of table "question"
enum question_update_column {
  # column name
  answer

  # column name
  author

  # column name
  id

  # column name
  question
}

# aggregate var_pop on columns
type question_var_pop_fields {
  id: Float
}

# order by var_pop() on columns of table "question"
input question_var_pop_order_by {
  id: order_by
}

# aggregate var_samp on columns
type question_var_samp_fields {
  id: Float
}

# order by var_samp() on columns of table "question"
input question_var_samp_order_by {
  id: order_by
}

# aggregate variance on columns
type question_variance_fields {
  id: Float
}

# order by variance() on columns of table "question"
input question_variance_order_by {
  id: order_by
}

# columns and relationships of "review"
type review {
  author: String!
  comment: String
  group: uuid!

  # An object relationship
  groupByGroup: group!
  id: Int!
  rating: Int!

  # An object relationship
  user: user!
}

# aggregated selection of "review"
type review_aggregate {
  aggregate: review_aggregate_fields
  nodes: [review!]!
}

# aggregate fields of "review"
type review_aggregate_fields {
  avg: review_avg_fields
  count(columns: [review_select_column!], distinct: Boolean): Int
  max: review_max_fields
  min: review_min_fields
  stddev: review_stddev_fields
  stddev_pop: review_stddev_pop_fields
  stddev_samp: review_stddev_samp_fields
  sum: review_sum_fields
  var_pop: review_var_pop_fields
  var_samp: review_var_samp_fields
  variance: review_variance_fields
}

# order by aggregate values of table "review"
input review_aggregate_order_by {
  avg: review_avg_order_by
  count: order_by
  max: review_max_order_by
  min: review_min_order_by
  stddev: review_stddev_order_by
  stddev_pop: review_stddev_pop_order_by
  stddev_samp: review_stddev_samp_order_by
  sum: review_sum_order_by
  var_pop: review_var_pop_order_by
  var_samp: review_var_samp_order_by
  variance: review_variance_order_by
}

# input type for inserting array relation for remote table "review"
input review_arr_rel_insert_input {
  data: [review_insert_input!]!
  on_conflict: review_on_conflict
}

# aggregate avg on columns
type review_avg_fields {
  id: Float
  rating: Float
}

# order by avg() on columns of table "review"
input review_avg_order_by {
  id: order_by
  rating: order_by
}

# Boolean expression to filter rows from the table "review". All fields are combined with a logical 'AND'.
input review_bool_exp {
  _and: [review_bool_exp]
  _not: review_bool_exp
  _or: [review_bool_exp]
  author: String_comparison_exp
  comment: String_comparison_exp
  group: uuid_comparison_exp
  groupByGroup: group_bool_exp
  id: Int_comparison_exp
  rating: Int_comparison_exp
  user: user_bool_exp
}

# unique or primary key constraints on table "review"
enum review_constraint {
  # unique or primary key constraint
  review_id1_key

  # unique or primary key constraint
  review_pkey
}

# input type for incrementing integer column in table "review"
input review_inc_input {
  id: Int
  rating: Int
}

# input type for inserting data into table "review"
input review_insert_input {
  author: String
  comment: String
  group: uuid
  groupByGroup: group_obj_rel_insert_input
  id: Int
  rating: Int
  user: user_obj_rel_insert_input
}

# aggregate max on columns
type review_max_fields {
  author: String
  comment: String
  group: uuid
  id: Int
  rating: Int
}

# order by max() on columns of table "review"
input review_max_order_by {
  author: order_by
  comment: order_by
  group: order_by
  id: order_by
  rating: order_by
}

# aggregate min on columns
type review_min_fields {
  author: String
  comment: String
  group: uuid
  id: Int
  rating: Int
}

# order by min() on columns of table "review"
input review_min_order_by {
  author: order_by
  comment: order_by
  group: order_by
  id: order_by
  rating: order_by
}

# response of any mutation on the table "review"
type review_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [review!]!
}

# input type for inserting object relation for remote table "review"
input review_obj_rel_insert_input {
  data: review_insert_input!
  on_conflict: review_on_conflict
}

# on conflict condition type for table "review"
input review_on_conflict {
  constraint: review_constraint!
  update_columns: [review_update_column!]!
  where: review_bool_exp
}

# ordering options when selecting data from "review"
input review_order_by {
  author: order_by
  comment: order_by
  group: order_by
  groupByGroup: group_order_by
  id: order_by
  rating: order_by
  user: user_order_by
}

# primary key columns input for table: "review"
input review_pk_columns_input {
  id: Int!
}

# select columns of table "review"
enum review_select_column {
  # column name
  author

  # column name
  comment

  # column name
  group

  # column name
  id

  # column name
  rating
}

# input type for updating data in table "review"
input review_set_input {
  author: String
  comment: String
  group: uuid
  id: Int
  rating: Int
}

# aggregate stddev on columns
type review_stddev_fields {
  id: Float
  rating: Float
}

# order by stddev() on columns of table "review"
input review_stddev_order_by {
  id: order_by
  rating: order_by
}

# aggregate stddev_pop on columns
type review_stddev_pop_fields {
  id: Float
  rating: Float
}

# order by stddev_pop() on columns of table "review"
input review_stddev_pop_order_by {
  id: order_by
  rating: order_by
}

# aggregate stddev_samp on columns
type review_stddev_samp_fields {
  id: Float
  rating: Float
}

# order by stddev_samp() on columns of table "review"
input review_stddev_samp_order_by {
  id: order_by
  rating: order_by
}

# aggregate sum on columns
type review_sum_fields {
  id: Int
  rating: Int
}

# order by sum() on columns of table "review"
input review_sum_order_by {
  id: order_by
  rating: order_by
}

# update columns of table "review"
enum review_update_column {
  # column name
  author

  # column name
  comment

  # column name
  group

  # column name
  id

  # column name
  rating
}

# aggregate var_pop on columns
type review_var_pop_fields {
  id: Float
  rating: Float
}

# order by var_pop() on columns of table "review"
input review_var_pop_order_by {
  id: order_by
  rating: order_by
}

# aggregate var_samp on columns
type review_var_samp_fields {
  id: Float
  rating: Float
}

# order by var_samp() on columns of table "review"
input review_var_samp_order_by {
  id: order_by
  rating: order_by
}

# aggregate variance on columns
type review_variance_fields {
  id: Float
  rating: Float
}

# order by variance() on columns of table "review"
input review_variance_order_by {
  id: order_by
  rating: order_by
}

# expression to compare columns of type String. All fields are combined with logical 'AND'.
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  _ilike: String
  _in: [String!]
  _is_null: Boolean
  _like: String
  _lt: String
  _lte: String
  _neq: String
  _nilike: String
  _nin: [String!]
  _nlike: String
  _nsimilar: String
  _similar: String
}

# subscription root
type subscription_root {
  # fetch data from the table: "chat" using primary key columns
  chat(id: Int!): chat

  # fetch data from the table: "chatUserView"
  chatUserView(
    # distinct select on columns
    distinct_on: [chatUserView_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [chatUserView_order_by!]

    # filter the rows returned
    where: chatUserView_bool_exp
  ): [chatUserView!]!

  # fetch aggregated fields from the table: "chatUserView"
  chatUserView_aggregate(
    # distinct select on columns
    distinct_on: [chatUserView_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [chatUserView_order_by!]

    # filter the rows returned
    where: chatUserView_bool_exp
  ): chatUserView_aggregate!

  # fetch aggregated fields from the table: "chat"
  chat_aggregate(
    # distinct select on columns
    distinct_on: [chat_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [chat_order_by!]

    # filter the rows returned
    where: chat_bool_exp
  ): chat_aggregate!

  # fetch data from the table: "chat"
  chats(
    # distinct select on columns
    distinct_on: [chat_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [chat_order_by!]

    # filter the rows returned
    where: chat_bool_exp
  ): [chat!]!

  # fetch data from the table: "event" using primary key columns
  event(id: uuid!): event

  # fetch data from the table: "eventQuestion"
  eventQuestion(
    # distinct select on columns
    distinct_on: [eventQuestion_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [eventQuestion_order_by!]

    # filter the rows returned
    where: eventQuestion_bool_exp
  ): [eventQuestion!]!

  # fetch aggregated fields from the table: "eventQuestion"
  eventQuestion_aggregate(
    # distinct select on columns
    distinct_on: [eventQuestion_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [eventQuestion_order_by!]

    # filter the rows returned
    where: eventQuestion_bool_exp
  ): eventQuestion_aggregate!

  # fetch data from the table: "eventQuestion" using primary key columns
  eventQuestion_by_pk(eventId: uuid!, questionId: Int!): eventQuestion

  # fetch aggregated fields from the table: "event"
  event_aggregate(
    # distinct select on columns
    distinct_on: [event_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [event_order_by!]

    # filter the rows returned
    where: event_bool_exp
  ): event_aggregate!

  # fetch data from the table: "event"
  events(
    # distinct select on columns
    distinct_on: [event_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [event_order_by!]

    # filter the rows returned
    where: event_bool_exp
  ): [event!]!

  # fetch data from the table: "friend"
  friend(
    # distinct select on columns
    distinct_on: [friend_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [friend_order_by!]

    # filter the rows returned
    where: friend_bool_exp
  ): [friend!]!

  # fetch data from the table: "friendRequest"
  friendRequest(
    # distinct select on columns
    distinct_on: [friendRequest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [friendRequest_order_by!]

    # filter the rows returned
    where: friendRequest_bool_exp
  ): [friendRequest!]!

  # fetch aggregated fields from the table: "friendRequest"
  friendRequest_aggregate(
    # distinct select on columns
    distinct_on: [friendRequest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [friendRequest_order_by!]

    # filter the rows returned
    where: friendRequest_bool_exp
  ): friendRequest_aggregate!

  # fetch data from the table: "friendRequest" using primary key columns
  friendRequest_by_pk(recipient: String!, sender: String!): friendRequest

  # fetch aggregated fields from the table: "friendView"
  friendView_aggregate(
    # distinct select on columns
    distinct_on: [friendView_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [friendView_order_by!]

    # filter the rows returned
    where: friendView_bool_exp
  ): friendView_aggregate!

  # fetch aggregated fields from the table: "friend"
  friend_aggregate(
    # distinct select on columns
    distinct_on: [friend_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [friend_order_by!]

    # filter the rows returned
    where: friend_bool_exp
  ): friend_aggregate!

  # fetch data from the table: "friend" using primary key columns
  friend_by_pk(friendId: String!, userId: String!): friend

  # fetch data from the table: "friendView"
  friends(
    # distinct select on columns
    distinct_on: [friendView_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [friendView_order_by!]

    # filter the rows returned
    where: friendView_bool_exp
  ): [friendView!]!

  # fetch data from the table: "groupTrophy"
  getTrophies(
    # distinct select on columns
    distinct_on: [groupTrophy_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupTrophy_order_by!]

    # filter the rows returned
    where: groupTrophy_bool_exp
  ): [groupTrophy!]!

  # fetch data from the table: "group" using primary key columns
  group(id: uuid!): group

  # fetch data from the table: "groupEvent"
  groupEvent(
    # distinct select on columns
    distinct_on: [groupEvent_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupEvent_order_by!]

    # filter the rows returned
    where: groupEvent_bool_exp
  ): [groupEvent!]!

  # fetch aggregated fields from the table: "groupEvent"
  groupEvent_aggregate(
    # distinct select on columns
    distinct_on: [groupEvent_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupEvent_order_by!]

    # filter the rows returned
    where: groupEvent_bool_exp
  ): groupEvent_aggregate!

  # fetch data from the table: "groupEvent" using primary key columns
  groupEvent_by_pk(eventId: uuid!, groupId: uuid!): groupEvent

  # fetch data from the table: "groupInterest"
  groupInterest(
    # distinct select on columns
    distinct_on: [groupInterest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupInterest_order_by!]

    # filter the rows returned
    where: groupInterest_bool_exp
  ): [groupInterest!]!

  # fetch aggregated fields from the table: "groupInterest"
  groupInterest_aggregate(
    # distinct select on columns
    distinct_on: [groupInterest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupInterest_order_by!]

    # filter the rows returned
    where: groupInterest_bool_exp
  ): groupInterest_aggregate!

  # fetch data from the table: "groupInterest" using primary key columns
  groupInterest_by_pk(groupId: uuid!, interestId: Int!): groupInterest

  # fetch data from the table: "groupQuestion"
  groupQuestion(
    # distinct select on columns
    distinct_on: [groupQuestion_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupQuestion_order_by!]

    # filter the rows returned
    where: groupQuestion_bool_exp
  ): [groupQuestion!]!

  # fetch aggregated fields from the table: "groupQuestion"
  groupQuestion_aggregate(
    # distinct select on columns
    distinct_on: [groupQuestion_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupQuestion_order_by!]

    # filter the rows returned
    where: groupQuestion_bool_exp
  ): groupQuestion_aggregate!

  # fetch data from the table: "groupQuestion" using primary key columns
  groupQuestion_by_pk(groupId: uuid!, questionId: Int!): groupQuestion

  # fetch aggregated fields from the table: "groupTrophy"
  groupTrophy_aggregate(
    # distinct select on columns
    distinct_on: [groupTrophy_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupTrophy_order_by!]

    # filter the rows returned
    where: groupTrophy_bool_exp
  ): groupTrophy_aggregate!

  # fetch data from the table: "groupTrophy" using primary key columns
  groupTrophy_by_pk(groupId: uuid!, trophyId: uuid!): groupTrophy

  # fetch aggregated fields from the table: "group"
  group_aggregate(
    # distinct select on columns
    distinct_on: [group_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [group_order_by!]

    # filter the rows returned
    where: group_bool_exp
  ): group_aggregate!

  # fetch data from the table: "group"
  groups(
    # distinct select on columns
    distinct_on: [group_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [group_order_by!]

    # filter the rows returned
    where: group_bool_exp
  ): [group!]!

  # fetch data from the table: "interest" using primary key columns
  interest(name: String!): interest

  # fetch aggregated fields from the table: "interest"
  interest_aggregate(
    # distinct select on columns
    distinct_on: [interest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [interest_order_by!]

    # filter the rows returned
    where: interest_bool_exp
  ): interest_aggregate!

  # fetch data from the table: "interest"
  interests(
    # distinct select on columns
    distinct_on: [interest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [interest_order_by!]

    # filter the rows returned
    where: interest_bool_exp
  ): [interest!]!

  # fetch data from the table: "message" using primary key columns
  message(id: Int!): message

  # fetch aggregated fields from the table: "message"
  message_aggregate(
    # distinct select on columns
    distinct_on: [message_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [message_order_by!]

    # filter the rows returned
    where: message_bool_exp
  ): message_aggregate!

  # fetch data from the table: "message"
  messages(
    # distinct select on columns
    distinct_on: [message_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [message_order_by!]

    # filter the rows returned
    where: message_bool_exp
  ): [message!]!

  # fetch aggregated fields from the table: "notification"
  notification_aggregate(
    # distinct select on columns
    distinct_on: [notification_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [notification_order_by!]

    # filter the rows returned
    where: notification_bool_exp
  ): notification_aggregate!

  # fetch data from the table: "notification" using primary key columns
  notification_by_pk(id: Int!): notification

  # fetch data from the table: "notification"
  notifications(
    # distinct select on columns
    distinct_on: [notification_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [notification_order_by!]

    # filter the rows returned
    where: notification_bool_exp
  ): [notification!]!

  # fetch data from the table: "program" using primary key columns
  program(name: String!): program

  # fetch aggregated fields from the table: "program"
  program_aggregate(
    # distinct select on columns
    distinct_on: [program_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [program_order_by!]

    # filter the rows returned
    where: program_bool_exp
  ): program_aggregate!

  # fetch data from the table: "program"
  programs(
    # distinct select on columns
    distinct_on: [program_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [program_order_by!]

    # filter the rows returned
    where: program_bool_exp
  ): [program!]!

  # fetch aggregated fields from the table: "question"
  question_aggregate(
    # distinct select on columns
    distinct_on: [question_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [question_order_by!]

    # filter the rows returned
    where: question_bool_exp
  ): question_aggregate!

  # fetch data from the table: "question" using primary key columns
  question_by_pk(id: Int!): question

  # fetch data from the table: "question"
  questions(
    # distinct select on columns
    distinct_on: [question_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [question_order_by!]

    # filter the rows returned
    where: question_bool_exp
  ): [question!]!

  # fetch data from the table: "review"
  review(
    # distinct select on columns
    distinct_on: [review_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [review_order_by!]

    # filter the rows returned
    where: review_bool_exp
  ): [review!]!

  # fetch aggregated fields from the table: "review"
  review_aggregate(
    # distinct select on columns
    distinct_on: [review_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [review_order_by!]

    # filter the rows returned
    where: review_bool_exp
  ): review_aggregate!

  # fetch data from the table: "review" using primary key columns
  review_by_pk(id: Int!): review

  # fetch data from the table: "trophy"
  trophy(
    # distinct select on columns
    distinct_on: [trophy_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [trophy_order_by!]

    # filter the rows returned
    where: trophy_bool_exp
  ): [trophy!]!

  # fetch data from the table: "trophyGroupView"
  trophyGroupView(
    # distinct select on columns
    distinct_on: [trophyGroupView_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [trophyGroupView_order_by!]

    # filter the rows returned
    where: trophyGroupView_bool_exp
  ): [trophyGroupView!]!

  # fetch aggregated fields from the table: "trophyGroupView"
  trophyGroupView_aggregate(
    # distinct select on columns
    distinct_on: [trophyGroupView_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [trophyGroupView_order_by!]

    # filter the rows returned
    where: trophyGroupView_bool_exp
  ): trophyGroupView_aggregate!

  # fetch aggregated fields from the table: "trophy"
  trophy_aggregate(
    # distinct select on columns
    distinct_on: [trophy_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [trophy_order_by!]

    # filter the rows returned
    where: trophy_bool_exp
  ): trophy_aggregate!

  # fetch data from the table: "trophy" using primary key columns
  trophy_by_pk(id: uuid!): trophy

  # fetch data from the table: "user" using primary key columns
  user(id: String!): user

  # fetch data from the table: "userChat"
  userChat(
    # distinct select on columns
    distinct_on: [userChat_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userChat_order_by!]

    # filter the rows returned
    where: userChat_bool_exp
  ): [userChat!]!

  # fetch aggregated fields from the table: "userChat"
  userChat_aggregate(
    # distinct select on columns
    distinct_on: [userChat_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userChat_order_by!]

    # filter the rows returned
    where: userChat_bool_exp
  ): userChat_aggregate!

  # fetch data from the table: "userChat" using primary key columns
  userChat_by_pk(chatId: Int!, userId: String!): userChat

  # fetch data from the table: "userEvent"
  userEvent(
    # distinct select on columns
    distinct_on: [userEvent_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userEvent_order_by!]

    # filter the rows returned
    where: userEvent_bool_exp
  ): [userEvent!]!

  # fetch aggregated fields from the table: "userEvent"
  userEvent_aggregate(
    # distinct select on columns
    distinct_on: [userEvent_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userEvent_order_by!]

    # filter the rows returned
    where: userEvent_bool_exp
  ): userEvent_aggregate!

  # fetch data from the table: "userEvent" using primary key columns
  userEvent_by_pk(eventId: uuid!, userId: String!): userEvent

  # fetch data from the table: "userInterest"
  userInterest(
    # distinct select on columns
    distinct_on: [userInterest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userInterest_order_by!]

    # filter the rows returned
    where: userInterest_bool_exp
  ): [userInterest!]!

  # fetch aggregated fields from the table: "userInterest"
  userInterest_aggregate(
    # distinct select on columns
    distinct_on: [userInterest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userInterest_order_by!]

    # filter the rows returned
    where: userInterest_bool_exp
  ): userInterest_aggregate!

  # fetch data from the table: "userInterest" using primary key columns
  userInterest_by_pk(interestId: Int!, userId: String!): userInterest

  # fetch data from the table: "userMember"
  userMember(
    # distinct select on columns
    distinct_on: [userMember_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userMember_order_by!]

    # filter the rows returned
    where: userMember_bool_exp
  ): [userMember!]!

  # fetch aggregated fields from the table: "userMember"
  userMember_aggregate(
    # distinct select on columns
    distinct_on: [userMember_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userMember_order_by!]

    # filter the rows returned
    where: userMember_bool_exp
  ): userMember_aggregate!

  # fetch data from the table: "userMember" using primary key columns
  userMember_by_pk(groupId: uuid!, userId: String!): userMember

  # fetch data from the table: "userOwner"
  userOwner(
    # distinct select on columns
    distinct_on: [userOwner_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userOwner_order_by!]

    # filter the rows returned
    where: userOwner_bool_exp
  ): [userOwner!]!

  # fetch aggregated fields from the table: "userOwner"
  userOwner_aggregate(
    # distinct select on columns
    distinct_on: [userOwner_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userOwner_order_by!]

    # filter the rows returned
    where: userOwner_bool_exp
  ): userOwner_aggregate!

  # fetch data from the table: "userOwner" using primary key columns
  userOwner_by_pk(groupId: uuid!, userId: String!): userOwner

  # fetch data from the table: "userProgram"
  userProgram(
    # distinct select on columns
    distinct_on: [userProgram_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userProgram_order_by!]

    # filter the rows returned
    where: userProgram_bool_exp
  ): [userProgram!]!

  # fetch aggregated fields from the table: "userProgram"
  userProgram_aggregate(
    # distinct select on columns
    distinct_on: [userProgram_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userProgram_order_by!]

    # filter the rows returned
    where: userProgram_bool_exp
  ): userProgram_aggregate!

  # fetch data from the table: "userProgram" using primary key columns
  userProgram_by_pk(programId: Int!, userId: String!): userProgram

  # fetch aggregated fields from the table: "user"
  user_aggregate(
    # distinct select on columns
    distinct_on: [user_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [user_order_by!]

    # filter the rows returned
    where: user_bool_exp
  ): user_aggregate!

  # fetch data from the table: "user"
  users(
    # distinct select on columns
    distinct_on: [user_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [user_order_by!]

    # filter the rows returned
    where: user_bool_exp
  ): [user!]!
}

scalar timestamptz

# expression to compare columns of type timestamptz. All fields are combined with logical 'AND'.
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

# columns and relationships of "trophy"
type trophy {
  description: String!

  # An array relationship
  groupTrophies(
    # distinct select on columns
    distinct_on: [groupTrophy_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupTrophy_order_by!]

    # filter the rows returned
    where: groupTrophy_bool_exp
  ): [groupTrophy!]!

  # An aggregated array relationship
  groupTrophies_aggregate(
    # distinct select on columns
    distinct_on: [groupTrophy_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupTrophy_order_by!]

    # filter the rows returned
    where: groupTrophy_bool_exp
  ): groupTrophy_aggregate!
  id: uuid!
  name: String!
  score: Int!
}

# aggregated selection of "trophy"
type trophy_aggregate {
  aggregate: trophy_aggregate_fields
  nodes: [trophy!]!
}

# aggregate fields of "trophy"
type trophy_aggregate_fields {
  avg: trophy_avg_fields
  count(columns: [trophy_select_column!], distinct: Boolean): Int
  max: trophy_max_fields
  min: trophy_min_fields
  stddev: trophy_stddev_fields
  stddev_pop: trophy_stddev_pop_fields
  stddev_samp: trophy_stddev_samp_fields
  sum: trophy_sum_fields
  var_pop: trophy_var_pop_fields
  var_samp: trophy_var_samp_fields
  variance: trophy_variance_fields
}

# order by aggregate values of table "trophy"
input trophy_aggregate_order_by {
  avg: trophy_avg_order_by
  count: order_by
  max: trophy_max_order_by
  min: trophy_min_order_by
  stddev: trophy_stddev_order_by
  stddev_pop: trophy_stddev_pop_order_by
  stddev_samp: trophy_stddev_samp_order_by
  sum: trophy_sum_order_by
  var_pop: trophy_var_pop_order_by
  var_samp: trophy_var_samp_order_by
  variance: trophy_variance_order_by
}

# input type for inserting array relation for remote table "trophy"
input trophy_arr_rel_insert_input {
  data: [trophy_insert_input!]!
  on_conflict: trophy_on_conflict
}

# aggregate avg on columns
type trophy_avg_fields {
  score: Float
}

# order by avg() on columns of table "trophy"
input trophy_avg_order_by {
  score: order_by
}

# Boolean expression to filter rows from the table "trophy". All fields are combined with a logical 'AND'.
input trophy_bool_exp {
  _and: [trophy_bool_exp]
  _not: trophy_bool_exp
  _or: [trophy_bool_exp]
  description: String_comparison_exp
  groupTrophies: groupTrophy_bool_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  score: Int_comparison_exp
}

# unique or primary key constraints on table "trophy"
enum trophy_constraint {
  # unique or primary key constraint
  trophy_pkey
}

# input type for incrementing integer column in table "trophy"
input trophy_inc_input {
  score: Int
}

# input type for inserting data into table "trophy"
input trophy_insert_input {
  description: String
  groupTrophies: groupTrophy_arr_rel_insert_input
  id: uuid
  name: String
  score: Int
}

# aggregate max on columns
type trophy_max_fields {
  description: String
  id: uuid
  name: String
  score: Int
}

# order by max() on columns of table "trophy"
input trophy_max_order_by {
  description: order_by
  id: order_by
  name: order_by
  score: order_by
}

# aggregate min on columns
type trophy_min_fields {
  description: String
  id: uuid
  name: String
  score: Int
}

# order by min() on columns of table "trophy"
input trophy_min_order_by {
  description: order_by
  id: order_by
  name: order_by
  score: order_by
}

# response of any mutation on the table "trophy"
type trophy_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [trophy!]!
}

# input type for inserting object relation for remote table "trophy"
input trophy_obj_rel_insert_input {
  data: trophy_insert_input!
  on_conflict: trophy_on_conflict
}

# on conflict condition type for table "trophy"
input trophy_on_conflict {
  constraint: trophy_constraint!
  update_columns: [trophy_update_column!]!
  where: trophy_bool_exp
}

# ordering options when selecting data from "trophy"
input trophy_order_by {
  description: order_by
  groupTrophies_aggregate: groupTrophy_aggregate_order_by
  id: order_by
  name: order_by
  score: order_by
}

# primary key columns input for table: "trophy"
input trophy_pk_columns_input {
  id: uuid!
}

# select columns of table "trophy"
enum trophy_select_column {
  # column name
  description

  # column name
  id

  # column name
  name

  # column name
  score
}

# input type for updating data in table "trophy"
input trophy_set_input {
  description: String
  id: uuid
  name: String
  score: Int
}

# aggregate stddev on columns
type trophy_stddev_fields {
  score: Float
}

# order by stddev() on columns of table "trophy"
input trophy_stddev_order_by {
  score: order_by
}

# aggregate stddev_pop on columns
type trophy_stddev_pop_fields {
  score: Float
}

# order by stddev_pop() on columns of table "trophy"
input trophy_stddev_pop_order_by {
  score: order_by
}

# aggregate stddev_samp on columns
type trophy_stddev_samp_fields {
  score: Float
}

# order by stddev_samp() on columns of table "trophy"
input trophy_stddev_samp_order_by {
  score: order_by
}

# aggregate sum on columns
type trophy_sum_fields {
  score: Int
}

# order by sum() on columns of table "trophy"
input trophy_sum_order_by {
  score: order_by
}

# update columns of table "trophy"
enum trophy_update_column {
  # column name
  description

  # column name
  id

  # column name
  name

  # column name
  score
}

# aggregate var_pop on columns
type trophy_var_pop_fields {
  score: Float
}

# order by var_pop() on columns of table "trophy"
input trophy_var_pop_order_by {
  score: order_by
}

# aggregate var_samp on columns
type trophy_var_samp_fields {
  score: Float
}

# order by var_samp() on columns of table "trophy"
input trophy_var_samp_order_by {
  score: order_by
}

# aggregate variance on columns
type trophy_variance_fields {
  score: Float
}

# order by variance() on columns of table "trophy"
input trophy_variance_order_by {
  score: order_by
}

# columns and relationships of "trophyGroupView"
type trophyGroupView {
  description: String
  groupId: uuid
  id: uuid
  name: String
  score: Int
}

# aggregated selection of "trophyGroupView"
type trophyGroupView_aggregate {
  aggregate: trophyGroupView_aggregate_fields
  nodes: [trophyGroupView!]!
}

# aggregate fields of "trophyGroupView"
type trophyGroupView_aggregate_fields {
  avg: trophyGroupView_avg_fields
  count(columns: [trophyGroupView_select_column!], distinct: Boolean): Int
  max: trophyGroupView_max_fields
  min: trophyGroupView_min_fields
  stddev: trophyGroupView_stddev_fields
  stddev_pop: trophyGroupView_stddev_pop_fields
  stddev_samp: trophyGroupView_stddev_samp_fields
  sum: trophyGroupView_sum_fields
  var_pop: trophyGroupView_var_pop_fields
  var_samp: trophyGroupView_var_samp_fields
  variance: trophyGroupView_variance_fields
}

# order by aggregate values of table "trophyGroupView"
input trophyGroupView_aggregate_order_by {
  avg: trophyGroupView_avg_order_by
  count: order_by
  max: trophyGroupView_max_order_by
  min: trophyGroupView_min_order_by
  stddev: trophyGroupView_stddev_order_by
  stddev_pop: trophyGroupView_stddev_pop_order_by
  stddev_samp: trophyGroupView_stddev_samp_order_by
  sum: trophyGroupView_sum_order_by
  var_pop: trophyGroupView_var_pop_order_by
  var_samp: trophyGroupView_var_samp_order_by
  variance: trophyGroupView_variance_order_by
}

# aggregate avg on columns
type trophyGroupView_avg_fields {
  score: Float
}

# order by avg() on columns of table "trophyGroupView"
input trophyGroupView_avg_order_by {
  score: order_by
}

# Boolean expression to filter rows from the table "trophyGroupView". All fields are combined with a logical 'AND'.
input trophyGroupView_bool_exp {
  _and: [trophyGroupView_bool_exp]
  _not: trophyGroupView_bool_exp
  _or: [trophyGroupView_bool_exp]
  description: String_comparison_exp
  groupId: uuid_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  score: Int_comparison_exp
}

# aggregate max on columns
type trophyGroupView_max_fields {
  description: String
  groupId: uuid
  id: uuid
  name: String
  score: Int
}

# order by max() on columns of table "trophyGroupView"
input trophyGroupView_max_order_by {
  description: order_by
  groupId: order_by
  id: order_by
  name: order_by
  score: order_by
}

# aggregate min on columns
type trophyGroupView_min_fields {
  description: String
  groupId: uuid
  id: uuid
  name: String
  score: Int
}

# order by min() on columns of table "trophyGroupView"
input trophyGroupView_min_order_by {
  description: order_by
  groupId: order_by
  id: order_by
  name: order_by
  score: order_by
}

# ordering options when selecting data from "trophyGroupView"
input trophyGroupView_order_by {
  description: order_by
  groupId: order_by
  id: order_by
  name: order_by
  score: order_by
}

# select columns of table "trophyGroupView"
enum trophyGroupView_select_column {
  # column name
  description

  # column name
  groupId

  # column name
  id

  # column name
  name

  # column name
  score
}

# aggregate stddev on columns
type trophyGroupView_stddev_fields {
  score: Float
}

# order by stddev() on columns of table "trophyGroupView"
input trophyGroupView_stddev_order_by {
  score: order_by
}

# aggregate stddev_pop on columns
type trophyGroupView_stddev_pop_fields {
  score: Float
}

# order by stddev_pop() on columns of table "trophyGroupView"
input trophyGroupView_stddev_pop_order_by {
  score: order_by
}

# aggregate stddev_samp on columns
type trophyGroupView_stddev_samp_fields {
  score: Float
}

# order by stddev_samp() on columns of table "trophyGroupView"
input trophyGroupView_stddev_samp_order_by {
  score: order_by
}

# aggregate sum on columns
type trophyGroupView_sum_fields {
  score: Int
}

# order by sum() on columns of table "trophyGroupView"
input trophyGroupView_sum_order_by {
  score: order_by
}

# aggregate var_pop on columns
type trophyGroupView_var_pop_fields {
  score: Float
}

# order by var_pop() on columns of table "trophyGroupView"
input trophyGroupView_var_pop_order_by {
  score: order_by
}

# aggregate var_samp on columns
type trophyGroupView_var_samp_fields {
  score: Float
}

# order by var_samp() on columns of table "trophyGroupView"
input trophyGroupView_var_samp_order_by {
  score: order_by
}

# aggregate variance on columns
type trophyGroupView_variance_fields {
  score: Float
}

# order by variance() on columns of table "trophyGroupView"
input trophyGroupView_variance_order_by {
  score: order_by
}

# columns and relationships of "user"
type user {
  college: String
  description: String
  email: String!

  # An array relationship
  events(
    # distinct select on columns
    distinct_on: [userEvent_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userEvent_order_by!]

    # filter the rows returned
    where: userEvent_bool_exp
  ): [userEvent!]!

  # An aggregated array relationship
  events_aggregate(
    # distinct select on columns
    distinct_on: [userEvent_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userEvent_order_by!]

    # filter the rows returned
    where: userEvent_bool_exp
  ): userEvent_aggregate!

  # An array relationship
  friendRequestsReceived(
    # distinct select on columns
    distinct_on: [friendRequest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [friendRequest_order_by!]

    # filter the rows returned
    where: friendRequest_bool_exp
  ): [friendRequest!]!

  # An aggregated array relationship
  friendRequestsReceived_aggregate(
    # distinct select on columns
    distinct_on: [friendRequest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [friendRequest_order_by!]

    # filter the rows returned
    where: friendRequest_bool_exp
  ): friendRequest_aggregate!

  # An array relationship
  friendRequestsSent(
    # distinct select on columns
    distinct_on: [friendRequest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [friendRequest_order_by!]

    # filter the rows returned
    where: friendRequest_bool_exp
  ): [friendRequest!]!

  # An aggregated array relationship
  friendRequestsSent_aggregate(
    # distinct select on columns
    distinct_on: [friendRequest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [friendRequest_order_by!]

    # filter the rows returned
    where: friendRequest_bool_exp
  ): friendRequest_aggregate!

  # An array relationship
  friendsRecipient(
    # distinct select on columns
    distinct_on: [friend_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [friend_order_by!]

    # filter the rows returned
    where: friend_bool_exp
  ): [friend!]!

  # An aggregated array relationship
  friendsRecipient_aggregate(
    # distinct select on columns
    distinct_on: [friend_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [friend_order_by!]

    # filter the rows returned
    where: friend_bool_exp
  ): friend_aggregate!

  # An array relationship
  friendsSender(
    # distinct select on columns
    distinct_on: [friend_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [friend_order_by!]

    # filter the rows returned
    where: friend_bool_exp
  ): [friend!]!

  # An aggregated array relationship
  friendsSender_aggregate(
    # distinct select on columns
    distinct_on: [friend_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [friend_order_by!]

    # filter the rows returned
    where: friend_bool_exp
  ): friend_aggregate!
  id: String!
  image: String!

  # An array relationship
  interests(
    # distinct select on columns
    distinct_on: [userInterest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userInterest_order_by!]

    # filter the rows returned
    where: userInterest_bool_exp
  ): [userInterest!]!

  # An aggregated array relationship
  interests_aggregate(
    # distinct select on columns
    distinct_on: [userInterest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userInterest_order_by!]

    # filter the rows returned
    where: userInterest_bool_exp
  ): userInterest_aggregate!
  isOfficial: Boolean!
  links(
    # JSON select path
    path: String
  ): jsonb!

  # An array relationship
  member(
    # distinct select on columns
    distinct_on: [userMember_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userMember_order_by!]

    # filter the rows returned
    where: userMember_bool_exp
  ): [userMember!]!

  # An aggregated array relationship
  member_aggregate(
    # distinct select on columns
    distinct_on: [userMember_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userMember_order_by!]

    # filter the rows returned
    where: userMember_bool_exp
  ): userMember_aggregate!

  # An array relationship
  messages(
    # distinct select on columns
    distinct_on: [message_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [message_order_by!]

    # filter the rows returned
    where: message_bool_exp
  ): [message!]!

  # An aggregated array relationship
  messages_aggregate(
    # distinct select on columns
    distinct_on: [message_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [message_order_by!]

    # filter the rows returned
    where: message_bool_exp
  ): message_aggregate!
  name: String!
  notificationToken: String

  # An array relationship
  notifications(
    # distinct select on columns
    distinct_on: [notification_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [notification_order_by!]

    # filter the rows returned
    where: notification_bool_exp
  ): [notification!]!

  # An aggregated array relationship
  notifications_aggregate(
    # distinct select on columns
    distinct_on: [notification_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [notification_order_by!]

    # filter the rows returned
    where: notification_bool_exp
  ): notification_aggregate!

  # An array relationship
  owner(
    # distinct select on columns
    distinct_on: [userOwner_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userOwner_order_by!]

    # filter the rows returned
    where: userOwner_bool_exp
  ): [userOwner!]!

  # An aggregated array relationship
  owner_aggregate(
    # distinct select on columns
    distinct_on: [userOwner_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userOwner_order_by!]

    # filter the rows returned
    where: userOwner_bool_exp
  ): userOwner_aggregate!

  # An array relationship
  programs(
    # distinct select on columns
    distinct_on: [userProgram_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userProgram_order_by!]

    # filter the rows returned
    where: userProgram_bool_exp
  ): [userProgram!]!

  # An aggregated array relationship
  programs_aggregate(
    # distinct select on columns
    distinct_on: [userProgram_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userProgram_order_by!]

    # filter the rows returned
    where: userProgram_bool_exp
  ): userProgram_aggregate!

  # An array relationship
  questions(
    # distinct select on columns
    distinct_on: [question_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [question_order_by!]

    # filter the rows returned
    where: question_bool_exp
  ): [question!]!

  # An aggregated array relationship
  questions_aggregate(
    # distinct select on columns
    distinct_on: [question_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [question_order_by!]

    # filter the rows returned
    where: question_bool_exp
  ): question_aggregate!

  # An array relationship
  reviews(
    # distinct select on columns
    distinct_on: [review_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [review_order_by!]

    # filter the rows returned
    where: review_bool_exp
  ): [review!]!

  # An aggregated array relationship
  reviews_aggregate(
    # distinct select on columns
    distinct_on: [review_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [review_order_by!]

    # filter the rows returned
    where: review_bool_exp
  ): review_aggregate!
  timezone: String!

  # An array relationship
  userChats(
    # distinct select on columns
    distinct_on: [userChat_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userChat_order_by!]

    # filter the rows returned
    where: userChat_bool_exp
  ): [userChat!]!

  # An aggregated array relationship
  userChats_aggregate(
    # distinct select on columns
    distinct_on: [userChat_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userChat_order_by!]

    # filter the rows returned
    where: userChat_bool_exp
  ): userChat_aggregate!
  year: Int!
}

# aggregated selection of "user"
type user_aggregate {
  aggregate: user_aggregate_fields
  nodes: [user!]!
}

# aggregate fields of "user"
type user_aggregate_fields {
  avg: user_avg_fields
  count(columns: [user_select_column!], distinct: Boolean): Int
  max: user_max_fields
  min: user_min_fields
  stddev: user_stddev_fields
  stddev_pop: user_stddev_pop_fields
  stddev_samp: user_stddev_samp_fields
  sum: user_sum_fields
  var_pop: user_var_pop_fields
  var_samp: user_var_samp_fields
  variance: user_variance_fields
}

# order by aggregate values of table "user"
input user_aggregate_order_by {
  avg: user_avg_order_by
  count: order_by
  max: user_max_order_by
  min: user_min_order_by
  stddev: user_stddev_order_by
  stddev_pop: user_stddev_pop_order_by
  stddev_samp: user_stddev_samp_order_by
  sum: user_sum_order_by
  var_pop: user_var_pop_order_by
  var_samp: user_var_samp_order_by
  variance: user_variance_order_by
}

# append existing jsonb value of filtered columns with new jsonb value
input user_append_input {
  links: jsonb
}

# input type for inserting array relation for remote table "user"
input user_arr_rel_insert_input {
  data: [user_insert_input!]!
  on_conflict: user_on_conflict
}

# aggregate avg on columns
type user_avg_fields {
  year: Float
}

# order by avg() on columns of table "user"
input user_avg_order_by {
  year: order_by
}

# Boolean expression to filter rows from the table "user". All fields are combined with a logical 'AND'.
input user_bool_exp {
  _and: [user_bool_exp]
  _not: user_bool_exp
  _or: [user_bool_exp]
  college: String_comparison_exp
  description: String_comparison_exp
  email: String_comparison_exp
  events: userEvent_bool_exp
  friendRequestsReceived: friendRequest_bool_exp
  friendRequestsSent: friendRequest_bool_exp
  friendsRecipient: friend_bool_exp
  friendsSender: friend_bool_exp
  id: String_comparison_exp
  image: String_comparison_exp
  interests: userInterest_bool_exp
  isOfficial: Boolean_comparison_exp
  links: jsonb_comparison_exp
  member: userMember_bool_exp
  messages: message_bool_exp
  name: String_comparison_exp
  notificationToken: String_comparison_exp
  notifications: notification_bool_exp
  owner: userOwner_bool_exp
  programs: userProgram_bool_exp
  questions: question_bool_exp
  reviews: review_bool_exp
  timezone: String_comparison_exp
  userChats: userChat_bool_exp
  year: Int_comparison_exp
}

# unique or primary key constraints on table "user"
enum user_constraint {
  # unique or primary key constraint
  user_pkey
}

# delete the field or element with specified path (for JSON arrays, negative integers count from the end)
input user_delete_at_path_input {
  links: [String]
}

# delete the array element with specified index (negative integers count from the
# end). throws an error if top level container is not an array
input user_delete_elem_input {
  links: Int
}

# delete key/value pair or string element. key/value pairs are matched based on their key value
input user_delete_key_input {
  links: String
}

# input type for incrementing integer column in table "user"
input user_inc_input {
  year: Int
}

# input type for inserting data into table "user"
input user_insert_input {
  college: String
  description: String
  email: String
  events: userEvent_arr_rel_insert_input
  friendRequestsReceived: friendRequest_arr_rel_insert_input
  friendRequestsSent: friendRequest_arr_rel_insert_input
  friendsRecipient: friend_arr_rel_insert_input
  friendsSender: friend_arr_rel_insert_input
  id: String
  image: String
  interests: userInterest_arr_rel_insert_input
  isOfficial: Boolean
  links: jsonb
  member: userMember_arr_rel_insert_input
  messages: message_arr_rel_insert_input
  name: String
  notificationToken: String
  notifications: notification_arr_rel_insert_input
  owner: userOwner_arr_rel_insert_input
  programs: userProgram_arr_rel_insert_input
  questions: question_arr_rel_insert_input
  reviews: review_arr_rel_insert_input
  timezone: String
  userChats: userChat_arr_rel_insert_input
  year: Int
}

# aggregate max on columns
type user_max_fields {
  college: String
  description: String
  email: String
  id: String
  image: String
  name: String
  notificationToken: String
  timezone: String
  year: Int
}

# order by max() on columns of table "user"
input user_max_order_by {
  college: order_by
  description: order_by
  email: order_by
  id: order_by
  image: order_by
  name: order_by
  notificationToken: order_by
  timezone: order_by
  year: order_by
}

# aggregate min on columns
type user_min_fields {
  college: String
  description: String
  email: String
  id: String
  image: String
  name: String
  notificationToken: String
  timezone: String
  year: Int
}

# order by min() on columns of table "user"
input user_min_order_by {
  college: order_by
  description: order_by
  email: order_by
  id: order_by
  image: order_by
  name: order_by
  notificationToken: order_by
  timezone: order_by
  year: order_by
}

# response of any mutation on the table "user"
type user_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [user!]!
}

# input type for inserting object relation for remote table "user"
input user_obj_rel_insert_input {
  data: user_insert_input!
  on_conflict: user_on_conflict
}

# on conflict condition type for table "user"
input user_on_conflict {
  constraint: user_constraint!
  update_columns: [user_update_column!]!
  where: user_bool_exp
}

# ordering options when selecting data from "user"
input user_order_by {
  college: order_by
  description: order_by
  email: order_by
  events_aggregate: userEvent_aggregate_order_by
  friendRequestsReceived_aggregate: friendRequest_aggregate_order_by
  friendRequestsSent_aggregate: friendRequest_aggregate_order_by
  friendsRecipient_aggregate: friend_aggregate_order_by
  friendsSender_aggregate: friend_aggregate_order_by
  id: order_by
  image: order_by
  interests_aggregate: userInterest_aggregate_order_by
  isOfficial: order_by
  links: order_by
  member_aggregate: userMember_aggregate_order_by
  messages_aggregate: message_aggregate_order_by
  name: order_by
  notificationToken: order_by
  notifications_aggregate: notification_aggregate_order_by
  owner_aggregate: userOwner_aggregate_order_by
  programs_aggregate: userProgram_aggregate_order_by
  questions_aggregate: question_aggregate_order_by
  reviews_aggregate: review_aggregate_order_by
  timezone: order_by
  userChats_aggregate: userChat_aggregate_order_by
  year: order_by
}

# primary key columns input for table: "user"
input user_pk_columns_input {
  id: String!
}

# prepend existing jsonb value of filtered columns with new jsonb value
input user_prepend_input {
  links: jsonb
}

# select columns of table "user"
enum user_select_column {
  # column name
  college

  # column name
  description

  # column name
  email

  # column name
  id

  # column name
  image

  # column name
  isOfficial

  # column name
  links

  # column name
  name

  # column name
  notificationToken

  # column name
  timezone

  # column name
  year
}

# input type for updating data in table "user"
input user_set_input {
  college: String
  description: String
  email: String
  id: String
  image: String
  isOfficial: Boolean
  links: jsonb
  name: String
  notificationToken: String
  timezone: String
  year: Int
}

# aggregate stddev on columns
type user_stddev_fields {
  year: Float
}

# order by stddev() on columns of table "user"
input user_stddev_order_by {
  year: order_by
}

# aggregate stddev_pop on columns
type user_stddev_pop_fields {
  year: Float
}

# order by stddev_pop() on columns of table "user"
input user_stddev_pop_order_by {
  year: order_by
}

# aggregate stddev_samp on columns
type user_stddev_samp_fields {
  year: Float
}

# order by stddev_samp() on columns of table "user"
input user_stddev_samp_order_by {
  year: order_by
}

# aggregate sum on columns
type user_sum_fields {
  year: Int
}

# order by sum() on columns of table "user"
input user_sum_order_by {
  year: order_by
}

# update columns of table "user"
enum user_update_column {
  # column name
  college

  # column name
  description

  # column name
  email

  # column name
  id

  # column name
  image

  # column name
  isOfficial

  # column name
  links

  # column name
  name

  # column name
  notificationToken

  # column name
  timezone

  # column name
  year
}

# aggregate var_pop on columns
type user_var_pop_fields {
  year: Float
}

# order by var_pop() on columns of table "user"
input user_var_pop_order_by {
  year: order_by
}

# aggregate var_samp on columns
type user_var_samp_fields {
  year: Float
}

# order by var_samp() on columns of table "user"
input user_var_samp_order_by {
  year: order_by
}

# aggregate variance on columns
type user_variance_fields {
  year: Float
}

# order by variance() on columns of table "user"
input user_variance_order_by {
  year: order_by
}

# columns and relationships of "userChat"
type userChat {
  # An object relationship
  chat: chat!
  chatId: Int!

  # An object relationship
  user: user!
  userId: String!
}

# aggregated selection of "userChat"
type userChat_aggregate {
  aggregate: userChat_aggregate_fields
  nodes: [userChat!]!
}

# aggregate fields of "userChat"
type userChat_aggregate_fields {
  avg: userChat_avg_fields
  count(columns: [userChat_select_column!], distinct: Boolean): Int
  max: userChat_max_fields
  min: userChat_min_fields
  stddev: userChat_stddev_fields
  stddev_pop: userChat_stddev_pop_fields
  stddev_samp: userChat_stddev_samp_fields
  sum: userChat_sum_fields
  var_pop: userChat_var_pop_fields
  var_samp: userChat_var_samp_fields
  variance: userChat_variance_fields
}

# order by aggregate values of table "userChat"
input userChat_aggregate_order_by {
  avg: userChat_avg_order_by
  count: order_by
  max: userChat_max_order_by
  min: userChat_min_order_by
  stddev: userChat_stddev_order_by
  stddev_pop: userChat_stddev_pop_order_by
  stddev_samp: userChat_stddev_samp_order_by
  sum: userChat_sum_order_by
  var_pop: userChat_var_pop_order_by
  var_samp: userChat_var_samp_order_by
  variance: userChat_variance_order_by
}

# input type for inserting array relation for remote table "userChat"
input userChat_arr_rel_insert_input {
  data: [userChat_insert_input!]!
  on_conflict: userChat_on_conflict
}

# aggregate avg on columns
type userChat_avg_fields {
  chatId: Float
}

# order by avg() on columns of table "userChat"
input userChat_avg_order_by {
  chatId: order_by
}

# Boolean expression to filter rows from the table "userChat". All fields are combined with a logical 'AND'.
input userChat_bool_exp {
  _and: [userChat_bool_exp]
  _not: userChat_bool_exp
  _or: [userChat_bool_exp]
  chat: chat_bool_exp
  chatId: Int_comparison_exp
  user: user_bool_exp
  userId: String_comparison_exp
}

# unique or primary key constraints on table "userChat"
enum userChat_constraint {
  # unique or primary key constraint
  userChat_pkey
}

# input type for incrementing integer column in table "userChat"
input userChat_inc_input {
  chatId: Int
}

# input type for inserting data into table "userChat"
input userChat_insert_input {
  chat: chat_obj_rel_insert_input
  chatId: Int
  user: user_obj_rel_insert_input
  userId: String
}

# aggregate max on columns
type userChat_max_fields {
  chatId: Int
  userId: String
}

# order by max() on columns of table "userChat"
input userChat_max_order_by {
  chatId: order_by
  userId: order_by
}

# aggregate min on columns
type userChat_min_fields {
  chatId: Int
  userId: String
}

# order by min() on columns of table "userChat"
input userChat_min_order_by {
  chatId: order_by
  userId: order_by
}

# response of any mutation on the table "userChat"
type userChat_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [userChat!]!
}

# input type for inserting object relation for remote table "userChat"
input userChat_obj_rel_insert_input {
  data: userChat_insert_input!
  on_conflict: userChat_on_conflict
}

# on conflict condition type for table "userChat"
input userChat_on_conflict {
  constraint: userChat_constraint!
  update_columns: [userChat_update_column!]!
  where: userChat_bool_exp
}

# ordering options when selecting data from "userChat"
input userChat_order_by {
  chat: chat_order_by
  chatId: order_by
  user: user_order_by
  userId: order_by
}

# primary key columns input for table: "userChat"
input userChat_pk_columns_input {
  chatId: Int!
  userId: String!
}

# select columns of table "userChat"
enum userChat_select_column {
  # column name
  chatId

  # column name
  userId
}

# input type for updating data in table "userChat"
input userChat_set_input {
  chatId: Int
  userId: String
}

# aggregate stddev on columns
type userChat_stddev_fields {
  chatId: Float
}

# order by stddev() on columns of table "userChat"
input userChat_stddev_order_by {
  chatId: order_by
}

# aggregate stddev_pop on columns
type userChat_stddev_pop_fields {
  chatId: Float
}

# order by stddev_pop() on columns of table "userChat"
input userChat_stddev_pop_order_by {
  chatId: order_by
}

# aggregate stddev_samp on columns
type userChat_stddev_samp_fields {
  chatId: Float
}

# order by stddev_samp() on columns of table "userChat"
input userChat_stddev_samp_order_by {
  chatId: order_by
}

# aggregate sum on columns
type userChat_sum_fields {
  chatId: Int
}

# order by sum() on columns of table "userChat"
input userChat_sum_order_by {
  chatId: order_by
}

# update columns of table "userChat"
enum userChat_update_column {
  # column name
  chatId

  # column name
  userId
}

# aggregate var_pop on columns
type userChat_var_pop_fields {
  chatId: Float
}

# order by var_pop() on columns of table "userChat"
input userChat_var_pop_order_by {
  chatId: order_by
}

# aggregate var_samp on columns
type userChat_var_samp_fields {
  chatId: Float
}

# order by var_samp() on columns of table "userChat"
input userChat_var_samp_order_by {
  chatId: order_by
}

# aggregate variance on columns
type userChat_variance_fields {
  chatId: Float
}

# order by variance() on columns of table "userChat"
input userChat_variance_order_by {
  chatId: order_by
}

# columns and relationships of "userEvent"
type userEvent {
  didAccept: Boolean!

  # An object relationship
  event: event!
  eventId: uuid!

  # An object relationship
  user: user!
  userId: String!
}

# aggregated selection of "userEvent"
type userEvent_aggregate {
  aggregate: userEvent_aggregate_fields
  nodes: [userEvent!]!
}

# aggregate fields of "userEvent"
type userEvent_aggregate_fields {
  count(columns: [userEvent_select_column!], distinct: Boolean): Int
  max: userEvent_max_fields
  min: userEvent_min_fields
}

# order by aggregate values of table "userEvent"
input userEvent_aggregate_order_by {
  count: order_by
  max: userEvent_max_order_by
  min: userEvent_min_order_by
}

# input type for inserting array relation for remote table "userEvent"
input userEvent_arr_rel_insert_input {
  data: [userEvent_insert_input!]!
  on_conflict: userEvent_on_conflict
}

# Boolean expression to filter rows from the table "userEvent". All fields are combined with a logical 'AND'.
input userEvent_bool_exp {
  _and: [userEvent_bool_exp]
  _not: userEvent_bool_exp
  _or: [userEvent_bool_exp]
  didAccept: Boolean_comparison_exp
  event: event_bool_exp
  eventId: uuid_comparison_exp
  user: user_bool_exp
  userId: String_comparison_exp
}

# unique or primary key constraints on table "userEvent"
enum userEvent_constraint {
  # unique or primary key constraint
  userEvent_pkey
}

# input type for inserting data into table "userEvent"
input userEvent_insert_input {
  didAccept: Boolean
  event: event_obj_rel_insert_input
  eventId: uuid
  user: user_obj_rel_insert_input
  userId: String
}

# aggregate max on columns
type userEvent_max_fields {
  eventId: uuid
  userId: String
}

# order by max() on columns of table "userEvent"
input userEvent_max_order_by {
  eventId: order_by
  userId: order_by
}

# aggregate min on columns
type userEvent_min_fields {
  eventId: uuid
  userId: String
}

# order by min() on columns of table "userEvent"
input userEvent_min_order_by {
  eventId: order_by
  userId: order_by
}

# response of any mutation on the table "userEvent"
type userEvent_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [userEvent!]!
}

# input type for inserting object relation for remote table "userEvent"
input userEvent_obj_rel_insert_input {
  data: userEvent_insert_input!
  on_conflict: userEvent_on_conflict
}

# on conflict condition type for table "userEvent"
input userEvent_on_conflict {
  constraint: userEvent_constraint!
  update_columns: [userEvent_update_column!]!
  where: userEvent_bool_exp
}

# ordering options when selecting data from "userEvent"
input userEvent_order_by {
  didAccept: order_by
  event: event_order_by
  eventId: order_by
  user: user_order_by
  userId: order_by
}

# primary key columns input for table: "userEvent"
input userEvent_pk_columns_input {
  eventId: uuid!
  userId: String!
}

# select columns of table "userEvent"
enum userEvent_select_column {
  # column name
  didAccept

  # column name
  eventId

  # column name
  userId
}

# input type for updating data in table "userEvent"
input userEvent_set_input {
  didAccept: Boolean
  eventId: uuid
  userId: String
}

# update columns of table "userEvent"
enum userEvent_update_column {
  # column name
  didAccept

  # column name
  eventId

  # column name
  userId
}

# columns and relationships of "userInterest"
type userInterest {
  # An object relationship
  interest: interest!
  interestId: Int!

  # An object relationship
  user: user!
  userId: String!
}

# aggregated selection of "userInterest"
type userInterest_aggregate {
  aggregate: userInterest_aggregate_fields
  nodes: [userInterest!]!
}

# aggregate fields of "userInterest"
type userInterest_aggregate_fields {
  avg: userInterest_avg_fields
  count(columns: [userInterest_select_column!], distinct: Boolean): Int
  max: userInterest_max_fields
  min: userInterest_min_fields
  stddev: userInterest_stddev_fields
  stddev_pop: userInterest_stddev_pop_fields
  stddev_samp: userInterest_stddev_samp_fields
  sum: userInterest_sum_fields
  var_pop: userInterest_var_pop_fields
  var_samp: userInterest_var_samp_fields
  variance: userInterest_variance_fields
}

# order by aggregate values of table "userInterest"
input userInterest_aggregate_order_by {
  avg: userInterest_avg_order_by
  count: order_by
  max: userInterest_max_order_by
  min: userInterest_min_order_by
  stddev: userInterest_stddev_order_by
  stddev_pop: userInterest_stddev_pop_order_by
  stddev_samp: userInterest_stddev_samp_order_by
  sum: userInterest_sum_order_by
  var_pop: userInterest_var_pop_order_by
  var_samp: userInterest_var_samp_order_by
  variance: userInterest_variance_order_by
}

# input type for inserting array relation for remote table "userInterest"
input userInterest_arr_rel_insert_input {
  data: [userInterest_insert_input!]!
  on_conflict: userInterest_on_conflict
}

# aggregate avg on columns
type userInterest_avg_fields {
  interestId: Float
}

# order by avg() on columns of table "userInterest"
input userInterest_avg_order_by {
  interestId: order_by
}

# Boolean expression to filter rows from the table "userInterest". All fields are combined with a logical 'AND'.
input userInterest_bool_exp {
  _and: [userInterest_bool_exp]
  _not: userInterest_bool_exp
  _or: [userInterest_bool_exp]
  interest: interest_bool_exp
  interestId: Int_comparison_exp
  user: user_bool_exp
  userId: String_comparison_exp
}

# unique or primary key constraints on table "userInterest"
enum userInterest_constraint {
  # unique or primary key constraint
  userInterest_pkey
}

# input type for incrementing integer column in table "userInterest"
input userInterest_inc_input {
  interestId: Int
}

# input type for inserting data into table "userInterest"
input userInterest_insert_input {
  interest: interest_obj_rel_insert_input
  interestId: Int
  user: user_obj_rel_insert_input
  userId: String
}

# aggregate max on columns
type userInterest_max_fields {
  interestId: Int
  userId: String
}

# order by max() on columns of table "userInterest"
input userInterest_max_order_by {
  interestId: order_by
  userId: order_by
}

# aggregate min on columns
type userInterest_min_fields {
  interestId: Int
  userId: String
}

# order by min() on columns of table "userInterest"
input userInterest_min_order_by {
  interestId: order_by
  userId: order_by
}

# response of any mutation on the table "userInterest"
type userInterest_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [userInterest!]!
}

# input type for inserting object relation for remote table "userInterest"
input userInterest_obj_rel_insert_input {
  data: userInterest_insert_input!
  on_conflict: userInterest_on_conflict
}

# on conflict condition type for table "userInterest"
input userInterest_on_conflict {
  constraint: userInterest_constraint!
  update_columns: [userInterest_update_column!]!
  where: userInterest_bool_exp
}

# ordering options when selecting data from "userInterest"
input userInterest_order_by {
  interest: interest_order_by
  interestId: order_by
  user: user_order_by
  userId: order_by
}

# primary key columns input for table: "userInterest"
input userInterest_pk_columns_input {
  interestId: Int!
  userId: String!
}

# select columns of table "userInterest"
enum userInterest_select_column {
  # column name
  interestId

  # column name
  userId
}

# input type for updating data in table "userInterest"
input userInterest_set_input {
  interestId: Int
  userId: String
}

# aggregate stddev on columns
type userInterest_stddev_fields {
  interestId: Float
}

# order by stddev() on columns of table "userInterest"
input userInterest_stddev_order_by {
  interestId: order_by
}

# aggregate stddev_pop on columns
type userInterest_stddev_pop_fields {
  interestId: Float
}

# order by stddev_pop() on columns of table "userInterest"
input userInterest_stddev_pop_order_by {
  interestId: order_by
}

# aggregate stddev_samp on columns
type userInterest_stddev_samp_fields {
  interestId: Float
}

# order by stddev_samp() on columns of table "userInterest"
input userInterest_stddev_samp_order_by {
  interestId: order_by
}

# aggregate sum on columns
type userInterest_sum_fields {
  interestId: Int
}

# order by sum() on columns of table "userInterest"
input userInterest_sum_order_by {
  interestId: order_by
}

# update columns of table "userInterest"
enum userInterest_update_column {
  # column name
  interestId

  # column name
  userId
}

# aggregate var_pop on columns
type userInterest_var_pop_fields {
  interestId: Float
}

# order by var_pop() on columns of table "userInterest"
input userInterest_var_pop_order_by {
  interestId: order_by
}

# aggregate var_samp on columns
type userInterest_var_samp_fields {
  interestId: Float
}

# order by var_samp() on columns of table "userInterest"
input userInterest_var_samp_order_by {
  interestId: order_by
}

# aggregate variance on columns
type userInterest_variance_fields {
  interestId: Float
}

# order by variance() on columns of table "userInterest"
input userInterest_variance_order_by {
  interestId: order_by
}

# columns and relationships of "userMember"
type userMember {
  # An object relationship
  group: group!
  groupId: uuid!

  # An object relationship
  user: user!
  userId: String!
}

# aggregated selection of "userMember"
type userMember_aggregate {
  aggregate: userMember_aggregate_fields
  nodes: [userMember!]!
}

# aggregate fields of "userMember"
type userMember_aggregate_fields {
  count(columns: [userMember_select_column!], distinct: Boolean): Int
  max: userMember_max_fields
  min: userMember_min_fields
}

# order by aggregate values of table "userMember"
input userMember_aggregate_order_by {
  count: order_by
  max: userMember_max_order_by
  min: userMember_min_order_by
}

# input type for inserting array relation for remote table "userMember"
input userMember_arr_rel_insert_input {
  data: [userMember_insert_input!]!
  on_conflict: userMember_on_conflict
}

# Boolean expression to filter rows from the table "userMember". All fields are combined with a logical 'AND'.
input userMember_bool_exp {
  _and: [userMember_bool_exp]
  _not: userMember_bool_exp
  _or: [userMember_bool_exp]
  group: group_bool_exp
  groupId: uuid_comparison_exp
  user: user_bool_exp
  userId: String_comparison_exp
}

# unique or primary key constraints on table "userMember"
enum userMember_constraint {
  # unique or primary key constraint
  userMember_pkey
}

# input type for inserting data into table "userMember"
input userMember_insert_input {
  group: group_obj_rel_insert_input
  groupId: uuid
  user: user_obj_rel_insert_input
  userId: String
}

# aggregate max on columns
type userMember_max_fields {
  groupId: uuid
  userId: String
}

# order by max() on columns of table "userMember"
input userMember_max_order_by {
  groupId: order_by
  userId: order_by
}

# aggregate min on columns
type userMember_min_fields {
  groupId: uuid
  userId: String
}

# order by min() on columns of table "userMember"
input userMember_min_order_by {
  groupId: order_by
  userId: order_by
}

# response of any mutation on the table "userMember"
type userMember_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [userMember!]!
}

# input type for inserting object relation for remote table "userMember"
input userMember_obj_rel_insert_input {
  data: userMember_insert_input!
  on_conflict: userMember_on_conflict
}

# on conflict condition type for table "userMember"
input userMember_on_conflict {
  constraint: userMember_constraint!
  update_columns: [userMember_update_column!]!
  where: userMember_bool_exp
}

# ordering options when selecting data from "userMember"
input userMember_order_by {
  group: group_order_by
  groupId: order_by
  user: user_order_by
  userId: order_by
}

# primary key columns input for table: "userMember"
input userMember_pk_columns_input {
  groupId: uuid!
  userId: String!
}

# select columns of table "userMember"
enum userMember_select_column {
  # column name
  groupId

  # column name
  userId
}

# input type for updating data in table "userMember"
input userMember_set_input {
  groupId: uuid
  userId: String
}

# update columns of table "userMember"
enum userMember_update_column {
  # column name
  groupId

  # column name
  userId
}

# columns and relationships of "userOwner"
type userOwner {
  # An object relationship
  group: group!
  groupId: uuid!

  # An object relationship
  user: user!
  userId: String!
}

# aggregated selection of "userOwner"
type userOwner_aggregate {
  aggregate: userOwner_aggregate_fields
  nodes: [userOwner!]!
}

# aggregate fields of "userOwner"
type userOwner_aggregate_fields {
  count(columns: [userOwner_select_column!], distinct: Boolean): Int
  max: userOwner_max_fields
  min: userOwner_min_fields
}

# order by aggregate values of table "userOwner"
input userOwner_aggregate_order_by {
  count: order_by
  max: userOwner_max_order_by
  min: userOwner_min_order_by
}

# input type for inserting array relation for remote table "userOwner"
input userOwner_arr_rel_insert_input {
  data: [userOwner_insert_input!]!
  on_conflict: userOwner_on_conflict
}

# Boolean expression to filter rows from the table "userOwner". All fields are combined with a logical 'AND'.
input userOwner_bool_exp {
  _and: [userOwner_bool_exp]
  _not: userOwner_bool_exp
  _or: [userOwner_bool_exp]
  group: group_bool_exp
  groupId: uuid_comparison_exp
  user: user_bool_exp
  userId: String_comparison_exp
}

# unique or primary key constraints on table "userOwner"
enum userOwner_constraint {
  # unique or primary key constraint
  userOwner_pkey
}

# input type for inserting data into table "userOwner"
input userOwner_insert_input {
  group: group_obj_rel_insert_input
  groupId: uuid
  user: user_obj_rel_insert_input
  userId: String
}

# aggregate max on columns
type userOwner_max_fields {
  groupId: uuid
  userId: String
}

# order by max() on columns of table "userOwner"
input userOwner_max_order_by {
  groupId: order_by
  userId: order_by
}

# aggregate min on columns
type userOwner_min_fields {
  groupId: uuid
  userId: String
}

# order by min() on columns of table "userOwner"
input userOwner_min_order_by {
  groupId: order_by
  userId: order_by
}

# response of any mutation on the table "userOwner"
type userOwner_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [userOwner!]!
}

# input type for inserting object relation for remote table "userOwner"
input userOwner_obj_rel_insert_input {
  data: userOwner_insert_input!
  on_conflict: userOwner_on_conflict
}

# on conflict condition type for table "userOwner"
input userOwner_on_conflict {
  constraint: userOwner_constraint!
  update_columns: [userOwner_update_column!]!
  where: userOwner_bool_exp
}

# ordering options when selecting data from "userOwner"
input userOwner_order_by {
  group: group_order_by
  groupId: order_by
  user: user_order_by
  userId: order_by
}

# primary key columns input for table: "userOwner"
input userOwner_pk_columns_input {
  groupId: uuid!
  userId: String!
}

# select columns of table "userOwner"
enum userOwner_select_column {
  # column name
  groupId

  # column name
  userId
}

# input type for updating data in table "userOwner"
input userOwner_set_input {
  groupId: uuid
  userId: String
}

# update columns of table "userOwner"
enum userOwner_update_column {
  # column name
  groupId

  # column name
  userId
}

# columns and relationships of "userProgram"
type userProgram {
  # An object relationship
  program: program!
  programId: Int!

  # An object relationship
  user: user!
  userId: String!
}

# aggregated selection of "userProgram"
type userProgram_aggregate {
  aggregate: userProgram_aggregate_fields
  nodes: [userProgram!]!
}

# aggregate fields of "userProgram"
type userProgram_aggregate_fields {
  avg: userProgram_avg_fields
  count(columns: [userProgram_select_column!], distinct: Boolean): Int
  max: userProgram_max_fields
  min: userProgram_min_fields
  stddev: userProgram_stddev_fields
  stddev_pop: userProgram_stddev_pop_fields
  stddev_samp: userProgram_stddev_samp_fields
  sum: userProgram_sum_fields
  var_pop: userProgram_var_pop_fields
  var_samp: userProgram_var_samp_fields
  variance: userProgram_variance_fields
}

# order by aggregate values of table "userProgram"
input userProgram_aggregate_order_by {
  avg: userProgram_avg_order_by
  count: order_by
  max: userProgram_max_order_by
  min: userProgram_min_order_by
  stddev: userProgram_stddev_order_by
  stddev_pop: userProgram_stddev_pop_order_by
  stddev_samp: userProgram_stddev_samp_order_by
  sum: userProgram_sum_order_by
  var_pop: userProgram_var_pop_order_by
  var_samp: userProgram_var_samp_order_by
  variance: userProgram_variance_order_by
}

# input type for inserting array relation for remote table "userProgram"
input userProgram_arr_rel_insert_input {
  data: [userProgram_insert_input!]!
  on_conflict: userProgram_on_conflict
}

# aggregate avg on columns
type userProgram_avg_fields {
  programId: Float
}

# order by avg() on columns of table "userProgram"
input userProgram_avg_order_by {
  programId: order_by
}

# Boolean expression to filter rows from the table "userProgram". All fields are combined with a logical 'AND'.
input userProgram_bool_exp {
  _and: [userProgram_bool_exp]
  _not: userProgram_bool_exp
  _or: [userProgram_bool_exp]
  program: program_bool_exp
  programId: Int_comparison_exp
  user: user_bool_exp
  userId: String_comparison_exp
}

# unique or primary key constraints on table "userProgram"
enum userProgram_constraint {
  # unique or primary key constraint
  userProgram_pkey
}

# input type for incrementing integer column in table "userProgram"
input userProgram_inc_input {
  programId: Int
}

# input type for inserting data into table "userProgram"
input userProgram_insert_input {
  program: program_obj_rel_insert_input
  programId: Int
  user: user_obj_rel_insert_input
  userId: String
}

# aggregate max on columns
type userProgram_max_fields {
  programId: Int
  userId: String
}

# order by max() on columns of table "userProgram"
input userProgram_max_order_by {
  programId: order_by
  userId: order_by
}

# aggregate min on columns
type userProgram_min_fields {
  programId: Int
  userId: String
}

# order by min() on columns of table "userProgram"
input userProgram_min_order_by {
  programId: order_by
  userId: order_by
}

# response of any mutation on the table "userProgram"
type userProgram_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [userProgram!]!
}

# input type for inserting object relation for remote table "userProgram"
input userProgram_obj_rel_insert_input {
  data: userProgram_insert_input!
  on_conflict: userProgram_on_conflict
}

# on conflict condition type for table "userProgram"
input userProgram_on_conflict {
  constraint: userProgram_constraint!
  update_columns: [userProgram_update_column!]!
  where: userProgram_bool_exp
}

# ordering options when selecting data from "userProgram"
input userProgram_order_by {
  program: program_order_by
  programId: order_by
  user: user_order_by
  userId: order_by
}

# primary key columns input for table: "userProgram"
input userProgram_pk_columns_input {
  programId: Int!
  userId: String!
}

# select columns of table "userProgram"
enum userProgram_select_column {
  # column name
  programId

  # column name
  userId
}

# input type for updating data in table "userProgram"
input userProgram_set_input {
  programId: Int
  userId: String
}

# aggregate stddev on columns
type userProgram_stddev_fields {
  programId: Float
}

# order by stddev() on columns of table "userProgram"
input userProgram_stddev_order_by {
  programId: order_by
}

# aggregate stddev_pop on columns
type userProgram_stddev_pop_fields {
  programId: Float
}

# order by stddev_pop() on columns of table "userProgram"
input userProgram_stddev_pop_order_by {
  programId: order_by
}

# aggregate stddev_samp on columns
type userProgram_stddev_samp_fields {
  programId: Float
}

# order by stddev_samp() on columns of table "userProgram"
input userProgram_stddev_samp_order_by {
  programId: order_by
}

# aggregate sum on columns
type userProgram_sum_fields {
  programId: Int
}

# order by sum() on columns of table "userProgram"
input userProgram_sum_order_by {
  programId: order_by
}

# update columns of table "userProgram"
enum userProgram_update_column {
  # column name
  programId

  # column name
  userId
}

# aggregate var_pop on columns
type userProgram_var_pop_fields {
  programId: Float
}

# order by var_pop() on columns of table "userProgram"
input userProgram_var_pop_order_by {
  programId: order_by
}

# aggregate var_samp on columns
type userProgram_var_samp_fields {
  programId: Float
}

# order by var_samp() on columns of table "userProgram"
input userProgram_var_samp_order_by {
  programId: order_by
}

# aggregate variance on columns
type userProgram_variance_fields {
  programId: Float
}

# order by variance() on columns of table "userProgram"
input userProgram_variance_order_by {
  programId: order_by
}

scalar uuid

# expression to compare columns of type uuid. All fields are combined with logical 'AND'.
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

