schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

# columns and relationships of "block"
type block {
  blockedId: String!
  blockerId: String!

  # An object relationship
  user: user!

  # An object relationship
  userByBlockedid: user!
}

# aggregated selection of "block"
type block_aggregate {
  aggregate: block_aggregate_fields
  nodes: [block!]!
}

# aggregate fields of "block"
type block_aggregate_fields {
  count(columns: [block_select_column!], distinct: Boolean): Int
  max: block_max_fields
  min: block_min_fields
}

# order by aggregate values of table "block"
input block_aggregate_order_by {
  count: order_by
  max: block_max_order_by
  min: block_min_order_by
}

# input type for inserting array relation for remote table "block"
input block_arr_rel_insert_input {
  data: [block_insert_input!]!
  on_conflict: block_on_conflict
}

# Boolean expression to filter rows from the table "block". All fields are combined with a logical 'AND'.
input block_bool_exp {
  _and: [block_bool_exp]
  _not: block_bool_exp
  _or: [block_bool_exp]
  blockedId: String_comparison_exp
  blockerId: String_comparison_exp
  user: user_bool_exp
  userByBlockedid: user_bool_exp
}

# unique or primary key constraints on table "block"
enum block_constraint {
  # unique or primary key constraint
  block_pkey
}

# input type for inserting data into table "block"
input block_insert_input {
  blockedId: String
  blockerId: String
  user: user_obj_rel_insert_input
  userByBlockedid: user_obj_rel_insert_input
}

# aggregate max on columns
type block_max_fields {
  blockedId: String
  blockerId: String
}

# order by max() on columns of table "block"
input block_max_order_by {
  blockedId: order_by
  blockerId: order_by
}

# aggregate min on columns
type block_min_fields {
  blockedId: String
  blockerId: String
}

# order by min() on columns of table "block"
input block_min_order_by {
  blockedId: order_by
  blockerId: order_by
}

# response of any mutation on the table "block"
type block_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [block!]!
}

# input type for inserting object relation for remote table "block"
input block_obj_rel_insert_input {
  data: block_insert_input!
  on_conflict: block_on_conflict
}

# on conflict condition type for table "block"
input block_on_conflict {
  constraint: block_constraint!
  update_columns: [block_update_column!]!
  where: block_bool_exp
}

# ordering options when selecting data from "block"
input block_order_by {
  blockedId: order_by
  blockerId: order_by
  user: user_order_by
  userByBlockedid: user_order_by
}

# primary key columns input for table: "block"
input block_pk_columns_input {
  blockedId: String!
  blockerId: String!
}

# select columns of table "block"
enum block_select_column {
  # column name
  blockedId

  # column name
  blockerId
}

# input type for updating data in table "block"
input block_set_input {
  blockedId: String
  blockerId: String
}

# update columns of table "block"
enum block_update_column {
  # column name
  blockedId

  # column name
  blockerId
}

# expression to compare columns of type Boolean. All fields are combined with logical 'AND'.
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

# columns and relationships of "bug"
type bug {
  description: String!
  reporter: String!
  time: timestamptz!
}

# aggregated selection of "bug"
type bug_aggregate {
  aggregate: bug_aggregate_fields
  nodes: [bug!]!
}

# aggregate fields of "bug"
type bug_aggregate_fields {
  count(columns: [bug_select_column!], distinct: Boolean): Int
  max: bug_max_fields
  min: bug_min_fields
}

# order by aggregate values of table "bug"
input bug_aggregate_order_by {
  count: order_by
  max: bug_max_order_by
  min: bug_min_order_by
}

# input type for inserting array relation for remote table "bug"
input bug_arr_rel_insert_input {
  data: [bug_insert_input!]!
  on_conflict: bug_on_conflict
}

# Boolean expression to filter rows from the table "bug". All fields are combined with a logical 'AND'.
input bug_bool_exp {
  _and: [bug_bool_exp]
  _not: bug_bool_exp
  _or: [bug_bool_exp]
  description: String_comparison_exp
  reporter: String_comparison_exp
  time: timestamptz_comparison_exp
}

# unique or primary key constraints on table "bug"
enum bug_constraint {
  # unique or primary key constraint
  bug_pkey
}

# input type for inserting data into table "bug"
input bug_insert_input {
  description: String
  reporter: String
  time: timestamptz
}

# aggregate max on columns
type bug_max_fields {
  description: String
  reporter: String
  time: timestamptz
}

# order by max() on columns of table "bug"
input bug_max_order_by {
  description: order_by
  reporter: order_by
  time: order_by
}

# aggregate min on columns
type bug_min_fields {
  description: String
  reporter: String
  time: timestamptz
}

# order by min() on columns of table "bug"
input bug_min_order_by {
  description: order_by
  reporter: order_by
  time: order_by
}

# response of any mutation on the table "bug"
type bug_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [bug!]!
}

# input type for inserting object relation for remote table "bug"
input bug_obj_rel_insert_input {
  data: bug_insert_input!
  on_conflict: bug_on_conflict
}

# on conflict condition type for table "bug"
input bug_on_conflict {
  constraint: bug_constraint!
  update_columns: [bug_update_column!]!
  where: bug_bool_exp
}

# ordering options when selecting data from "bug"
input bug_order_by {
  description: order_by
  reporter: order_by
  time: order_by
}

# primary key columns input for table: "bug"
input bug_pk_columns_input {
  reporter: String!
}

# select columns of table "bug"
enum bug_select_column {
  # column name
  description

  # column name
  reporter

  # column name
  time
}

# input type for updating data in table "bug"
input bug_set_input {
  description: String
  reporter: String
  time: timestamptz
}

# update columns of table "bug"
enum bug_update_column {
  # column name
  description

  # column name
  reporter

  # column name
  time
}

# columns and relationships of "chat"
type chat {
  id: Int!
  image: String

  # An array relationship
  messages(
    # distinct select on columns
    distinct_on: [message_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [message_order_by!]

    # filter the rows returned
    where: message_bool_exp
  ): [message!]!

  # An aggregated array relationship
  messages_aggregate(
    # distinct select on columns
    distinct_on: [message_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [message_order_by!]

    # filter the rows returned
    where: message_bool_exp
  ): message_aggregate!
  name: String

  # An array relationship
  participants(
    # distinct select on columns
    distinct_on: [chatUserView_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [chatUserView_order_by!]

    # filter the rows returned
    where: chatUserView_bool_exp
  ): [chatUserView!]!

  # An aggregated array relationship
  participants_aggregate(
    # distinct select on columns
    distinct_on: [chatUserView_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [chatUserView_order_by!]

    # filter the rows returned
    where: chatUserView_bool_exp
  ): chatUserView_aggregate!
  unsubscribable: Boolean!

  # An array relationship
  users(
    # distinct select on columns
    distinct_on: [userChat_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userChat_order_by!]

    # filter the rows returned
    where: userChat_bool_exp
  ): [userChat!]!

  # An aggregated array relationship
  users_aggregate(
    # distinct select on columns
    distinct_on: [userChat_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userChat_order_by!]

    # filter the rows returned
    where: userChat_bool_exp
  ): userChat_aggregate!
}

# aggregated selection of "chat"
type chat_aggregate {
  aggregate: chat_aggregate_fields
  nodes: [chat!]!
}

# aggregate fields of "chat"
type chat_aggregate_fields {
  avg: chat_avg_fields
  count(columns: [chat_select_column!], distinct: Boolean): Int
  max: chat_max_fields
  min: chat_min_fields
  stddev: chat_stddev_fields
  stddev_pop: chat_stddev_pop_fields
  stddev_samp: chat_stddev_samp_fields
  sum: chat_sum_fields
  var_pop: chat_var_pop_fields
  var_samp: chat_var_samp_fields
  variance: chat_variance_fields
}

# order by aggregate values of table "chat"
input chat_aggregate_order_by {
  avg: chat_avg_order_by
  count: order_by
  max: chat_max_order_by
  min: chat_min_order_by
  stddev: chat_stddev_order_by
  stddev_pop: chat_stddev_pop_order_by
  stddev_samp: chat_stddev_samp_order_by
  sum: chat_sum_order_by
  var_pop: chat_var_pop_order_by
  var_samp: chat_var_samp_order_by
  variance: chat_variance_order_by
}

# input type for inserting array relation for remote table "chat"
input chat_arr_rel_insert_input {
  data: [chat_insert_input!]!
  on_conflict: chat_on_conflict
}

# aggregate avg on columns
type chat_avg_fields {
  id: Float
}

# order by avg() on columns of table "chat"
input chat_avg_order_by {
  id: order_by
}

# Boolean expression to filter rows from the table "chat". All fields are combined with a logical 'AND'.
input chat_bool_exp {
  _and: [chat_bool_exp]
  _not: chat_bool_exp
  _or: [chat_bool_exp]
  id: Int_comparison_exp
  image: String_comparison_exp
  messages: message_bool_exp
  name: String_comparison_exp
  participants: chatUserView_bool_exp
  unsubscribable: Boolean_comparison_exp
  users: userChat_bool_exp
}

# unique or primary key constraints on table "chat"
enum chat_constraint {
  # unique or primary key constraint
  chat_pkey
}

# input type for incrementing integer column in table "chat"
input chat_inc_input {
  id: Int
}

# input type for inserting data into table "chat"
input chat_insert_input {
  id: Int
  image: String
  messages: message_arr_rel_insert_input
  name: String
  unsubscribable: Boolean
  users: userChat_arr_rel_insert_input
}

# aggregate max on columns
type chat_max_fields {
  id: Int
  image: String
  name: String
}

# order by max() on columns of table "chat"
input chat_max_order_by {
  id: order_by
  image: order_by
  name: order_by
}

# aggregate min on columns
type chat_min_fields {
  id: Int
  image: String
  name: String
}

# order by min() on columns of table "chat"
input chat_min_order_by {
  id: order_by
  image: order_by
  name: order_by
}

# response of any mutation on the table "chat"
type chat_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [chat!]!
}

# input type for inserting object relation for remote table "chat"
input chat_obj_rel_insert_input {
  data: chat_insert_input!
  on_conflict: chat_on_conflict
}

# on conflict condition type for table "chat"
input chat_on_conflict {
  constraint: chat_constraint!
  update_columns: [chat_update_column!]!
  where: chat_bool_exp
}

# ordering options when selecting data from "chat"
input chat_order_by {
  id: order_by
  image: order_by
  messages_aggregate: message_aggregate_order_by
  name: order_by
  participants_aggregate: chatUserView_aggregate_order_by
  unsubscribable: order_by
  users_aggregate: userChat_aggregate_order_by
}

# primary key columns input for table: "chat"
input chat_pk_columns_input {
  id: Int!
}

# select columns of table "chat"
enum chat_select_column {
  # column name
  id

  # column name
  image

  # column name
  name

  # column name
  unsubscribable
}

# input type for updating data in table "chat"
input chat_set_input {
  id: Int
  image: String
  name: String
  unsubscribable: Boolean
}

# aggregate stddev on columns
type chat_stddev_fields {
  id: Float
}

# order by stddev() on columns of table "chat"
input chat_stddev_order_by {
  id: order_by
}

# aggregate stddev_pop on columns
type chat_stddev_pop_fields {
  id: Float
}

# order by stddev_pop() on columns of table "chat"
input chat_stddev_pop_order_by {
  id: order_by
}

# aggregate stddev_samp on columns
type chat_stddev_samp_fields {
  id: Float
}

# order by stddev_samp() on columns of table "chat"
input chat_stddev_samp_order_by {
  id: order_by
}

# aggregate sum on columns
type chat_sum_fields {
  id: Int
}

# order by sum() on columns of table "chat"
input chat_sum_order_by {
  id: order_by
}

# update columns of table "chat"
enum chat_update_column {
  # column name
  id

  # column name
  image

  # column name
  name

  # column name
  unsubscribable
}

# aggregate var_pop on columns
type chat_var_pop_fields {
  id: Float
}

# order by var_pop() on columns of table "chat"
input chat_var_pop_order_by {
  id: order_by
}

# aggregate var_samp on columns
type chat_var_samp_fields {
  id: Float
}

# order by var_samp() on columns of table "chat"
input chat_var_samp_order_by {
  id: order_by
}

# aggregate variance on columns
type chat_variance_fields {
  id: Float
}

# order by variance() on columns of table "chat"
input chat_variance_order_by {
  id: order_by
}

# columns and relationships of "chatUserView"
type chatUserView {
  chatId: Int
  college: String
  description: String
  email: String
  id: String
  image: String
  isOfficial: Boolean
  links(
    # JSON select path
    path: String
  ): jsonb
  name: String
  notificationToken: String
  year: Int
}

# aggregated selection of "chatUserView"
type chatUserView_aggregate {
  aggregate: chatUserView_aggregate_fields
  nodes: [chatUserView!]!
}

# aggregate fields of "chatUserView"
type chatUserView_aggregate_fields {
  avg: chatUserView_avg_fields
  count(columns: [chatUserView_select_column!], distinct: Boolean): Int
  max: chatUserView_max_fields
  min: chatUserView_min_fields
  stddev: chatUserView_stddev_fields
  stddev_pop: chatUserView_stddev_pop_fields
  stddev_samp: chatUserView_stddev_samp_fields
  sum: chatUserView_sum_fields
  var_pop: chatUserView_var_pop_fields
  var_samp: chatUserView_var_samp_fields
  variance: chatUserView_variance_fields
}

# order by aggregate values of table "chatUserView"
input chatUserView_aggregate_order_by {
  avg: chatUserView_avg_order_by
  count: order_by
  max: chatUserView_max_order_by
  min: chatUserView_min_order_by
  stddev: chatUserView_stddev_order_by
  stddev_pop: chatUserView_stddev_pop_order_by
  stddev_samp: chatUserView_stddev_samp_order_by
  sum: chatUserView_sum_order_by
  var_pop: chatUserView_var_pop_order_by
  var_samp: chatUserView_var_samp_order_by
  variance: chatUserView_variance_order_by
}

# append existing jsonb value of filtered columns with new jsonb value
input chatUserView_append_input {
  links: jsonb
}

# aggregate avg on columns
type chatUserView_avg_fields {
  chatId: Float
  year: Float
}

# order by avg() on columns of table "chatUserView"
input chatUserView_avg_order_by {
  chatId: order_by
  year: order_by
}

# Boolean expression to filter rows from the table "chatUserView". All fields are combined with a logical 'AND'.
input chatUserView_bool_exp {
  _and: [chatUserView_bool_exp]
  _not: chatUserView_bool_exp
  _or: [chatUserView_bool_exp]
  chatId: Int_comparison_exp
  college: String_comparison_exp
  description: String_comparison_exp
  email: String_comparison_exp
  id: String_comparison_exp
  image: String_comparison_exp
  isOfficial: Boolean_comparison_exp
  links: jsonb_comparison_exp
  name: String_comparison_exp
  notificationToken: String_comparison_exp
  year: Int_comparison_exp
}

# delete the field or element with specified path (for JSON arrays, negative integers count from the end)
input chatUserView_delete_at_path_input {
  links: [String]
}

# delete the array element with specified index (negative integers count from the
# end). throws an error if top level container is not an array
input chatUserView_delete_elem_input {
  links: Int
}

# delete key/value pair or string element. key/value pairs are matched based on their key value
input chatUserView_delete_key_input {
  links: String
}

# aggregate max on columns
type chatUserView_max_fields {
  chatId: Int
  college: String
  description: String
  email: String
  id: String
  image: String
  name: String
  notificationToken: String
  year: Int
}

# order by max() on columns of table "chatUserView"
input chatUserView_max_order_by {
  chatId: order_by
  college: order_by
  description: order_by
  email: order_by
  id: order_by
  image: order_by
  name: order_by
  notificationToken: order_by
  year: order_by
}

# aggregate min on columns
type chatUserView_min_fields {
  chatId: Int
  college: String
  description: String
  email: String
  id: String
  image: String
  name: String
  notificationToken: String
  year: Int
}

# order by min() on columns of table "chatUserView"
input chatUserView_min_order_by {
  chatId: order_by
  college: order_by
  description: order_by
  email: order_by
  id: order_by
  image: order_by
  name: order_by
  notificationToken: order_by
  year: order_by
}

# ordering options when selecting data from "chatUserView"
input chatUserView_order_by {
  chatId: order_by
  college: order_by
  description: order_by
  email: order_by
  id: order_by
  image: order_by
  isOfficial: order_by
  links: order_by
  name: order_by
  notificationToken: order_by
  year: order_by
}

# prepend existing jsonb value of filtered columns with new jsonb value
input chatUserView_prepend_input {
  links: jsonb
}

# select columns of table "chatUserView"
enum chatUserView_select_column {
  # column name
  chatId

  # column name
  college

  # column name
  description

  # column name
  email

  # column name
  id

  # column name
  image

  # column name
  isOfficial

  # column name
  links

  # column name
  name

  # column name
  notificationToken

  # column name
  year
}

# aggregate stddev on columns
type chatUserView_stddev_fields {
  chatId: Float
  year: Float
}

# order by stddev() on columns of table "chatUserView"
input chatUserView_stddev_order_by {
  chatId: order_by
  year: order_by
}

# aggregate stddev_pop on columns
type chatUserView_stddev_pop_fields {
  chatId: Float
  year: Float
}

# order by stddev_pop() on columns of table "chatUserView"
input chatUserView_stddev_pop_order_by {
  chatId: order_by
  year: order_by
}

# aggregate stddev_samp on columns
type chatUserView_stddev_samp_fields {
  chatId: Float
  year: Float
}

# order by stddev_samp() on columns of table "chatUserView"
input chatUserView_stddev_samp_order_by {
  chatId: order_by
  year: order_by
}

# aggregate sum on columns
type chatUserView_sum_fields {
  chatId: Int
  year: Int
}

# order by sum() on columns of table "chatUserView"
input chatUserView_sum_order_by {
  chatId: order_by
  year: order_by
}

# aggregate var_pop on columns
type chatUserView_var_pop_fields {
  chatId: Float
  year: Float
}

# order by var_pop() on columns of table "chatUserView"
input chatUserView_var_pop_order_by {
  chatId: order_by
  year: order_by
}

# aggregate var_samp on columns
type chatUserView_var_samp_fields {
  chatId: Float
  year: Float
}

# order by var_samp() on columns of table "chatUserView"
input chatUserView_var_samp_order_by {
  chatId: order_by
  year: order_by
}

# aggregate variance on columns
type chatUserView_variance_fields {
  chatId: Float
  year: Float
}

# order by variance() on columns of table "chatUserView"
input chatUserView_variance_order_by {
  chatId: order_by
  year: order_by
}

# Made by Zach, might be bad
#
#
# columns and relationships of "comment"
#
type comment {
  authorId: String!
  id: Int!

  # An object relationship
  post: post!
  postId: Int!
  text: String!
  time: timestamptz!

  # An object relationship
  user: user!
}

# aggregated selection of "comment"
type comment_aggregate {
  aggregate: comment_aggregate_fields
  nodes: [comment!]!
}

# aggregate fields of "comment"
type comment_aggregate_fields {
  avg: comment_avg_fields
  count(columns: [comment_select_column!], distinct: Boolean): Int
  max: comment_max_fields
  min: comment_min_fields
  stddev: comment_stddev_fields
  stddev_pop: comment_stddev_pop_fields
  stddev_samp: comment_stddev_samp_fields
  sum: comment_sum_fields
  var_pop: comment_var_pop_fields
  var_samp: comment_var_samp_fields
  variance: comment_variance_fields
}

# order by aggregate values of table "comment"
input comment_aggregate_order_by {
  avg: comment_avg_order_by
  count: order_by
  max: comment_max_order_by
  min: comment_min_order_by
  stddev: comment_stddev_order_by
  stddev_pop: comment_stddev_pop_order_by
  stddev_samp: comment_stddev_samp_order_by
  sum: comment_sum_order_by
  var_pop: comment_var_pop_order_by
  var_samp: comment_var_samp_order_by
  variance: comment_variance_order_by
}

# input type for inserting array relation for remote table "comment"
input comment_arr_rel_insert_input {
  data: [comment_insert_input!]!
  on_conflict: comment_on_conflict
}

# aggregate avg on columns
type comment_avg_fields {
  id: Float
  postId: Float
}

# order by avg() on columns of table "comment"
input comment_avg_order_by {
  id: order_by
  postId: order_by
}

# Boolean expression to filter rows from the table "comment". All fields are combined with a logical 'AND'.
input comment_bool_exp {
  _and: [comment_bool_exp]
  _not: comment_bool_exp
  _or: [comment_bool_exp]
  authorId: String_comparison_exp
  id: Int_comparison_exp
  post: post_bool_exp
  postId: Int_comparison_exp
  text: String_comparison_exp
  time: timestamptz_comparison_exp
  user: user_bool_exp
}

# unique or primary key constraints on table "comment"
enum comment_constraint {
  # unique or primary key constraint
  comment_id_key

  # unique or primary key constraint
  comment_pkey
}

# input type for incrementing integer column in table "comment"
input comment_inc_input {
  id: Int
  postId: Int
}

# input type for inserting data into table "comment"
input comment_insert_input {
  authorId: String
  id: Int
  post: post_obj_rel_insert_input
  postId: Int
  text: String
  time: timestamptz
  user: user_obj_rel_insert_input
}

# aggregate max on columns
type comment_max_fields {
  authorId: String
  id: Int
  postId: Int
  text: String
  time: timestamptz
}

# order by max() on columns of table "comment"
input comment_max_order_by {
  authorId: order_by
  id: order_by
  postId: order_by
  text: order_by
  time: order_by
}

# aggregate min on columns
type comment_min_fields {
  authorId: String
  id: Int
  postId: Int
  text: String
  time: timestamptz
}

# order by min() on columns of table "comment"
input comment_min_order_by {
  authorId: order_by
  id: order_by
  postId: order_by
  text: order_by
  time: order_by
}

# response of any mutation on the table "comment"
type comment_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [comment!]!
}

# input type for inserting object relation for remote table "comment"
input comment_obj_rel_insert_input {
  data: comment_insert_input!
  on_conflict: comment_on_conflict
}

# on conflict condition type for table "comment"
input comment_on_conflict {
  constraint: comment_constraint!
  update_columns: [comment_update_column!]!
  where: comment_bool_exp
}

# ordering options when selecting data from "comment"
input comment_order_by {
  authorId: order_by
  id: order_by
  post: post_order_by
  postId: order_by
  text: order_by
  time: order_by
  user: user_order_by
}

# primary key columns input for table: "comment"
input comment_pk_columns_input {
  id: Int!
}

# select columns of table "comment"
enum comment_select_column {
  # column name
  authorId

  # column name
  id

  # column name
  postId

  # column name
  text

  # column name
  time
}

# input type for updating data in table "comment"
input comment_set_input {
  authorId: String
  id: Int
  postId: Int
  text: String
  time: timestamptz
}

# aggregate stddev on columns
type comment_stddev_fields {
  id: Float
  postId: Float
}

# order by stddev() on columns of table "comment"
input comment_stddev_order_by {
  id: order_by
  postId: order_by
}

# aggregate stddev_pop on columns
type comment_stddev_pop_fields {
  id: Float
  postId: Float
}

# order by stddev_pop() on columns of table "comment"
input comment_stddev_pop_order_by {
  id: order_by
  postId: order_by
}

# aggregate stddev_samp on columns
type comment_stddev_samp_fields {
  id: Float
  postId: Float
}

# order by stddev_samp() on columns of table "comment"
input comment_stddev_samp_order_by {
  id: order_by
  postId: order_by
}

# aggregate sum on columns
type comment_sum_fields {
  id: Int
  postId: Int
}

# order by sum() on columns of table "comment"
input comment_sum_order_by {
  id: order_by
  postId: order_by
}

# update columns of table "comment"
enum comment_update_column {
  # column name
  authorId

  # column name
  id

  # column name
  postId

  # column name
  text

  # column name
  time
}

# aggregate var_pop on columns
type comment_var_pop_fields {
  id: Float
  postId: Float
}

# order by var_pop() on columns of table "comment"
input comment_var_pop_order_by {
  id: order_by
  postId: order_by
}

# aggregate var_samp on columns
type comment_var_samp_fields {
  id: Float
  postId: Float
}

# order by var_samp() on columns of table "comment"
input comment_var_samp_order_by {
  id: order_by
  postId: order_by
}

# aggregate variance on columns
type comment_variance_fields {
  id: Float
  postId: Float
}

# order by variance() on columns of table "comment"
input comment_variance_order_by {
  id: order_by
  postId: order_by
}

type ConfirmFriendRequestOutput {
  recipient: String!
}

# columns and relationships of "event"
type event {
  # An array relationship
  attendees(
    # distinct select on columns
    distinct_on: [userEvent_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userEvent_order_by!]

    # filter the rows returned
    where: userEvent_bool_exp
  ): [userEvent!]!

  # An aggregated array relationship
  attendees_aggregate(
    # distinct select on columns
    distinct_on: [userEvent_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userEvent_order_by!]

    # filter the rows returned
    where: userEvent_bool_exp
  ): userEvent_aggregate!
  description: String
  email: String!
  endDate: timestamptz!
  eventType: String
  gallery(
    # JSON select path
    path: String
  ): jsonb!

  # An array relationship
  hosts(
    # distinct select on columns
    distinct_on: [groupEvent_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupEvent_order_by!]

    # filter the rows returned
    where: groupEvent_bool_exp
  ): [groupEvent!]!

  # An aggregated array relationship
  hosts_aggregate(
    # distinct select on columns
    distinct_on: [groupEvent_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupEvent_order_by!]

    # filter the rows returned
    where: groupEvent_bool_exp
  ): groupEvent_aggregate!
  id: uuid!
  image: String!
  isOfficial: Boolean!
  isZoom: Boolean!
  links(
    # JSON select path
    path: String
  ): jsonb!
  location(
    # JSON select path
    path: String
  ): jsonb!
  name: String!

  # An array relationship
  questions(
    # distinct select on columns
    distinct_on: [eventQuestion_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [eventQuestion_order_by!]

    # filter the rows returned
    where: eventQuestion_bool_exp
  ): [eventQuestion!]!

  # An aggregated array relationship
  questions_aggregate(
    # distinct select on columns
    distinct_on: [eventQuestion_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [eventQuestion_order_by!]

    # filter the rows returned
    where: eventQuestion_bool_exp
  ): eventQuestion_aggregate!
  startDate: timestamptz!
  website: String
}

# aggregated selection of "event"
type event_aggregate {
  aggregate: event_aggregate_fields
  nodes: [event!]!
}

# aggregate fields of "event"
type event_aggregate_fields {
  count(columns: [event_select_column!], distinct: Boolean): Int
  max: event_max_fields
  min: event_min_fields
}

# order by aggregate values of table "event"
input event_aggregate_order_by {
  count: order_by
  max: event_max_order_by
  min: event_min_order_by
}

# append existing jsonb value of filtered columns with new jsonb value
input event_append_input {
  gallery: jsonb
  links: jsonb
  location: jsonb
}

# input type for inserting array relation for remote table "event"
input event_arr_rel_insert_input {
  data: [event_insert_input!]!
  on_conflict: event_on_conflict
}

# Boolean expression to filter rows from the table "event". All fields are combined with a logical 'AND'.
input event_bool_exp {
  _and: [event_bool_exp]
  _not: event_bool_exp
  _or: [event_bool_exp]
  attendees: userEvent_bool_exp
  description: String_comparison_exp
  email: String_comparison_exp
  endDate: timestamptz_comparison_exp
  eventType: String_comparison_exp
  gallery: jsonb_comparison_exp
  hosts: groupEvent_bool_exp
  id: uuid_comparison_exp
  image: String_comparison_exp
  isOfficial: Boolean_comparison_exp
  isZoom: Boolean_comparison_exp
  links: jsonb_comparison_exp
  location: jsonb_comparison_exp
  name: String_comparison_exp
  questions: eventQuestion_bool_exp
  startDate: timestamptz_comparison_exp
  website: String_comparison_exp
}

# unique or primary key constraints on table "event"
enum event_constraint {
  # unique or primary key constraint
  event_id_key

  # unique or primary key constraint
  event_pkey
}

# delete the field or element with specified path (for JSON arrays, negative integers count from the end)
input event_delete_at_path_input {
  gallery: [String]
  links: [String]
  location: [String]
}

# delete the array element with specified index (negative integers count from the
# end). throws an error if top level container is not an array
input event_delete_elem_input {
  gallery: Int
  links: Int
  location: Int
}

# delete key/value pair or string element. key/value pairs are matched based on their key value
input event_delete_key_input {
  gallery: String
  links: String
  location: String
}

# input type for inserting data into table "event"
input event_insert_input {
  attendees: userEvent_arr_rel_insert_input
  description: String
  email: String
  endDate: timestamptz
  eventType: String
  gallery: jsonb
  hosts: groupEvent_arr_rel_insert_input
  id: uuid
  image: String
  isOfficial: Boolean
  isZoom: Boolean
  links: jsonb
  location: jsonb
  name: String
  questions: eventQuestion_arr_rel_insert_input
  startDate: timestamptz
  website: String
}

# aggregate max on columns
type event_max_fields {
  description: String
  email: String
  endDate: timestamptz
  eventType: String
  id: uuid
  image: String
  name: String
  startDate: timestamptz
  website: String
}

# order by max() on columns of table "event"
input event_max_order_by {
  description: order_by
  email: order_by
  endDate: order_by
  eventType: order_by
  id: order_by
  image: order_by
  name: order_by
  startDate: order_by
  website: order_by
}

# aggregate min on columns
type event_min_fields {
  description: String
  email: String
  endDate: timestamptz
  eventType: String
  id: uuid
  image: String
  name: String
  startDate: timestamptz
  website: String
}

# order by min() on columns of table "event"
input event_min_order_by {
  description: order_by
  email: order_by
  endDate: order_by
  eventType: order_by
  id: order_by
  image: order_by
  name: order_by
  startDate: order_by
  website: order_by
}

# response of any mutation on the table "event"
type event_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [event!]!
}

# input type for inserting object relation for remote table "event"
input event_obj_rel_insert_input {
  data: event_insert_input!
  on_conflict: event_on_conflict
}

# on conflict condition type for table "event"
input event_on_conflict {
  constraint: event_constraint!
  update_columns: [event_update_column!]!
  where: event_bool_exp
}

# ordering options when selecting data from "event"
input event_order_by {
  attendees_aggregate: userEvent_aggregate_order_by
  description: order_by
  email: order_by
  endDate: order_by
  eventType: order_by
  gallery: order_by
  hosts_aggregate: groupEvent_aggregate_order_by
  id: order_by
  image: order_by
  isOfficial: order_by
  isZoom: order_by
  links: order_by
  location: order_by
  name: order_by
  questions_aggregate: eventQuestion_aggregate_order_by
  startDate: order_by
  website: order_by
}

# primary key columns input for table: "event"
input event_pk_columns_input {
  id: uuid!
}

# prepend existing jsonb value of filtered columns with new jsonb value
input event_prepend_input {
  gallery: jsonb
  links: jsonb
  location: jsonb
}

# select columns of table "event"
enum event_select_column {
  # column name
  description

  # column name
  email

  # column name
  endDate

  # column name
  eventType

  # column name
  gallery

  # column name
  id

  # column name
  image

  # column name
  isOfficial

  # column name
  isZoom

  # column name
  links

  # column name
  location

  # column name
  name

  # column name
  startDate

  # column name
  website
}

# input type for updating data in table "event"
input event_set_input {
  description: String
  email: String
  endDate: timestamptz
  eventType: String
  gallery: jsonb
  id: uuid
  image: String
  isOfficial: Boolean
  isZoom: Boolean
  links: jsonb
  location: jsonb
  name: String
  startDate: timestamptz
  website: String
}

# update columns of table "event"
enum event_update_column {
  # column name
  description

  # column name
  email

  # column name
  endDate

  # column name
  eventType

  # column name
  gallery

  # column name
  id

  # column name
  image

  # column name
  isOfficial

  # column name
  isZoom

  # column name
  links

  # column name
  location

  # column name
  name

  # column name
  startDate

  # column name
  website
}

# columns and relationships of "eventQuestion"
type eventQuestion {
  # An object relationship
  event: event!
  eventId: uuid!

  # An object relationship
  question: question!
  questionId: Int!
}

# aggregated selection of "eventQuestion"
type eventQuestion_aggregate {
  aggregate: eventQuestion_aggregate_fields
  nodes: [eventQuestion!]!
}

# aggregate fields of "eventQuestion"
type eventQuestion_aggregate_fields {
  avg: eventQuestion_avg_fields
  count(columns: [eventQuestion_select_column!], distinct: Boolean): Int
  max: eventQuestion_max_fields
  min: eventQuestion_min_fields
  stddev: eventQuestion_stddev_fields
  stddev_pop: eventQuestion_stddev_pop_fields
  stddev_samp: eventQuestion_stddev_samp_fields
  sum: eventQuestion_sum_fields
  var_pop: eventQuestion_var_pop_fields
  var_samp: eventQuestion_var_samp_fields
  variance: eventQuestion_variance_fields
}

# order by aggregate values of table "eventQuestion"
input eventQuestion_aggregate_order_by {
  avg: eventQuestion_avg_order_by
  count: order_by
  max: eventQuestion_max_order_by
  min: eventQuestion_min_order_by
  stddev: eventQuestion_stddev_order_by
  stddev_pop: eventQuestion_stddev_pop_order_by
  stddev_samp: eventQuestion_stddev_samp_order_by
  sum: eventQuestion_sum_order_by
  var_pop: eventQuestion_var_pop_order_by
  var_samp: eventQuestion_var_samp_order_by
  variance: eventQuestion_variance_order_by
}

# input type for inserting array relation for remote table "eventQuestion"
input eventQuestion_arr_rel_insert_input {
  data: [eventQuestion_insert_input!]!
  on_conflict: eventQuestion_on_conflict
}

# aggregate avg on columns
type eventQuestion_avg_fields {
  questionId: Float
}

# order by avg() on columns of table "eventQuestion"
input eventQuestion_avg_order_by {
  questionId: order_by
}

# Boolean expression to filter rows from the table "eventQuestion". All fields are combined with a logical 'AND'.
input eventQuestion_bool_exp {
  _and: [eventQuestion_bool_exp]
  _not: eventQuestion_bool_exp
  _or: [eventQuestion_bool_exp]
  event: event_bool_exp
  eventId: uuid_comparison_exp
  question: question_bool_exp
  questionId: Int_comparison_exp
}

# unique or primary key constraints on table "eventQuestion"
enum eventQuestion_constraint {
  # unique or primary key constraint
  eventQuestion_pkey
}

# input type for incrementing integer column in table "eventQuestion"
input eventQuestion_inc_input {
  questionId: Int
}

# input type for inserting data into table "eventQuestion"
input eventQuestion_insert_input {
  event: event_obj_rel_insert_input
  eventId: uuid
  question: question_obj_rel_insert_input
  questionId: Int
}

# aggregate max on columns
type eventQuestion_max_fields {
  eventId: uuid
  questionId: Int
}

# order by max() on columns of table "eventQuestion"
input eventQuestion_max_order_by {
  eventId: order_by
  questionId: order_by
}

# aggregate min on columns
type eventQuestion_min_fields {
  eventId: uuid
  questionId: Int
}

# order by min() on columns of table "eventQuestion"
input eventQuestion_min_order_by {
  eventId: order_by
  questionId: order_by
}

# response of any mutation on the table "eventQuestion"
type eventQuestion_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [eventQuestion!]!
}

# input type for inserting object relation for remote table "eventQuestion"
input eventQuestion_obj_rel_insert_input {
  data: eventQuestion_insert_input!
  on_conflict: eventQuestion_on_conflict
}

# on conflict condition type for table "eventQuestion"
input eventQuestion_on_conflict {
  constraint: eventQuestion_constraint!
  update_columns: [eventQuestion_update_column!]!
  where: eventQuestion_bool_exp
}

# ordering options when selecting data from "eventQuestion"
input eventQuestion_order_by {
  event: event_order_by
  eventId: order_by
  question: question_order_by
  questionId: order_by
}

# primary key columns input for table: "eventQuestion"
input eventQuestion_pk_columns_input {
  eventId: uuid!
  questionId: Int!
}

# select columns of table "eventQuestion"
enum eventQuestion_select_column {
  # column name
  eventId

  # column name
  questionId
}

# input type for updating data in table "eventQuestion"
input eventQuestion_set_input {
  eventId: uuid
  questionId: Int
}

# aggregate stddev on columns
type eventQuestion_stddev_fields {
  questionId: Float
}

# order by stddev() on columns of table "eventQuestion"
input eventQuestion_stddev_order_by {
  questionId: order_by
}

# aggregate stddev_pop on columns
type eventQuestion_stddev_pop_fields {
  questionId: Float
}

# order by stddev_pop() on columns of table "eventQuestion"
input eventQuestion_stddev_pop_order_by {
  questionId: order_by
}

# aggregate stddev_samp on columns
type eventQuestion_stddev_samp_fields {
  questionId: Float
}

# order by stddev_samp() on columns of table "eventQuestion"
input eventQuestion_stddev_samp_order_by {
  questionId: order_by
}

# aggregate sum on columns
type eventQuestion_sum_fields {
  questionId: Int
}

# order by sum() on columns of table "eventQuestion"
input eventQuestion_sum_order_by {
  questionId: order_by
}

# update columns of table "eventQuestion"
enum eventQuestion_update_column {
  # column name
  eventId

  # column name
  questionId
}

# aggregate var_pop on columns
type eventQuestion_var_pop_fields {
  questionId: Float
}

# order by var_pop() on columns of table "eventQuestion"
input eventQuestion_var_pop_order_by {
  questionId: order_by
}

# aggregate var_samp on columns
type eventQuestion_var_samp_fields {
  questionId: Float
}

# order by var_samp() on columns of table "eventQuestion"
input eventQuestion_var_samp_order_by {
  questionId: order_by
}

# aggregate variance on columns
type eventQuestion_variance_fields {
  questionId: Float
}

# order by variance() on columns of table "eventQuestion"
input eventQuestion_variance_order_by {
  questionId: order_by
}

# columns and relationships of "friend"
type friend {
  # An object relationship
  friend: user!
  friendId: String!
  original: Boolean!

  # An object relationship
  user: user!
  userId: String!
}

# aggregated selection of "friend"
type friend_aggregate {
  aggregate: friend_aggregate_fields
  nodes: [friend!]!
}

# aggregate fields of "friend"
type friend_aggregate_fields {
  count(columns: [friend_select_column!], distinct: Boolean): Int
  max: friend_max_fields
  min: friend_min_fields
}

# order by aggregate values of table "friend"
input friend_aggregate_order_by {
  count: order_by
  max: friend_max_order_by
  min: friend_min_order_by
}

# input type for inserting array relation for remote table "friend"
input friend_arr_rel_insert_input {
  data: [friend_insert_input!]!
  on_conflict: friend_on_conflict
}

# Boolean expression to filter rows from the table "friend". All fields are combined with a logical 'AND'.
input friend_bool_exp {
  _and: [friend_bool_exp]
  _not: friend_bool_exp
  _or: [friend_bool_exp]
  friend: user_bool_exp
  friendId: String_comparison_exp
  original: Boolean_comparison_exp
  user: user_bool_exp
  userId: String_comparison_exp
}

# unique or primary key constraints on table "friend"
enum friend_constraint {
  # unique or primary key constraint
  friend_pkey
}

# input type for inserting data into table "friend"
input friend_insert_input {
  friend: user_obj_rel_insert_input
  friendId: String
  original: Boolean
  user: user_obj_rel_insert_input
  userId: String
}

# aggregate max on columns
type friend_max_fields {
  friendId: String
  userId: String
}

# order by max() on columns of table "friend"
input friend_max_order_by {
  friendId: order_by
  userId: order_by
}

# aggregate min on columns
type friend_min_fields {
  friendId: String
  userId: String
}

# order by min() on columns of table "friend"
input friend_min_order_by {
  friendId: order_by
  userId: order_by
}

# response of any mutation on the table "friend"
type friend_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [friend!]!
}

# input type for inserting object relation for remote table "friend"
input friend_obj_rel_insert_input {
  data: friend_insert_input!
  on_conflict: friend_on_conflict
}

# on conflict condition type for table "friend"
input friend_on_conflict {
  constraint: friend_constraint!
  update_columns: [friend_update_column!]!
  where: friend_bool_exp
}

# ordering options when selecting data from "friend"
input friend_order_by {
  friend: user_order_by
  friendId: order_by
  original: order_by
  user: user_order_by
  userId: order_by
}

# primary key columns input for table: "friend"
input friend_pk_columns_input {
  friendId: String!
  userId: String!
}

# select columns of table "friend"
enum friend_select_column {
  # column name
  friendId

  # column name
  original

  # column name
  userId
}

# input type for updating data in table "friend"
input friend_set_input {
  friendId: String
  original: Boolean
  userId: String
}

# update columns of table "friend"
enum friend_update_column {
  # column name
  friendId

  # column name
  original

  # column name
  userId
}

# columns and relationships of "friendRequest"
type friendRequest {
  date: timestamptz!
  recipient: String!
  sender: String!

  # An object relationship
  user: user!

  # An object relationship
  userByRecipient: user!
}

# aggregated selection of "friendRequest"
type friendRequest_aggregate {
  aggregate: friendRequest_aggregate_fields
  nodes: [friendRequest!]!
}

# aggregate fields of "friendRequest"
type friendRequest_aggregate_fields {
  count(columns: [friendRequest_select_column!], distinct: Boolean): Int
  max: friendRequest_max_fields
  min: friendRequest_min_fields
}

# order by aggregate values of table "friendRequest"
input friendRequest_aggregate_order_by {
  count: order_by
  max: friendRequest_max_order_by
  min: friendRequest_min_order_by
}

# input type for inserting array relation for remote table "friendRequest"
input friendRequest_arr_rel_insert_input {
  data: [friendRequest_insert_input!]!
  on_conflict: friendRequest_on_conflict
}

# Boolean expression to filter rows from the table "friendRequest". All fields are combined with a logical 'AND'.
input friendRequest_bool_exp {
  _and: [friendRequest_bool_exp]
  _not: friendRequest_bool_exp
  _or: [friendRequest_bool_exp]
  date: timestamptz_comparison_exp
  recipient: String_comparison_exp
  sender: String_comparison_exp
  user: user_bool_exp
  userByRecipient: user_bool_exp
}

# unique or primary key constraints on table "friendRequest"
enum friendRequest_constraint {
  # unique or primary key constraint
  pendingFriend_pkey
}

# input type for inserting data into table "friendRequest"
input friendRequest_insert_input {
  date: timestamptz
  recipient: String
  sender: String
  user: user_obj_rel_insert_input
  userByRecipient: user_obj_rel_insert_input
}

# aggregate max on columns
type friendRequest_max_fields {
  date: timestamptz
  recipient: String
  sender: String
}

# order by max() on columns of table "friendRequest"
input friendRequest_max_order_by {
  date: order_by
  recipient: order_by
  sender: order_by
}

# aggregate min on columns
type friendRequest_min_fields {
  date: timestamptz
  recipient: String
  sender: String
}

# order by min() on columns of table "friendRequest"
input friendRequest_min_order_by {
  date: order_by
  recipient: order_by
  sender: order_by
}

# response of any mutation on the table "friendRequest"
type friendRequest_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [friendRequest!]!
}

# input type for inserting object relation for remote table "friendRequest"
input friendRequest_obj_rel_insert_input {
  data: friendRequest_insert_input!
  on_conflict: friendRequest_on_conflict
}

# on conflict condition type for table "friendRequest"
input friendRequest_on_conflict {
  constraint: friendRequest_constraint!
  update_columns: [friendRequest_update_column!]!
  where: friendRequest_bool_exp
}

# ordering options when selecting data from "friendRequest"
input friendRequest_order_by {
  date: order_by
  recipient: order_by
  sender: order_by
  user: user_order_by
  userByRecipient: user_order_by
}

# primary key columns input for table: "friendRequest"
input friendRequest_pk_columns_input {
  recipient: String!
  sender: String!
}

# select columns of table "friendRequest"
enum friendRequest_select_column {
  # column name
  date

  # column name
  recipient

  # column name
  sender
}

# input type for updating data in table "friendRequest"
input friendRequest_set_input {
  date: timestamptz
  recipient: String
  sender: String
}

# update columns of table "friendRequest"
enum friendRequest_update_column {
  # column name
  date

  # column name
  recipient

  # column name
  sender
}

# columns and relationships of "friendView"
type friendView {
  college: String
  description: String
  email: String
  id: String
  image: String
  isOfficial: Boolean
  links(
    # JSON select path
    path: String
  ): jsonb
  name: String
  userId: String
  year: Int
}

# aggregated selection of "friendView"
type friendView_aggregate {
  aggregate: friendView_aggregate_fields
  nodes: [friendView!]!
}

# aggregate fields of "friendView"
type friendView_aggregate_fields {
  avg: friendView_avg_fields
  count(columns: [friendView_select_column!], distinct: Boolean): Int
  max: friendView_max_fields
  min: friendView_min_fields
  stddev: friendView_stddev_fields
  stddev_pop: friendView_stddev_pop_fields
  stddev_samp: friendView_stddev_samp_fields
  sum: friendView_sum_fields
  var_pop: friendView_var_pop_fields
  var_samp: friendView_var_samp_fields
  variance: friendView_variance_fields
}

# order by aggregate values of table "friendView"
input friendView_aggregate_order_by {
  avg: friendView_avg_order_by
  count: order_by
  max: friendView_max_order_by
  min: friendView_min_order_by
  stddev: friendView_stddev_order_by
  stddev_pop: friendView_stddev_pop_order_by
  stddev_samp: friendView_stddev_samp_order_by
  sum: friendView_sum_order_by
  var_pop: friendView_var_pop_order_by
  var_samp: friendView_var_samp_order_by
  variance: friendView_variance_order_by
}

# append existing jsonb value of filtered columns with new jsonb value
input friendView_append_input {
  links: jsonb
}

# aggregate avg on columns
type friendView_avg_fields {
  year: Float
}

# order by avg() on columns of table "friendView"
input friendView_avg_order_by {
  year: order_by
}

# Boolean expression to filter rows from the table "friendView". All fields are combined with a logical 'AND'.
input friendView_bool_exp {
  _and: [friendView_bool_exp]
  _not: friendView_bool_exp
  _or: [friendView_bool_exp]
  college: String_comparison_exp
  description: String_comparison_exp
  email: String_comparison_exp
  id: String_comparison_exp
  image: String_comparison_exp
  isOfficial: Boolean_comparison_exp
  links: jsonb_comparison_exp
  name: String_comparison_exp
  userId: String_comparison_exp
  year: Int_comparison_exp
}

# delete the field or element with specified path (for JSON arrays, negative integers count from the end)
input friendView_delete_at_path_input {
  links: [String]
}

# delete the array element with specified index (negative integers count from the
# end). throws an error if top level container is not an array
input friendView_delete_elem_input {
  links: Int
}

# delete key/value pair or string element. key/value pairs are matched based on their key value
input friendView_delete_key_input {
  links: String
}

# aggregate max on columns
type friendView_max_fields {
  college: String
  description: String
  email: String
  id: String
  image: String
  name: String
  userId: String
  year: Int
}

# order by max() on columns of table "friendView"
input friendView_max_order_by {
  college: order_by
  description: order_by
  email: order_by
  id: order_by
  image: order_by
  name: order_by
  userId: order_by
  year: order_by
}

# aggregate min on columns
type friendView_min_fields {
  college: String
  description: String
  email: String
  id: String
  image: String
  name: String
  userId: String
  year: Int
}

# order by min() on columns of table "friendView"
input friendView_min_order_by {
  college: order_by
  description: order_by
  email: order_by
  id: order_by
  image: order_by
  name: order_by
  userId: order_by
  year: order_by
}

# ordering options when selecting data from "friendView"
input friendView_order_by {
  college: order_by
  description: order_by
  email: order_by
  id: order_by
  image: order_by
  isOfficial: order_by
  links: order_by
  name: order_by
  userId: order_by
  year: order_by
}

# prepend existing jsonb value of filtered columns with new jsonb value
input friendView_prepend_input {
  links: jsonb
}

# select columns of table "friendView"
enum friendView_select_column {
  # column name
  college

  # column name
  description

  # column name
  email

  # column name
  id

  # column name
  image

  # column name
  isOfficial

  # column name
  links

  # column name
  name

  # column name
  userId

  # column name
  year
}

# aggregate stddev on columns
type friendView_stddev_fields {
  year: Float
}

# order by stddev() on columns of table "friendView"
input friendView_stddev_order_by {
  year: order_by
}

# aggregate stddev_pop on columns
type friendView_stddev_pop_fields {
  year: Float
}

# order by stddev_pop() on columns of table "friendView"
input friendView_stddev_pop_order_by {
  year: order_by
}

# aggregate stddev_samp on columns
type friendView_stddev_samp_fields {
  year: Float
}

# order by stddev_samp() on columns of table "friendView"
input friendView_stddev_samp_order_by {
  year: order_by
}

# aggregate sum on columns
type friendView_sum_fields {
  year: Int
}

# order by sum() on columns of table "friendView"
input friendView_sum_order_by {
  year: order_by
}

# aggregate var_pop on columns
type friendView_var_pop_fields {
  year: Float
}

# order by var_pop() on columns of table "friendView"
input friendView_var_pop_order_by {
  year: order_by
}

# aggregate var_samp on columns
type friendView_var_samp_fields {
  year: Float
}

# order by var_samp() on columns of table "friendView"
input friendView_var_samp_order_by {
  year: order_by
}

# aggregate variance on columns
type friendView_variance_fields {
  year: Float
}

# order by variance() on columns of table "friendView"
input friendView_variance_order_by {
  year: order_by
}

input getrandomusers_args {
  userid: String
}

# columns and relationships of "group"
type group {
  description: String
  email: String!

  # An array relationship
  events(
    # distinct select on columns
    distinct_on: [groupEvent_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupEvent_order_by!]

    # filter the rows returned
    where: groupEvent_bool_exp
  ): [groupEvent!]!

  # An aggregated array relationship
  events_aggregate(
    # distinct select on columns
    distinct_on: [groupEvent_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupEvent_order_by!]

    # filter the rows returned
    where: groupEvent_bool_exp
  ): groupEvent_aggregate!
  gallery(
    # JSON select path
    path: String
  ): jsonb!

  # An array relationship
  groupChats(
    # distinct select on columns
    distinct_on: [groupChats_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupChats_order_by!]

    # filter the rows returned
    where: groupChats_bool_exp
  ): [groupChats!]!

  # An aggregated array relationship
  groupChats_aggregate(
    # distinct select on columns
    distinct_on: [groupChats_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupChats_order_by!]

    # filter the rows returned
    where: groupChats_bool_exp
  ): groupChats_aggregate!

  # An array relationship
  groupTrophies(
    # distinct select on columns
    distinct_on: [groupTrophy_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupTrophy_order_by!]

    # filter the rows returned
    where: groupTrophy_bool_exp
  ): [groupTrophy!]!

  # An aggregated array relationship
  groupTrophies_aggregate(
    # distinct select on columns
    distinct_on: [groupTrophy_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupTrophy_order_by!]

    # filter the rows returned
    where: groupTrophy_bool_exp
  ): groupTrophy_aggregate!
  groupType: String!
  id: uuid!
  image: String!
  links(
    # JSON select path
    path: String
  ): jsonb!

  # An array relationship
  members(
    # distinct select on columns
    distinct_on: [userGroup_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userGroup_order_by!]

    # filter the rows returned
    where: userGroup_bool_exp
  ): [userGroup!]!

  # An aggregated array relationship
  members_aggregate(
    # distinct select on columns
    distinct_on: [userGroup_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userGroup_order_by!]

    # filter the rows returned
    where: userGroup_bool_exp
  ): userGroup_aggregate!
  name: String!
  phone: String

  # An array relationship
  posts(
    # distinct select on columns
    distinct_on: [post_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [post_order_by!]

    # filter the rows returned
    where: post_bool_exp
  ): [post!]!

  # An aggregated array relationship
  posts_aggregate(
    # distinct select on columns
    distinct_on: [post_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [post_order_by!]

    # filter the rows returned
    where: post_bool_exp
  ): post_aggregate!

  # An array relationship
  questions(
    # distinct select on columns
    distinct_on: [groupQuestion_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupQuestion_order_by!]

    # filter the rows returned
    where: groupQuestion_bool_exp
  ): [groupQuestion!]!

  # An aggregated array relationship
  questions_aggregate(
    # distinct select on columns
    distinct_on: [groupQuestion_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupQuestion_order_by!]

    # filter the rows returned
    where: groupQuestion_bool_exp
  ): groupQuestion_aggregate!

  # An array relationship
  reviews(
    # distinct select on columns
    distinct_on: [review_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [review_order_by!]

    # filter the rows returned
    where: review_bool_exp
  ): [review!]!

  # An aggregated array relationship
  reviews_aggregate(
    # distinct select on columns
    distinct_on: [review_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [review_order_by!]

    # filter the rows returned
    where: review_bool_exp
  ): review_aggregate!

  # An array relationship
  tags(
    # distinct select on columns
    distinct_on: [groupInterest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupInterest_order_by!]

    # filter the rows returned
    where: groupInterest_bool_exp
  ): [groupInterest!]!

  # An aggregated array relationship
  tags_aggregate(
    # distinct select on columns
    distinct_on: [groupInterest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupInterest_order_by!]

    # filter the rows returned
    where: groupInterest_bool_exp
  ): groupInterest_aggregate!

  # An array relationship
  trophies(
    # distinct select on columns
    distinct_on: [trophyGroupView_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [trophyGroupView_order_by!]

    # filter the rows returned
    where: trophyGroupView_bool_exp
  ): [trophyGroupView!]!

  # An aggregated array relationship
  trophies_aggregate(
    # distinct select on columns
    distinct_on: [trophyGroupView_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [trophyGroupView_order_by!]

    # filter the rows returned
    where: trophyGroupView_bool_exp
  ): trophyGroupView_aggregate!
  unsubscribable: Boolean!
  website: String
}

# aggregated selection of "group"
type group_aggregate {
  aggregate: group_aggregate_fields
  nodes: [group!]!
}

# aggregate fields of "group"
type group_aggregate_fields {
  count(columns: [group_select_column!], distinct: Boolean): Int
  max: group_max_fields
  min: group_min_fields
}

# order by aggregate values of table "group"
input group_aggregate_order_by {
  count: order_by
  max: group_max_order_by
  min: group_min_order_by
}

# append existing jsonb value of filtered columns with new jsonb value
input group_append_input {
  gallery: jsonb
  links: jsonb
}

# input type for inserting array relation for remote table "group"
input group_arr_rel_insert_input {
  data: [group_insert_input!]!
  on_conflict: group_on_conflict
}

# Boolean expression to filter rows from the table "group". All fields are combined with a logical 'AND'.
input group_bool_exp {
  _and: [group_bool_exp]
  _not: group_bool_exp
  _or: [group_bool_exp]
  description: String_comparison_exp
  email: String_comparison_exp
  events: groupEvent_bool_exp
  gallery: jsonb_comparison_exp
  groupChats: groupChats_bool_exp
  groupTrophies: groupTrophy_bool_exp
  groupType: String_comparison_exp
  id: uuid_comparison_exp
  image: String_comparison_exp
  links: jsonb_comparison_exp
  members: userGroup_bool_exp
  name: String_comparison_exp
  phone: String_comparison_exp
  posts: post_bool_exp
  questions: groupQuestion_bool_exp
  reviews: review_bool_exp
  tags: groupInterest_bool_exp
  trophies: trophyGroupView_bool_exp
  unsubscribable: Boolean_comparison_exp
  website: String_comparison_exp
}

# unique or primary key constraints on table "group"
enum group_constraint {
  # unique or primary key constraint
  group_id_key

  # unique or primary key constraint
  group_pkey
}

# delete the field or element with specified path (for JSON arrays, negative integers count from the end)
input group_delete_at_path_input {
  gallery: [String]
  links: [String]
}

# delete the array element with specified index (negative integers count from the
# end). throws an error if top level container is not an array
input group_delete_elem_input {
  gallery: Int
  links: Int
}

# delete key/value pair or string element. key/value pairs are matched based on their key value
input group_delete_key_input {
  gallery: String
  links: String
}

# input type for inserting data into table "group"
input group_insert_input {
  description: String
  email: String
  events: groupEvent_arr_rel_insert_input
  gallery: jsonb
  groupChats: groupChats_arr_rel_insert_input
  groupTrophies: groupTrophy_arr_rel_insert_input
  groupType: String
  id: uuid
  image: String
  links: jsonb
  members: userGroup_arr_rel_insert_input
  name: String
  phone: String
  posts: post_arr_rel_insert_input
  questions: groupQuestion_arr_rel_insert_input
  reviews: review_arr_rel_insert_input
  tags: groupInterest_arr_rel_insert_input
  unsubscribable: Boolean
  website: String
}

# aggregate max on columns
type group_max_fields {
  description: String
  email: String
  groupType: String
  id: uuid
  image: String
  name: String
  phone: String
  website: String
}

# order by max() on columns of table "group"
input group_max_order_by {
  description: order_by
  email: order_by
  groupType: order_by
  id: order_by
  image: order_by
  name: order_by
  phone: order_by
  website: order_by
}

# aggregate min on columns
type group_min_fields {
  description: String
  email: String
  groupType: String
  id: uuid
  image: String
  name: String
  phone: String
  website: String
}

# order by min() on columns of table "group"
input group_min_order_by {
  description: order_by
  email: order_by
  groupType: order_by
  id: order_by
  image: order_by
  name: order_by
  phone: order_by
  website: order_by
}

# response of any mutation on the table "group"
type group_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [group!]!
}

# input type for inserting object relation for remote table "group"
input group_obj_rel_insert_input {
  data: group_insert_input!
  on_conflict: group_on_conflict
}

# on conflict condition type for table "group"
input group_on_conflict {
  constraint: group_constraint!
  update_columns: [group_update_column!]!
  where: group_bool_exp
}

# ordering options when selecting data from "group"
input group_order_by {
  description: order_by
  email: order_by
  events_aggregate: groupEvent_aggregate_order_by
  gallery: order_by
  groupChats_aggregate: groupChats_aggregate_order_by
  groupTrophies_aggregate: groupTrophy_aggregate_order_by
  groupType: order_by
  id: order_by
  image: order_by
  links: order_by
  members_aggregate: userGroup_aggregate_order_by
  name: order_by
  phone: order_by
  posts_aggregate: post_aggregate_order_by
  questions_aggregate: groupQuestion_aggregate_order_by
  reviews_aggregate: review_aggregate_order_by
  tags_aggregate: groupInterest_aggregate_order_by
  trophies_aggregate: trophyGroupView_aggregate_order_by
  unsubscribable: order_by
  website: order_by
}

# primary key columns input for table: "group"
input group_pk_columns_input {
  id: uuid!
}

# prepend existing jsonb value of filtered columns with new jsonb value
input group_prepend_input {
  gallery: jsonb
  links: jsonb
}

# select columns of table "group"
enum group_select_column {
  # column name
  description

  # column name
  email

  # column name
  gallery

  # column name
  groupType

  # column name
  id

  # column name
  image

  # column name
  links

  # column name
  name

  # column name
  phone

  # column name
  unsubscribable

  # column name
  website
}

# input type for updating data in table "group"
input group_set_input {
  description: String
  email: String
  gallery: jsonb
  groupType: String
  id: uuid
  image: String
  links: jsonb
  name: String
  phone: String
  unsubscribable: Boolean
  website: String
}

# update columns of table "group"
enum group_update_column {
  # column name
  description

  # column name
  email

  # column name
  gallery

  # column name
  groupType

  # column name
  id

  # column name
  image

  # column name
  links

  # column name
  name

  # column name
  phone

  # column name
  unsubscribable

  # column name
  website
}

# Made by Zach. Fix if wrong
#
#
# columns and relationships of "groupChats"
#
type groupChats {
  # An object relationship
  chat: chat!
  chatId: Int!

  # An object relationship
  group: group!
  groupId: uuid!
}

# aggregated selection of "groupChats"
type groupChats_aggregate {
  aggregate: groupChats_aggregate_fields
  nodes: [groupChats!]!
}

# aggregate fields of "groupChats"
type groupChats_aggregate_fields {
  avg: groupChats_avg_fields
  count(columns: [groupChats_select_column!], distinct: Boolean): Int
  max: groupChats_max_fields
  min: groupChats_min_fields
  stddev: groupChats_stddev_fields
  stddev_pop: groupChats_stddev_pop_fields
  stddev_samp: groupChats_stddev_samp_fields
  sum: groupChats_sum_fields
  var_pop: groupChats_var_pop_fields
  var_samp: groupChats_var_samp_fields
  variance: groupChats_variance_fields
}

# order by aggregate values of table "groupChats"
input groupChats_aggregate_order_by {
  avg: groupChats_avg_order_by
  count: order_by
  max: groupChats_max_order_by
  min: groupChats_min_order_by
  stddev: groupChats_stddev_order_by
  stddev_pop: groupChats_stddev_pop_order_by
  stddev_samp: groupChats_stddev_samp_order_by
  sum: groupChats_sum_order_by
  var_pop: groupChats_var_pop_order_by
  var_samp: groupChats_var_samp_order_by
  variance: groupChats_variance_order_by
}

# input type for inserting array relation for remote table "groupChats"
input groupChats_arr_rel_insert_input {
  data: [groupChats_insert_input!]!
  on_conflict: groupChats_on_conflict
}

# aggregate avg on columns
type groupChats_avg_fields {
  chatId: Float
}

# order by avg() on columns of table "groupChats"
input groupChats_avg_order_by {
  chatId: order_by
}

# Boolean expression to filter rows from the table "groupChats". All fields are combined with a logical 'AND'.
input groupChats_bool_exp {
  _and: [groupChats_bool_exp]
  _not: groupChats_bool_exp
  _or: [groupChats_bool_exp]
  chat: chat_bool_exp
  chatId: Int_comparison_exp
  group: group_bool_exp
  groupId: uuid_comparison_exp
}

# unique or primary key constraints on table "groupChats"
enum groupChats_constraint {
  # unique or primary key constraint
  groupChats_pkey
}

# input type for incrementing integer column in table "groupChats"
input groupChats_inc_input {
  chatId: Int
}

# input type for inserting data into table "groupChats"
input groupChats_insert_input {
  chat: chat_obj_rel_insert_input
  chatId: Int
  group: group_obj_rel_insert_input
  groupId: uuid
}

# aggregate max on columns
type groupChats_max_fields {
  chatId: Int
  groupId: uuid
}

# order by max() on columns of table "groupChats"
input groupChats_max_order_by {
  chatId: order_by
  groupId: order_by
}

# aggregate min on columns
type groupChats_min_fields {
  chatId: Int
  groupId: uuid
}

# order by min() on columns of table "groupChats"
input groupChats_min_order_by {
  chatId: order_by
  groupId: order_by
}

# response of any mutation on the table "groupChats"
type groupChats_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [groupChats!]!
}

# input type for inserting object relation for remote table "groupChats"
input groupChats_obj_rel_insert_input {
  data: groupChats_insert_input!
  on_conflict: groupChats_on_conflict
}

# on conflict condition type for table "groupChats"
input groupChats_on_conflict {
  constraint: groupChats_constraint!
  update_columns: [groupChats_update_column!]!
  where: groupChats_bool_exp
}

# ordering options when selecting data from "groupChats"
input groupChats_order_by {
  chat: chat_order_by
  chatId: order_by
  group: group_order_by
  groupId: order_by
}

# primary key columns input for table: "groupChats"
input groupChats_pk_columns_input {
  chatId: Int!
  groupId: uuid!
}

# select columns of table "groupChats"
enum groupChats_select_column {
  # column name
  chatId

  # column name
  groupId
}

# input type for updating data in table "groupChats"
input groupChats_set_input {
  chatId: Int
  groupId: uuid
}

# aggregate stddev on columns
type groupChats_stddev_fields {
  chatId: Float
}

# order by stddev() on columns of table "groupChats"
input groupChats_stddev_order_by {
  chatId: order_by
}

# aggregate stddev_pop on columns
type groupChats_stddev_pop_fields {
  chatId: Float
}

# order by stddev_pop() on columns of table "groupChats"
input groupChats_stddev_pop_order_by {
  chatId: order_by
}

# aggregate stddev_samp on columns
type groupChats_stddev_samp_fields {
  chatId: Float
}

# order by stddev_samp() on columns of table "groupChats"
input groupChats_stddev_samp_order_by {
  chatId: order_by
}

# aggregate sum on columns
type groupChats_sum_fields {
  chatId: Int
}

# order by sum() on columns of table "groupChats"
input groupChats_sum_order_by {
  chatId: order_by
}

# update columns of table "groupChats"
enum groupChats_update_column {
  # column name
  chatId

  # column name
  groupId
}

# aggregate var_pop on columns
type groupChats_var_pop_fields {
  chatId: Float
}

# order by var_pop() on columns of table "groupChats"
input groupChats_var_pop_order_by {
  chatId: order_by
}

# aggregate var_samp on columns
type groupChats_var_samp_fields {
  chatId: Float
}

# order by var_samp() on columns of table "groupChats"
input groupChats_var_samp_order_by {
  chatId: order_by
}

# aggregate variance on columns
type groupChats_variance_fields {
  chatId: Float
}

# order by variance() on columns of table "groupChats"
input groupChats_variance_order_by {
  chatId: order_by
}

# columns and relationships of "groupEvent"
type groupEvent {
  # An object relationship
  event: event!
  eventId: uuid!

  # An object relationship
  group: group!
  groupId: uuid!
}

# aggregated selection of "groupEvent"
type groupEvent_aggregate {
  aggregate: groupEvent_aggregate_fields
  nodes: [groupEvent!]!
}

# aggregate fields of "groupEvent"
type groupEvent_aggregate_fields {
  count(columns: [groupEvent_select_column!], distinct: Boolean): Int
  max: groupEvent_max_fields
  min: groupEvent_min_fields
}

# order by aggregate values of table "groupEvent"
input groupEvent_aggregate_order_by {
  count: order_by
  max: groupEvent_max_order_by
  min: groupEvent_min_order_by
}

# input type for inserting array relation for remote table "groupEvent"
input groupEvent_arr_rel_insert_input {
  data: [groupEvent_insert_input!]!
  on_conflict: groupEvent_on_conflict
}

# Boolean expression to filter rows from the table "groupEvent". All fields are combined with a logical 'AND'.
input groupEvent_bool_exp {
  _and: [groupEvent_bool_exp]
  _not: groupEvent_bool_exp
  _or: [groupEvent_bool_exp]
  event: event_bool_exp
  eventId: uuid_comparison_exp
  group: group_bool_exp
  groupId: uuid_comparison_exp
}

# unique or primary key constraints on table "groupEvent"
enum groupEvent_constraint {
  # unique or primary key constraint
  groupEvent_pkey
}

# input type for inserting data into table "groupEvent"
input groupEvent_insert_input {
  event: event_obj_rel_insert_input
  eventId: uuid
  group: group_obj_rel_insert_input
  groupId: uuid
}

# aggregate max on columns
type groupEvent_max_fields {
  eventId: uuid
  groupId: uuid
}

# order by max() on columns of table "groupEvent"
input groupEvent_max_order_by {
  eventId: order_by
  groupId: order_by
}

# aggregate min on columns
type groupEvent_min_fields {
  eventId: uuid
  groupId: uuid
}

# order by min() on columns of table "groupEvent"
input groupEvent_min_order_by {
  eventId: order_by
  groupId: order_by
}

# response of any mutation on the table "groupEvent"
type groupEvent_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [groupEvent!]!
}

# input type for inserting object relation for remote table "groupEvent"
input groupEvent_obj_rel_insert_input {
  data: groupEvent_insert_input!
  on_conflict: groupEvent_on_conflict
}

# on conflict condition type for table "groupEvent"
input groupEvent_on_conflict {
  constraint: groupEvent_constraint!
  update_columns: [groupEvent_update_column!]!
  where: groupEvent_bool_exp
}

# ordering options when selecting data from "groupEvent"
input groupEvent_order_by {
  event: event_order_by
  eventId: order_by
  group: group_order_by
  groupId: order_by
}

# primary key columns input for table: "groupEvent"
input groupEvent_pk_columns_input {
  eventId: uuid!
  groupId: uuid!
}

# select columns of table "groupEvent"
enum groupEvent_select_column {
  # column name
  eventId

  # column name
  groupId
}

# input type for updating data in table "groupEvent"
input groupEvent_set_input {
  eventId: uuid
  groupId: uuid
}

# update columns of table "groupEvent"
enum groupEvent_update_column {
  # column name
  eventId

  # column name
  groupId
}

# columns and relationships of "groupInterest"
type groupInterest {
  # An object relationship
  group: group!
  groupId: uuid!

  # An object relationship
  interest: interest!
  interestId: Int!
}

# aggregated selection of "groupInterest"
type groupInterest_aggregate {
  aggregate: groupInterest_aggregate_fields
  nodes: [groupInterest!]!
}

# aggregate fields of "groupInterest"
type groupInterest_aggregate_fields {
  avg: groupInterest_avg_fields
  count(columns: [groupInterest_select_column!], distinct: Boolean): Int
  max: groupInterest_max_fields
  min: groupInterest_min_fields
  stddev: groupInterest_stddev_fields
  stddev_pop: groupInterest_stddev_pop_fields
  stddev_samp: groupInterest_stddev_samp_fields
  sum: groupInterest_sum_fields
  var_pop: groupInterest_var_pop_fields
  var_samp: groupInterest_var_samp_fields
  variance: groupInterest_variance_fields
}

# order by aggregate values of table "groupInterest"
input groupInterest_aggregate_order_by {
  avg: groupInterest_avg_order_by
  count: order_by
  max: groupInterest_max_order_by
  min: groupInterest_min_order_by
  stddev: groupInterest_stddev_order_by
  stddev_pop: groupInterest_stddev_pop_order_by
  stddev_samp: groupInterest_stddev_samp_order_by
  sum: groupInterest_sum_order_by
  var_pop: groupInterest_var_pop_order_by
  var_samp: groupInterest_var_samp_order_by
  variance: groupInterest_variance_order_by
}

# input type for inserting array relation for remote table "groupInterest"
input groupInterest_arr_rel_insert_input {
  data: [groupInterest_insert_input!]!
  on_conflict: groupInterest_on_conflict
}

# aggregate avg on columns
type groupInterest_avg_fields {
  interestId: Float
}

# order by avg() on columns of table "groupInterest"
input groupInterest_avg_order_by {
  interestId: order_by
}

# Boolean expression to filter rows from the table "groupInterest". All fields are combined with a logical 'AND'.
input groupInterest_bool_exp {
  _and: [groupInterest_bool_exp]
  _not: groupInterest_bool_exp
  _or: [groupInterest_bool_exp]
  group: group_bool_exp
  groupId: uuid_comparison_exp
  interest: interest_bool_exp
  interestId: Int_comparison_exp
}

# unique or primary key constraints on table "groupInterest"
enum groupInterest_constraint {
  # unique or primary key constraint
  groupInterest_pkey
}

# input type for incrementing integer column in table "groupInterest"
input groupInterest_inc_input {
  interestId: Int
}

# input type for inserting data into table "groupInterest"
input groupInterest_insert_input {
  group: group_obj_rel_insert_input
  groupId: uuid
  interest: interest_obj_rel_insert_input
  interestId: Int
}

# aggregate max on columns
type groupInterest_max_fields {
  groupId: uuid
  interestId: Int
}

# order by max() on columns of table "groupInterest"
input groupInterest_max_order_by {
  groupId: order_by
  interestId: order_by
}

# aggregate min on columns
type groupInterest_min_fields {
  groupId: uuid
  interestId: Int
}

# order by min() on columns of table "groupInterest"
input groupInterest_min_order_by {
  groupId: order_by
  interestId: order_by
}

# response of any mutation on the table "groupInterest"
type groupInterest_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [groupInterest!]!
}

# input type for inserting object relation for remote table "groupInterest"
input groupInterest_obj_rel_insert_input {
  data: groupInterest_insert_input!
  on_conflict: groupInterest_on_conflict
}

# on conflict condition type for table "groupInterest"
input groupInterest_on_conflict {
  constraint: groupInterest_constraint!
  update_columns: [groupInterest_update_column!]!
  where: groupInterest_bool_exp
}

# ordering options when selecting data from "groupInterest"
input groupInterest_order_by {
  group: group_order_by
  groupId: order_by
  interest: interest_order_by
  interestId: order_by
}

# primary key columns input for table: "groupInterest"
input groupInterest_pk_columns_input {
  groupId: uuid!
  interestId: Int!
}

# select columns of table "groupInterest"
enum groupInterest_select_column {
  # column name
  groupId

  # column name
  interestId
}

# input type for updating data in table "groupInterest"
input groupInterest_set_input {
  groupId: uuid
  interestId: Int
}

# aggregate stddev on columns
type groupInterest_stddev_fields {
  interestId: Float
}

# order by stddev() on columns of table "groupInterest"
input groupInterest_stddev_order_by {
  interestId: order_by
}

# aggregate stddev_pop on columns
type groupInterest_stddev_pop_fields {
  interestId: Float
}

# order by stddev_pop() on columns of table "groupInterest"
input groupInterest_stddev_pop_order_by {
  interestId: order_by
}

# aggregate stddev_samp on columns
type groupInterest_stddev_samp_fields {
  interestId: Float
}

# order by stddev_samp() on columns of table "groupInterest"
input groupInterest_stddev_samp_order_by {
  interestId: order_by
}

# aggregate sum on columns
type groupInterest_sum_fields {
  interestId: Int
}

# order by sum() on columns of table "groupInterest"
input groupInterest_sum_order_by {
  interestId: order_by
}

# update columns of table "groupInterest"
enum groupInterest_update_column {
  # column name
  groupId

  # column name
  interestId
}

# aggregate var_pop on columns
type groupInterest_var_pop_fields {
  interestId: Float
}

# order by var_pop() on columns of table "groupInterest"
input groupInterest_var_pop_order_by {
  interestId: order_by
}

# aggregate var_samp on columns
type groupInterest_var_samp_fields {
  interestId: Float
}

# order by var_samp() on columns of table "groupInterest"
input groupInterest_var_samp_order_by {
  interestId: order_by
}

# aggregate variance on columns
type groupInterest_variance_fields {
  interestId: Float
}

# order by variance() on columns of table "groupInterest"
input groupInterest_variance_order_by {
  interestId: order_by
}

# columns and relationships of "groupQuestion"
type groupQuestion {
  # An object relationship
  group: group!
  groupId: uuid!

  # An object relationship
  question: question!
  questionId: Int!
}

# aggregated selection of "groupQuestion"
type groupQuestion_aggregate {
  aggregate: groupQuestion_aggregate_fields
  nodes: [groupQuestion!]!
}

# aggregate fields of "groupQuestion"
type groupQuestion_aggregate_fields {
  avg: groupQuestion_avg_fields
  count(columns: [groupQuestion_select_column!], distinct: Boolean): Int
  max: groupQuestion_max_fields
  min: groupQuestion_min_fields
  stddev: groupQuestion_stddev_fields
  stddev_pop: groupQuestion_stddev_pop_fields
  stddev_samp: groupQuestion_stddev_samp_fields
  sum: groupQuestion_sum_fields
  var_pop: groupQuestion_var_pop_fields
  var_samp: groupQuestion_var_samp_fields
  variance: groupQuestion_variance_fields
}

# order by aggregate values of table "groupQuestion"
input groupQuestion_aggregate_order_by {
  avg: groupQuestion_avg_order_by
  count: order_by
  max: groupQuestion_max_order_by
  min: groupQuestion_min_order_by
  stddev: groupQuestion_stddev_order_by
  stddev_pop: groupQuestion_stddev_pop_order_by
  stddev_samp: groupQuestion_stddev_samp_order_by
  sum: groupQuestion_sum_order_by
  var_pop: groupQuestion_var_pop_order_by
  var_samp: groupQuestion_var_samp_order_by
  variance: groupQuestion_variance_order_by
}

# input type for inserting array relation for remote table "groupQuestion"
input groupQuestion_arr_rel_insert_input {
  data: [groupQuestion_insert_input!]!
  on_conflict: groupQuestion_on_conflict
}

# aggregate avg on columns
type groupQuestion_avg_fields {
  questionId: Float
}

# order by avg() on columns of table "groupQuestion"
input groupQuestion_avg_order_by {
  questionId: order_by
}

# Boolean expression to filter rows from the table "groupQuestion". All fields are combined with a logical 'AND'.
input groupQuestion_bool_exp {
  _and: [groupQuestion_bool_exp]
  _not: groupQuestion_bool_exp
  _or: [groupQuestion_bool_exp]
  group: group_bool_exp
  groupId: uuid_comparison_exp
  question: question_bool_exp
  questionId: Int_comparison_exp
}

# unique or primary key constraints on table "groupQuestion"
enum groupQuestion_constraint {
  # unique or primary key constraint
  groupQuestion_pkey
}

# input type for incrementing integer column in table "groupQuestion"
input groupQuestion_inc_input {
  questionId: Int
}

# input type for inserting data into table "groupQuestion"
input groupQuestion_insert_input {
  group: group_obj_rel_insert_input
  groupId: uuid
  question: question_obj_rel_insert_input
  questionId: Int
}

# aggregate max on columns
type groupQuestion_max_fields {
  groupId: uuid
  questionId: Int
}

# order by max() on columns of table "groupQuestion"
input groupQuestion_max_order_by {
  groupId: order_by
  questionId: order_by
}

# aggregate min on columns
type groupQuestion_min_fields {
  groupId: uuid
  questionId: Int
}

# order by min() on columns of table "groupQuestion"
input groupQuestion_min_order_by {
  groupId: order_by
  questionId: order_by
}

# response of any mutation on the table "groupQuestion"
type groupQuestion_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [groupQuestion!]!
}

# input type for inserting object relation for remote table "groupQuestion"
input groupQuestion_obj_rel_insert_input {
  data: groupQuestion_insert_input!
  on_conflict: groupQuestion_on_conflict
}

# on conflict condition type for table "groupQuestion"
input groupQuestion_on_conflict {
  constraint: groupQuestion_constraint!
  update_columns: [groupQuestion_update_column!]!
  where: groupQuestion_bool_exp
}

# ordering options when selecting data from "groupQuestion"
input groupQuestion_order_by {
  group: group_order_by
  groupId: order_by
  question: question_order_by
  questionId: order_by
}

# primary key columns input for table: "groupQuestion"
input groupQuestion_pk_columns_input {
  groupId: uuid!
  questionId: Int!
}

# select columns of table "groupQuestion"
enum groupQuestion_select_column {
  # column name
  groupId

  # column name
  questionId
}

# input type for updating data in table "groupQuestion"
input groupQuestion_set_input {
  groupId: uuid
  questionId: Int
}

# aggregate stddev on columns
type groupQuestion_stddev_fields {
  questionId: Float
}

# order by stddev() on columns of table "groupQuestion"
input groupQuestion_stddev_order_by {
  questionId: order_by
}

# aggregate stddev_pop on columns
type groupQuestion_stddev_pop_fields {
  questionId: Float
}

# order by stddev_pop() on columns of table "groupQuestion"
input groupQuestion_stddev_pop_order_by {
  questionId: order_by
}

# aggregate stddev_samp on columns
type groupQuestion_stddev_samp_fields {
  questionId: Float
}

# order by stddev_samp() on columns of table "groupQuestion"
input groupQuestion_stddev_samp_order_by {
  questionId: order_by
}

# aggregate sum on columns
type groupQuestion_sum_fields {
  questionId: Int
}

# order by sum() on columns of table "groupQuestion"
input groupQuestion_sum_order_by {
  questionId: order_by
}

# update columns of table "groupQuestion"
enum groupQuestion_update_column {
  # column name
  groupId

  # column name
  questionId
}

# aggregate var_pop on columns
type groupQuestion_var_pop_fields {
  questionId: Float
}

# order by var_pop() on columns of table "groupQuestion"
input groupQuestion_var_pop_order_by {
  questionId: order_by
}

# aggregate var_samp on columns
type groupQuestion_var_samp_fields {
  questionId: Float
}

# order by var_samp() on columns of table "groupQuestion"
input groupQuestion_var_samp_order_by {
  questionId: order_by
}

# aggregate variance on columns
type groupQuestion_variance_fields {
  questionId: Float
}

# order by variance() on columns of table "groupQuestion"
input groupQuestion_variance_order_by {
  questionId: order_by
}

# columns and relationships of "groupTrophy"
type groupTrophy {
  # An object relationship
  group: group!
  groupId: uuid!

  # An object relationship
  trophy: trophy!
  trophyId: uuid!
}

# aggregated selection of "groupTrophy"
type groupTrophy_aggregate {
  aggregate: groupTrophy_aggregate_fields
  nodes: [groupTrophy!]!
}

# aggregate fields of "groupTrophy"
type groupTrophy_aggregate_fields {
  count(columns: [groupTrophy_select_column!], distinct: Boolean): Int
  max: groupTrophy_max_fields
  min: groupTrophy_min_fields
}

# order by aggregate values of table "groupTrophy"
input groupTrophy_aggregate_order_by {
  count: order_by
  max: groupTrophy_max_order_by
  min: groupTrophy_min_order_by
}

# input type for inserting array relation for remote table "groupTrophy"
input groupTrophy_arr_rel_insert_input {
  data: [groupTrophy_insert_input!]!
  on_conflict: groupTrophy_on_conflict
}

# Boolean expression to filter rows from the table "groupTrophy". All fields are combined with a logical 'AND'.
input groupTrophy_bool_exp {
  _and: [groupTrophy_bool_exp]
  _not: groupTrophy_bool_exp
  _or: [groupTrophy_bool_exp]
  group: group_bool_exp
  groupId: uuid_comparison_exp
  trophy: trophy_bool_exp
  trophyId: uuid_comparison_exp
}

# unique or primary key constraints on table "groupTrophy"
enum groupTrophy_constraint {
  # unique or primary key constraint
  groupTrophy_pkey
}

# input type for inserting data into table "groupTrophy"
input groupTrophy_insert_input {
  group: group_obj_rel_insert_input
  groupId: uuid
  trophy: trophy_obj_rel_insert_input
  trophyId: uuid
}

# aggregate max on columns
type groupTrophy_max_fields {
  groupId: uuid
  trophyId: uuid
}

# order by max() on columns of table "groupTrophy"
input groupTrophy_max_order_by {
  groupId: order_by
  trophyId: order_by
}

# aggregate min on columns
type groupTrophy_min_fields {
  groupId: uuid
  trophyId: uuid
}

# order by min() on columns of table "groupTrophy"
input groupTrophy_min_order_by {
  groupId: order_by
  trophyId: order_by
}

# response of any mutation on the table "groupTrophy"
type groupTrophy_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [groupTrophy!]!
}

# input type for inserting object relation for remote table "groupTrophy"
input groupTrophy_obj_rel_insert_input {
  data: groupTrophy_insert_input!
  on_conflict: groupTrophy_on_conflict
}

# on conflict condition type for table "groupTrophy"
input groupTrophy_on_conflict {
  constraint: groupTrophy_constraint!
  update_columns: [groupTrophy_update_column!]!
  where: groupTrophy_bool_exp
}

# ordering options when selecting data from "groupTrophy"
input groupTrophy_order_by {
  group: group_order_by
  groupId: order_by
  trophy: trophy_order_by
  trophyId: order_by
}

# primary key columns input for table: "groupTrophy"
input groupTrophy_pk_columns_input {
  groupId: uuid!
  trophyId: uuid!
}

# select columns of table "groupTrophy"
enum groupTrophy_select_column {
  # column name
  groupId

  # column name
  trophyId
}

# input type for updating data in table "groupTrophy"
input groupTrophy_set_input {
  groupId: uuid
  trophyId: uuid
}

# update columns of table "groupTrophy"
enum groupTrophy_update_column {
  # column name
  groupId

  # column name
  trophyId
}

# expression to compare columns of type Int. All fields are combined with logical 'AND'.
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

# columns and relationships of "interest"
type interest {
  aliases(
    # JSON select path
    path: String
  ): jsonb!

  # An array relationship
  groupInterests(
    # distinct select on columns
    distinct_on: [groupInterest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupInterest_order_by!]

    # filter the rows returned
    where: groupInterest_bool_exp
  ): [groupInterest!]!

  # An aggregated array relationship
  groupInterests_aggregate(
    # distinct select on columns
    distinct_on: [groupInterest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupInterest_order_by!]

    # filter the rows returned
    where: groupInterest_bool_exp
  ): groupInterest_aggregate!
  id: Int!
  name: String!

  # An array relationship
  userInterests(
    # distinct select on columns
    distinct_on: [userInterest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userInterest_order_by!]

    # filter the rows returned
    where: userInterest_bool_exp
  ): [userInterest!]!

  # An aggregated array relationship
  userInterests_aggregate(
    # distinct select on columns
    distinct_on: [userInterest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userInterest_order_by!]

    # filter the rows returned
    where: userInterest_bool_exp
  ): userInterest_aggregate!
}

# aggregated selection of "interest"
type interest_aggregate {
  aggregate: interest_aggregate_fields
  nodes: [interest!]!
}

# aggregate fields of "interest"
type interest_aggregate_fields {
  avg: interest_avg_fields
  count(columns: [interest_select_column!], distinct: Boolean): Int
  max: interest_max_fields
  min: interest_min_fields
  stddev: interest_stddev_fields
  stddev_pop: interest_stddev_pop_fields
  stddev_samp: interest_stddev_samp_fields
  sum: interest_sum_fields
  var_pop: interest_var_pop_fields
  var_samp: interest_var_samp_fields
  variance: interest_variance_fields
}

# order by aggregate values of table "interest"
input interest_aggregate_order_by {
  avg: interest_avg_order_by
  count: order_by
  max: interest_max_order_by
  min: interest_min_order_by
  stddev: interest_stddev_order_by
  stddev_pop: interest_stddev_pop_order_by
  stddev_samp: interest_stddev_samp_order_by
  sum: interest_sum_order_by
  var_pop: interest_var_pop_order_by
  var_samp: interest_var_samp_order_by
  variance: interest_variance_order_by
}

# append existing jsonb value of filtered columns with new jsonb value
input interest_append_input {
  aliases: jsonb
}

# input type for inserting array relation for remote table "interest"
input interest_arr_rel_insert_input {
  data: [interest_insert_input!]!
  on_conflict: interest_on_conflict
}

# aggregate avg on columns
type interest_avg_fields {
  id: Float
}

# order by avg() on columns of table "interest"
input interest_avg_order_by {
  id: order_by
}

# Boolean expression to filter rows from the table "interest". All fields are combined with a logical 'AND'.
input interest_bool_exp {
  _and: [interest_bool_exp]
  _not: interest_bool_exp
  _or: [interest_bool_exp]
  aliases: jsonb_comparison_exp
  groupInterests: groupInterest_bool_exp
  id: Int_comparison_exp
  name: String_comparison_exp
  userInterests: userInterest_bool_exp
}

# unique or primary key constraints on table "interest"
enum interest_constraint {
  # unique or primary key constraint
  interest_id_key

  # unique or primary key constraint
  interests_pkey
}

# delete the field or element with specified path (for JSON arrays, negative integers count from the end)
input interest_delete_at_path_input {
  aliases: [String]
}

# delete the array element with specified index (negative integers count from the
# end). throws an error if top level container is not an array
input interest_delete_elem_input {
  aliases: Int
}

# delete key/value pair or string element. key/value pairs are matched based on their key value
input interest_delete_key_input {
  aliases: String
}

# input type for incrementing integer column in table "interest"
input interest_inc_input {
  id: Int
}

# input type for inserting data into table "interest"
input interest_insert_input {
  aliases: jsonb
  groupInterests: groupInterest_arr_rel_insert_input
  id: Int
  name: String
  userInterests: userInterest_arr_rel_insert_input
}

# aggregate max on columns
type interest_max_fields {
  id: Int
  name: String
}

# order by max() on columns of table "interest"
input interest_max_order_by {
  id: order_by
  name: order_by
}

# aggregate min on columns
type interest_min_fields {
  id: Int
  name: String
}

# order by min() on columns of table "interest"
input interest_min_order_by {
  id: order_by
  name: order_by
}

# response of any mutation on the table "interest"
type interest_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [interest!]!
}

# input type for inserting object relation for remote table "interest"
input interest_obj_rel_insert_input {
  data: interest_insert_input!
  on_conflict: interest_on_conflict
}

# on conflict condition type for table "interest"
input interest_on_conflict {
  constraint: interest_constraint!
  update_columns: [interest_update_column!]!
  where: interest_bool_exp
}

# ordering options when selecting data from "interest"
input interest_order_by {
  aliases: order_by
  groupInterests_aggregate: groupInterest_aggregate_order_by
  id: order_by
  name: order_by
  userInterests_aggregate: userInterest_aggregate_order_by
}

# primary key columns input for table: "interest"
input interest_pk_columns_input {
  name: String!
}

# prepend existing jsonb value of filtered columns with new jsonb value
input interest_prepend_input {
  aliases: jsonb
}

# select columns of table "interest"
enum interest_select_column {
  # column name
  aliases

  # column name
  id

  # column name
  name
}

# input type for updating data in table "interest"
input interest_set_input {
  aliases: jsonb
  id: Int
  name: String
}

# aggregate stddev on columns
type interest_stddev_fields {
  id: Float
}

# order by stddev() on columns of table "interest"
input interest_stddev_order_by {
  id: order_by
}

# aggregate stddev_pop on columns
type interest_stddev_pop_fields {
  id: Float
}

# order by stddev_pop() on columns of table "interest"
input interest_stddev_pop_order_by {
  id: order_by
}

# aggregate stddev_samp on columns
type interest_stddev_samp_fields {
  id: Float
}

# order by stddev_samp() on columns of table "interest"
input interest_stddev_samp_order_by {
  id: order_by
}

# aggregate sum on columns
type interest_sum_fields {
  id: Int
}

# order by sum() on columns of table "interest"
input interest_sum_order_by {
  id: order_by
}

# update columns of table "interest"
enum interest_update_column {
  # column name
  aliases

  # column name
  id

  # column name
  name
}

# aggregate var_pop on columns
type interest_var_pop_fields {
  id: Float
}

# order by var_pop() on columns of table "interest"
input interest_var_pop_order_by {
  id: order_by
}

# aggregate var_samp on columns
type interest_var_samp_fields {
  id: Float
}

# order by var_samp() on columns of table "interest"
input interest_var_samp_order_by {
  id: order_by
}

# aggregate variance on columns
type interest_variance_fields {
  id: Float
}

# order by variance() on columns of table "interest"
input interest_variance_order_by {
  id: order_by
}

scalar jsonb

# expression to compare columns of type jsonb. All fields are combined with logical 'AND'.
input jsonb_comparison_exp {
  # is the column contained in the given json value
  _contained_in: jsonb

  # does the column contain the given json value at the top level
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  # does the string exist as a top-level key in the column
  _has_key: String

  # do all of these strings exist as top-level keys in the column
  _has_keys_all: [String!]

  # do any of these strings exist as top-level keys in the column
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

# columns and relationships of "like"
type like {
  id: Int!

  # An object relationship
  post: post!
  postId: Int!

  # An object relationship
  user: user!
  userId: String!
}

# aggregated selection of "like"
type like_aggregate {
  aggregate: like_aggregate_fields
  nodes: [like!]!
}

# aggregate fields of "like"
type like_aggregate_fields {
  avg: like_avg_fields
  count(columns: [like_select_column!], distinct: Boolean): Int
  max: like_max_fields
  min: like_min_fields
  stddev: like_stddev_fields
  stddev_pop: like_stddev_pop_fields
  stddev_samp: like_stddev_samp_fields
  sum: like_sum_fields
  var_pop: like_var_pop_fields
  var_samp: like_var_samp_fields
  variance: like_variance_fields
}

# order by aggregate values of table "like"
input like_aggregate_order_by {
  avg: like_avg_order_by
  count: order_by
  max: like_max_order_by
  min: like_min_order_by
  stddev: like_stddev_order_by
  stddev_pop: like_stddev_pop_order_by
  stddev_samp: like_stddev_samp_order_by
  sum: like_sum_order_by
  var_pop: like_var_pop_order_by
  var_samp: like_var_samp_order_by
  variance: like_variance_order_by
}

# input type for inserting array relation for remote table "like"
input like_arr_rel_insert_input {
  data: [like_insert_input!]!
  on_conflict: like_on_conflict
}

# aggregate avg on columns
type like_avg_fields {
  id: Float
  postId: Float
}

# order by avg() on columns of table "like"
input like_avg_order_by {
  id: order_by
  postId: order_by
}

# Boolean expression to filter rows from the table "like". All fields are combined with a logical 'AND'.
input like_bool_exp {
  _and: [like_bool_exp]
  _not: like_bool_exp
  _or: [like_bool_exp]
  id: Int_comparison_exp
  post: post_bool_exp
  postId: Int_comparison_exp
  user: user_bool_exp
  userId: String_comparison_exp
}

# unique or primary key constraints on table "like"
enum like_constraint {
  # unique or primary key constraint
  like_id_key

  # unique or primary key constraint
  like_pkey
}

# input type for incrementing integer column in table "like"
input like_inc_input {
  id: Int
  postId: Int
}

# input type for inserting data into table "like"
input like_insert_input {
  id: Int
  post: post_obj_rel_insert_input
  postId: Int
  user: user_obj_rel_insert_input
  userId: String
}

# aggregate max on columns
type like_max_fields {
  id: Int
  postId: Int
  userId: String
}

# order by max() on columns of table "like"
input like_max_order_by {
  id: order_by
  postId: order_by
  userId: order_by
}

# aggregate min on columns
type like_min_fields {
  id: Int
  postId: Int
  userId: String
}

# order by min() on columns of table "like"
input like_min_order_by {
  id: order_by
  postId: order_by
  userId: order_by
}

# response of any mutation on the table "like"
type like_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [like!]!
}

# input type for inserting object relation for remote table "like"
input like_obj_rel_insert_input {
  data: like_insert_input!
  on_conflict: like_on_conflict
}

# on conflict condition type for table "like"
input like_on_conflict {
  constraint: like_constraint!
  update_columns: [like_update_column!]!
  where: like_bool_exp
}

# ordering options when selecting data from "like"
input like_order_by {
  id: order_by
  post: post_order_by
  postId: order_by
  user: user_order_by
  userId: order_by
}

# primary key columns input for table: "like"
input like_pk_columns_input {
  postId: Int!
  userId: String!
}

# select columns of table "like"
enum like_select_column {
  # column name
  id

  # column name
  postId

  # column name
  userId
}

# input type for updating data in table "like"
input like_set_input {
  id: Int
  postId: Int
  userId: String
}

# aggregate stddev on columns
type like_stddev_fields {
  id: Float
  postId: Float
}

# order by stddev() on columns of table "like"
input like_stddev_order_by {
  id: order_by
  postId: order_by
}

# aggregate stddev_pop on columns
type like_stddev_pop_fields {
  id: Float
  postId: Float
}

# order by stddev_pop() on columns of table "like"
input like_stddev_pop_order_by {
  id: order_by
  postId: order_by
}

# aggregate stddev_samp on columns
type like_stddev_samp_fields {
  id: Float
  postId: Float
}

# order by stddev_samp() on columns of table "like"
input like_stddev_samp_order_by {
  id: order_by
  postId: order_by
}

# aggregate sum on columns
type like_sum_fields {
  id: Int
  postId: Int
}

# order by sum() on columns of table "like"
input like_sum_order_by {
  id: order_by
  postId: order_by
}

# update columns of table "like"
enum like_update_column {
  # column name
  id

  # column name
  postId

  # column name
  userId
}

# aggregate var_pop on columns
type like_var_pop_fields {
  id: Float
  postId: Float
}

# order by var_pop() on columns of table "like"
input like_var_pop_order_by {
  id: order_by
  postId: order_by
}

# aggregate var_samp on columns
type like_var_samp_fields {
  id: Float
  postId: Float
}

# order by var_samp() on columns of table "like"
input like_var_samp_order_by {
  id: order_by
  postId: order_by
}

# aggregate variance on columns
type like_variance_fields {
  id: Float
  postId: Float
}

# order by variance() on columns of table "like"
input like_variance_order_by {
  id: order_by
  postId: order_by
}

# columns and relationships of "message"
type message {
  body: String!

  # An object relationship
  chat: chat!
  chatId: Int!
  date: timestamptz!
  id: Int!

  # An object relationship
  sender: user!
  senderId: String!
}

# aggregated selection of "message"
type message_aggregate {
  aggregate: message_aggregate_fields
  nodes: [message!]!
}

# aggregate fields of "message"
type message_aggregate_fields {
  avg: message_avg_fields
  count(columns: [message_select_column!], distinct: Boolean): Int
  max: message_max_fields
  min: message_min_fields
  stddev: message_stddev_fields
  stddev_pop: message_stddev_pop_fields
  stddev_samp: message_stddev_samp_fields
  sum: message_sum_fields
  var_pop: message_var_pop_fields
  var_samp: message_var_samp_fields
  variance: message_variance_fields
}

# order by aggregate values of table "message"
input message_aggregate_order_by {
  avg: message_avg_order_by
  count: order_by
  max: message_max_order_by
  min: message_min_order_by
  stddev: message_stddev_order_by
  stddev_pop: message_stddev_pop_order_by
  stddev_samp: message_stddev_samp_order_by
  sum: message_sum_order_by
  var_pop: message_var_pop_order_by
  var_samp: message_var_samp_order_by
  variance: message_variance_order_by
}

# input type for inserting array relation for remote table "message"
input message_arr_rel_insert_input {
  data: [message_insert_input!]!
  on_conflict: message_on_conflict
}

# aggregate avg on columns
type message_avg_fields {
  chatId: Float
  id: Float
}

# order by avg() on columns of table "message"
input message_avg_order_by {
  chatId: order_by
  id: order_by
}

# Boolean expression to filter rows from the table "message". All fields are combined with a logical 'AND'.
input message_bool_exp {
  _and: [message_bool_exp]
  _not: message_bool_exp
  _or: [message_bool_exp]
  body: String_comparison_exp
  chat: chat_bool_exp
  chatId: Int_comparison_exp
  date: timestamptz_comparison_exp
  id: Int_comparison_exp
  sender: user_bool_exp
  senderId: String_comparison_exp
}

# unique or primary key constraints on table "message"
enum message_constraint {
  # unique or primary key constraint
  message_pkey
}

# input type for incrementing integer column in table "message"
input message_inc_input {
  chatId: Int
  id: Int
}

# input type for inserting data into table "message"
input message_insert_input {
  body: String
  chat: chat_obj_rel_insert_input
  chatId: Int
  date: timestamptz
  id: Int
  sender: user_obj_rel_insert_input
  senderId: String
}

# aggregate max on columns
type message_max_fields {
  body: String
  chatId: Int
  date: timestamptz
  id: Int
  senderId: String
}

# order by max() on columns of table "message"
input message_max_order_by {
  body: order_by
  chatId: order_by
  date: order_by
  id: order_by
  senderId: order_by
}

# aggregate min on columns
type message_min_fields {
  body: String
  chatId: Int
  date: timestamptz
  id: Int
  senderId: String
}

# order by min() on columns of table "message"
input message_min_order_by {
  body: order_by
  chatId: order_by
  date: order_by
  id: order_by
  senderId: order_by
}

# response of any mutation on the table "message"
type message_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [message!]!
}

# input type for inserting object relation for remote table "message"
input message_obj_rel_insert_input {
  data: message_insert_input!
  on_conflict: message_on_conflict
}

# on conflict condition type for table "message"
input message_on_conflict {
  constraint: message_constraint!
  update_columns: [message_update_column!]!
  where: message_bool_exp
}

# ordering options when selecting data from "message"
input message_order_by {
  body: order_by
  chat: chat_order_by
  chatId: order_by
  date: order_by
  id: order_by
  sender: user_order_by
  senderId: order_by
}

# primary key columns input for table: "message"
input message_pk_columns_input {
  id: Int!
}

# select columns of table "message"
enum message_select_column {
  # column name
  body

  # column name
  chatId

  # column name
  date

  # column name
  id

  # column name
  senderId
}

# input type for updating data in table "message"
input message_set_input {
  body: String
  chatId: Int
  date: timestamptz
  id: Int
  senderId: String
}

# aggregate stddev on columns
type message_stddev_fields {
  chatId: Float
  id: Float
}

# order by stddev() on columns of table "message"
input message_stddev_order_by {
  chatId: order_by
  id: order_by
}

# aggregate stddev_pop on columns
type message_stddev_pop_fields {
  chatId: Float
  id: Float
}

# order by stddev_pop() on columns of table "message"
input message_stddev_pop_order_by {
  chatId: order_by
  id: order_by
}

# aggregate stddev_samp on columns
type message_stddev_samp_fields {
  chatId: Float
  id: Float
}

# order by stddev_samp() on columns of table "message"
input message_stddev_samp_order_by {
  chatId: order_by
  id: order_by
}

# aggregate sum on columns
type message_sum_fields {
  chatId: Int
  id: Int
}

# order by sum() on columns of table "message"
input message_sum_order_by {
  chatId: order_by
  id: order_by
}

# update columns of table "message"
enum message_update_column {
  # column name
  body

  # column name
  chatId

  # column name
  date

  # column name
  id

  # column name
  senderId
}

# aggregate var_pop on columns
type message_var_pop_fields {
  chatId: Float
  id: Float
}

# order by var_pop() on columns of table "message"
input message_var_pop_order_by {
  chatId: order_by
  id: order_by
}

# aggregate var_samp on columns
type message_var_samp_fields {
  chatId: Float
  id: Float
}

# order by var_samp() on columns of table "message"
input message_var_samp_order_by {
  chatId: order_by
  id: order_by
}

# aggregate variance on columns
type message_variance_fields {
  chatId: Float
  id: Float
}

# order by variance() on columns of table "message"
input message_variance_order_by {
  chatId: order_by
  id: order_by
}

# mutation root
type mutation_root {
  # insert a single row into the table: "friend"
  addFriend(
    # the row to be inserted
    object: friend_insert_input!

    # on conflict condition
    on_conflict: friend_on_conflict
  ): friend

  # insert a single row into the table: "groupEvent"
  addHostToEvent(
    # the row to be inserted
    object: groupEvent_insert_input!

    # on conflict condition
    on_conflict: groupEvent_on_conflict
  ): groupEvent

  # insert a single row into the table: "userInterest"
  addInterestForUser(
    # the row to be inserted
    object: userInterest_insert_input!

    # on conflict condition
    on_conflict: userInterest_on_conflict
  ): userInterest

  # insert a single row into the table: "eventQuestion"
  addQuestionToEvent(
    # the row to be inserted
    object: eventQuestion_insert_input!

    # on conflict condition
    on_conflict: eventQuestion_on_conflict
  ): eventQuestion

  # insert a single row into the table: "groupQuestion"
  addQuestionToGroup(
    # the row to be inserted
    object: groupQuestion_insert_input!

    # on conflict condition
    on_conflict: groupQuestion_on_conflict
  ): groupQuestion

  # insert a single row into the table: "groupInterest"
  addTagToGroup(
    # the row to be inserted
    object: groupInterest_insert_input!

    # on conflict condition
    on_conflict: groupInterest_on_conflict
  ): groupInterest

  # insert data into the table: "groupTrophy"
  awardTrophies(
    # the rows to be inserted
    objects: [groupTrophy_insert_input!]!

    # on conflict condition
    on_conflict: groupTrophy_on_conflict
  ): groupTrophy_mutation_response

  # insert a single row into the table: "groupTrophy"
  awardTrophy(
    # the row to be inserted
    object: groupTrophy_insert_input!

    # on conflict condition
    on_conflict: groupTrophy_on_conflict
  ): groupTrophy

  # insert a single row into the table: "block"
  blockUser(
    # the row to be inserted
    object: block_insert_input!

    # on conflict condition
    on_conflict: block_on_conflict
  ): block

  # update single row of the table: "userEvent"
  confirmEventInvite(
    # sets the columns of the filtered rows to the given values
    _set: userEvent_set_input
    pk_columns: userEvent_pk_columns_input!
  ): userEvent

  # insert a single row into the table: "chat"
  createChat(
    # the row to be inserted
    object: chat_insert_input!

    # on conflict condition
    on_conflict: chat_on_conflict
  ): chat

  # insert a single row into the table: "event"
  createEvent(
    # the row to be inserted
    object: event_insert_input!

    # on conflict condition
    on_conflict: event_on_conflict
  ): event

  # insert a single row into the table: "group"
  createGroup(
    # the row to be inserted
    object: group_insert_input!

    # on conflict condition
    on_conflict: group_on_conflict
  ): group

  # insert a single row into the table: "review"
  createReview(
    # the row to be inserted
    object: review_insert_input!

    # on conflict condition
    on_conflict: review_on_conflict
  ): review

  # insert a single row into the table: "user"
  createUser(
    # the row to be inserted
    object: user_insert_input!

    # on conflict condition
    on_conflict: user_on_conflict
  ): user

  # delete single row from the table: "chat"
  deleteChat(id: Int!): chat

  # delete single row from the table: "event"
  deleteEvent(id: uuid!): event

  # delete single row from the table: "friendRequest"
  deleteFriendRequest(recipient: String!, sender: String!): friendRequest

  # delete single row from the table: "group"
  deleteGroup(id: uuid!): group

  # delete single row from the table: "notification"
  deleteNotification(id: Int!): notification

  # delete single row from the table: "review"
  deleteReview(id: Int!): review

  # delete single row from the table: "user"
  deleteUser(id: String!): user

  # delete single row from the table: "block"
  delete_block_by_pk(blockedId: String!, blockerId: String!): block

  # delete data from the table: "bug"
  delete_bug(
    # filter the rows which have to be deleted
    where: bug_bool_exp!
  ): bug_mutation_response

  # delete single row from the table: "bug"
  delete_bug_by_pk(reporter: String!): bug

  # delete data from the table: "chat"
  delete_chat(
    # filter the rows which have to be deleted
    where: chat_bool_exp!
  ): chat_mutation_response

  # delete data from the table: "comment"
  delete_comment(
    # filter the rows which have to be deleted
    where: comment_bool_exp!
  ): comment_mutation_response

  # delete single row from the table: "comment"
  delete_comment_by_pk(id: Int!): comment

  # delete data from the table: "event"
  delete_event(
    # filter the rows which have to be deleted
    where: event_bool_exp!
  ): event_mutation_response

  # delete data from the table: "eventQuestion"
  delete_eventQuestion(
    # filter the rows which have to be deleted
    where: eventQuestion_bool_exp!
  ): eventQuestion_mutation_response

  # delete data from the table: "friend"
  delete_friend(
    # filter the rows which have to be deleted
    where: friend_bool_exp!
  ): friend_mutation_response

  # delete data from the table: "friendRequest"
  delete_friendRequest(
    # filter the rows which have to be deleted
    where: friendRequest_bool_exp!
  ): friendRequest_mutation_response

  # delete data from the table: "group"
  delete_group(
    # filter the rows which have to be deleted
    where: group_bool_exp!
  ): group_mutation_response

  # delete data from the table: "groupChats"
  delete_groupChats(
    # filter the rows which have to be deleted
    where: groupChats_bool_exp!
  ): groupChats_mutation_response

  # delete single row from the table: "groupChats"
  delete_groupChats_by_pk(chatId: Int!, groupId: uuid!): groupChats

  # delete data from the table: "groupEvent"
  delete_groupEvent(
    # filter the rows which have to be deleted
    where: groupEvent_bool_exp!
  ): groupEvent_mutation_response

  # delete data from the table: "groupInterest"
  delete_groupInterest(
    # filter the rows which have to be deleted
    where: groupInterest_bool_exp!
  ): groupInterest_mutation_response

  # delete data from the table: "groupQuestion"
  delete_groupQuestion(
    # filter the rows which have to be deleted
    where: groupQuestion_bool_exp!
  ): groupQuestion_mutation_response

  # delete data from the table: "groupTrophy"
  delete_groupTrophy(
    # filter the rows which have to be deleted
    where: groupTrophy_bool_exp!
  ): groupTrophy_mutation_response

  # delete data from the table: "interest"
  delete_interest(
    # filter the rows which have to be deleted
    where: interest_bool_exp!
  ): interest_mutation_response

  # delete single row from the table: "interest"
  delete_interest_by_pk(name: String!): interest

  # delete data from the table: "like"
  delete_like(
    # filter the rows which have to be deleted
    where: like_bool_exp!
  ): like_mutation_response

  # delete single row from the table: "like"
  delete_like_by_pk(postId: Int!, userId: String!): like

  # delete data from the table: "message"
  delete_message(
    # filter the rows which have to be deleted
    where: message_bool_exp!
  ): message_mutation_response

  # delete single row from the table: "message"
  delete_message_by_pk(id: Int!): message

  # delete data from the table: "notification"
  delete_notification(
    # filter the rows which have to be deleted
    where: notification_bool_exp!
  ): notification_mutation_response

  # delete data from the table: "post"
  delete_post(
    # filter the rows which have to be deleted
    where: post_bool_exp!
  ): post_mutation_response

  # delete single row from the table: "post"
  delete_post_by_pk(id: Int!): post

  # delete data from the table: "program"
  delete_program(
    # filter the rows which have to be deleted
    where: program_bool_exp!
  ): program_mutation_response

  # delete single row from the table: "program"
  delete_program_by_pk(name: String!): program

  # delete data from the table: "question"
  delete_question(
    # filter the rows which have to be deleted
    where: question_bool_exp!
  ): question_mutation_response

  # delete single row from the table: "question"
  delete_question_by_pk(id: Int!): question

  # delete data from the table: "report"
  delete_report(
    # filter the rows which have to be deleted
    where: report_bool_exp!
  ): report_mutation_response

  # delete data from the table: "review"
  delete_review(
    # filter the rows which have to be deleted
    where: review_bool_exp!
  ): review_mutation_response

  # delete data from the table: "trophy"
  delete_trophy(
    # filter the rows which have to be deleted
    where: trophy_bool_exp!
  ): trophy_mutation_response

  # delete single row from the table: "trophy"
  delete_trophy_by_pk(id: uuid!): trophy

  # delete data from the table: "user"
  delete_user(
    # filter the rows which have to be deleted
    where: user_bool_exp!
  ): user_mutation_response

  # delete data from the table: "userChat"
  delete_userChat(
    # filter the rows which have to be deleted
    where: userChat_bool_exp!
  ): userChat_mutation_response

  # delete data from the table: "userEvent"
  delete_userEvent(
    # filter the rows which have to be deleted
    where: userEvent_bool_exp!
  ): userEvent_mutation_response

  # delete data from the table: "userGroup"
  delete_userGroup(
    # filter the rows which have to be deleted
    where: userGroup_bool_exp!
  ): userGroup_mutation_response

  # delete data from the table: "userInterest"
  delete_userInterest(
    # filter the rows which have to be deleted
    where: userInterest_bool_exp!
  ): userInterest_mutation_response

  # delete data from the table: "userNotification"
  delete_userNotification(
    # filter the rows which have to be deleted
    where: userNotification_bool_exp!
  ): userNotification_mutation_response

  # delete single row from the table: "userNotification"
  delete_userNotification_by_pk(notificationId: Int!, userId: String!): userNotification

  # delete data from the table: "userProgram"
  delete_userProgram(
    # filter the rows which have to be deleted
    where: userProgram_bool_exp!
  ): userProgram_mutation_response

  # insert data into the table: "block"
  insert_block(
    # the rows to be inserted
    objects: [block_insert_input!]!

    # on conflict condition
    on_conflict: block_on_conflict
  ): block_mutation_response

  # insert data into the table: "bug"
  insert_bug(
    # the rows to be inserted
    objects: [bug_insert_input!]!

    # on conflict condition
    on_conflict: bug_on_conflict
  ): bug_mutation_response

  # insert a single row into the table: "bug"
  insert_bug_one(
    # the row to be inserted
    object: bug_insert_input!

    # on conflict condition
    on_conflict: bug_on_conflict
  ): bug

  # insert data into the table: "chat"
  insert_chat(
    # the rows to be inserted
    objects: [chat_insert_input!]!

    # on conflict condition
    on_conflict: chat_on_conflict
  ): chat_mutation_response

  # insert data into the table: "comment"
  insert_comment(
    # the rows to be inserted
    objects: [comment_insert_input!]!

    # on conflict condition
    on_conflict: comment_on_conflict
  ): comment_mutation_response

  # insert a single row into the table: "comment"
  insert_comment_one(
    # the row to be inserted
    object: comment_insert_input!

    # on conflict condition
    on_conflict: comment_on_conflict
  ): comment

  # insert data into the table: "event"
  insert_event(
    # the rows to be inserted
    objects: [event_insert_input!]!

    # on conflict condition
    on_conflict: event_on_conflict
  ): event_mutation_response

  # insert data into the table: "eventQuestion"
  insert_eventQuestion(
    # the rows to be inserted
    objects: [eventQuestion_insert_input!]!

    # on conflict condition
    on_conflict: eventQuestion_on_conflict
  ): eventQuestion_mutation_response

  # insert data into the table: "friend"
  insert_friend(
    # the rows to be inserted
    objects: [friend_insert_input!]!

    # on conflict condition
    on_conflict: friend_on_conflict
  ): friend_mutation_response

  # insert data into the table: "friendRequest"
  insert_friendRequest(
    # the rows to be inserted
    objects: [friendRequest_insert_input!]!

    # on conflict condition
    on_conflict: friendRequest_on_conflict
  ): friendRequest_mutation_response

  # insert data into the table: "group"
  insert_group(
    # the rows to be inserted
    objects: [group_insert_input!]!

    # on conflict condition
    on_conflict: group_on_conflict
  ): group_mutation_response

  # insert data into the table: "groupChats"
  insert_groupChats(
    # the rows to be inserted
    objects: [groupChats_insert_input!]!

    # on conflict condition
    on_conflict: groupChats_on_conflict
  ): groupChats_mutation_response

  # insert a single row into the table: "groupChats"
  insert_groupChats_one(
    # the row to be inserted
    object: groupChats_insert_input!

    # on conflict condition
    on_conflict: groupChats_on_conflict
  ): groupChats

  # insert data into the table: "groupEvent"
  insert_groupEvent(
    # the rows to be inserted
    objects: [groupEvent_insert_input!]!

    # on conflict condition
    on_conflict: groupEvent_on_conflict
  ): groupEvent_mutation_response

  # insert data into the table: "groupInterest"
  insert_groupInterest(
    # the rows to be inserted
    objects: [groupInterest_insert_input!]!

    # on conflict condition
    on_conflict: groupInterest_on_conflict
  ): groupInterest_mutation_response

  # insert data into the table: "groupQuestion"
  insert_groupQuestion(
    # the rows to be inserted
    objects: [groupQuestion_insert_input!]!

    # on conflict condition
    on_conflict: groupQuestion_on_conflict
  ): groupQuestion_mutation_response

  # insert data into the table: "interest"
  insert_interest(
    # the rows to be inserted
    objects: [interest_insert_input!]!

    # on conflict condition
    on_conflict: interest_on_conflict
  ): interest_mutation_response

  # insert a single row into the table: "interest"
  insert_interest_one(
    # the row to be inserted
    object: interest_insert_input!

    # on conflict condition
    on_conflict: interest_on_conflict
  ): interest

  # insert data into the table: "like"
  insert_like(
    # the rows to be inserted
    objects: [like_insert_input!]!

    # on conflict condition
    on_conflict: like_on_conflict
  ): like_mutation_response

  # insert a single row into the table: "like"
  insert_like_one(
    # the row to be inserted
    object: like_insert_input!

    # on conflict condition
    on_conflict: like_on_conflict
  ): like

  # insert data into the table: "message"
  insert_message(
    # the rows to be inserted
    objects: [message_insert_input!]!

    # on conflict condition
    on_conflict: message_on_conflict
  ): message_mutation_response

  # insert data into the table: "notification"
  insert_notification(
    # the rows to be inserted
    objects: [notification_insert_input!]!

    # on conflict condition
    on_conflict: notification_on_conflict
  ): notification_mutation_response

  # insert data into the table: "post"
  insert_post(
    # the rows to be inserted
    objects: [post_insert_input!]!

    # on conflict condition
    on_conflict: post_on_conflict
  ): post_mutation_response

  # insert a single row into the table: "post"
  insert_post_one(
    # the row to be inserted
    object: post_insert_input!

    # on conflict condition
    on_conflict: post_on_conflict
  ): post

  # insert data into the table: "program"
  insert_program(
    # the rows to be inserted
    objects: [program_insert_input!]!

    # on conflict condition
    on_conflict: program_on_conflict
  ): program_mutation_response

  # insert a single row into the table: "program"
  insert_program_one(
    # the row to be inserted
    object: program_insert_input!

    # on conflict condition
    on_conflict: program_on_conflict
  ): program

  # insert data into the table: "question"
  insert_question(
    # the rows to be inserted
    objects: [question_insert_input!]!

    # on conflict condition
    on_conflict: question_on_conflict
  ): question_mutation_response

  # insert a single row into the table: "question"
  insert_question_one(
    # the row to be inserted
    object: question_insert_input!

    # on conflict condition
    on_conflict: question_on_conflict
  ): question

  # insert data into the table: "report"
  insert_report(
    # the rows to be inserted
    objects: [report_insert_input!]!
  ): report_mutation_response

  # insert a single row into the table: "report"
  insert_report_one(
    # the row to be inserted
    object: report_insert_input!
  ): report

  # insert data into the table: "review"
  insert_review(
    # the rows to be inserted
    objects: [review_insert_input!]!

    # on conflict condition
    on_conflict: review_on_conflict
  ): review_mutation_response

  # insert data into the table: "trophy"
  insert_trophy(
    # the rows to be inserted
    objects: [trophy_insert_input!]!

    # on conflict condition
    on_conflict: trophy_on_conflict
  ): trophy_mutation_response

  # insert a single row into the table: "trophy"
  insert_trophy_one(
    # the row to be inserted
    object: trophy_insert_input!

    # on conflict condition
    on_conflict: trophy_on_conflict
  ): trophy

  # insert data into the table: "user"
  insert_user(
    # the rows to be inserted
    objects: [user_insert_input!]!

    # on conflict condition
    on_conflict: user_on_conflict
  ): user_mutation_response

  # insert data into the table: "userChat"
  insert_userChat(
    # the rows to be inserted
    objects: [userChat_insert_input!]!

    # on conflict condition
    on_conflict: userChat_on_conflict
  ): userChat_mutation_response

  # insert data into the table: "userGroup"
  insert_userGroup(
    # the rows to be inserted
    objects: [userGroup_insert_input!]!

    # on conflict condition
    on_conflict: userGroup_on_conflict
  ): userGroup_mutation_response

  # insert data into the table: "userInterest"
  insert_userInterest(
    # the rows to be inserted
    objects: [userInterest_insert_input!]!

    # on conflict condition
    on_conflict: userInterest_on_conflict
  ): userInterest_mutation_response

  # insert data into the table: "userNotification"
  insert_userNotification(
    # the rows to be inserted
    objects: [userNotification_insert_input!]!

    # on conflict condition
    on_conflict: userNotification_on_conflict
  ): userNotification_mutation_response

  # insert a single row into the table: "userNotification"
  insert_userNotification_one(
    # the row to be inserted
    object: userNotification_insert_input!

    # on conflict condition
    on_conflict: userNotification_on_conflict
  ): userNotification

  # insert data into the table: "userProgram"
  insert_userProgram(
    # the rows to be inserted
    objects: [userProgram_insert_input!]!

    # on conflict condition
    on_conflict: userProgram_on_conflict
  ): userProgram_mutation_response

  # insert a single row into the table: "userGroup"
  joinClub(
    # the row to be inserted
    object: userGroup_insert_input!

    # on conflict condition
    on_conflict: userGroup_on_conflict
  ): userGroup

  # delete single row from the table: "userGroup"
  leaveClub(groupId: uuid!, userId: String!): userGroup

  # insert a single row into the table: "userProgram"
  registerUserForProgram(
    # the row to be inserted
    object: userProgram_insert_input!

    # on conflict condition
    on_conflict: userProgram_on_conflict
  ): userProgram

  # delete single row from the table: "friend"
  removeFriend(friendId: String!, userId: String!): friend

  # delete single row from the table: "groupEvent"
  removeHostFromEvent(eventId: uuid!, groupId: uuid!): groupEvent

  # delete single row from the table: "userInterest"
  removeInterestFromUser(interestId: Int!, userId: String!): userInterest

  # delete single row from the table: "eventQuestion"
  removeQuestionFromEvent(eventId: uuid!, questionId: Int!): eventQuestion

  # delete single row from the table: "groupQuestion"
  removeQuestionFromGroup(groupId: uuid!, questionId: Int!): groupQuestion

  # delete single row from the table: "groupInterest"
  removeTagFromGroup(groupId: uuid!, interestId: Int!): groupInterest

  # delete single row from the table: "groupTrophy"
  removeTrophy(groupId: uuid!, trophyId: uuid!): groupTrophy

  # delete single row from the table: "userEvent"
  removeUserFromEvent(eventId: uuid!, userId: String!): userEvent

  # delete single row from the table: "userProgram"
  removeUserFromProgram(programId: Int!, userId: String!): userProgram

  # insert a single row into the table: "friendRequest"
  sendFriendRequest(
    # the row to be inserted
    object: friendRequest_insert_input!

    # on conflict condition
    on_conflict: friendRequest_on_conflict
  ): friendRequest

  # insert a single row into the table: "message"
  sendMessage(
    # the row to be inserted
    object: message_insert_input!

    # on conflict condition
    on_conflict: message_on_conflict
  ): message

  # insert a single row into the table: "notification"
  sendNotification(
    # the row to be inserted
    object: notification_insert_input!

    # on conflict condition
    on_conflict: notification_on_conflict
  ): notification

  # insert a single row into the table: "userEvent"
  signUpUserForEvent(
    # the row to be inserted
    object: userEvent_insert_input!

    # on conflict condition
    on_conflict: userEvent_on_conflict
  ): userEvent

  # insert data into the table: "userEvent"
  signUpUsersForEvent(
    # the rows to be inserted
    objects: [userEvent_insert_input!]!

    # on conflict condition
    on_conflict: userEvent_on_conflict
  ): userEvent_mutation_response

  # insert a single row into the table: "userChat"
  subscribeToChat(
    # the row to be inserted
    object: userChat_insert_input!

    # on conflict condition
    on_conflict: userChat_on_conflict
  ): userChat

  # delete data from the table: "block"
  unblockUser(
    # filter the rows which have to be deleted
    where: block_bool_exp!
  ): block_mutation_response

  # delete single row from the table: "userChat"
  unsubscribeFromChat(chatId: Int!, userId: String!): userChat

  # update single row of the table: "event"
  updateEvent(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: event_append_input

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _delete_at_path: event_delete_at_path_input

    # delete the array element with specified index (negative integers count from
    # the end). throws an error if top level container is not an array
    _delete_elem: event_delete_elem_input

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _delete_key: event_delete_key_input

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: event_prepend_input

    # sets the columns of the filtered rows to the given values
    _set: event_set_input
    pk_columns: event_pk_columns_input!
  ): event

  # update single row of the table: "group"
  updateGroup(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: group_append_input

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _delete_at_path: group_delete_at_path_input

    # delete the array element with specified index (negative integers count from
    # the end). throws an error if top level container is not an array
    _delete_elem: group_delete_elem_input

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _delete_key: group_delete_key_input

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: group_prepend_input

    # sets the columns of the filtered rows to the given values
    _set: group_set_input
    pk_columns: group_pk_columns_input!
  ): group

  # update single row of the table: "user"
  updateUser(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: user_append_input

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _delete_at_path: user_delete_at_path_input

    # delete the array element with specified index (negative integers count from
    # the end). throws an error if top level container is not an array
    _delete_elem: user_delete_elem_input

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _delete_key: user_delete_key_input

    # increments the integer columns with given value of the filtered values
    _inc: user_inc_input

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: user_prepend_input

    # sets the columns of the filtered rows to the given values
    _set: user_set_input
    pk_columns: user_pk_columns_input!
  ): user

  # update single row of the table: "userGroup"
  updateUserGroup(
    # sets the columns of the filtered rows to the given values
    _set: userGroup_set_input
    pk_columns: userGroup_pk_columns_input!
  ): userGroup

  # update data of the table: "block"
  update_block(
    # sets the columns of the filtered rows to the given values
    _set: block_set_input

    # filter the rows which have to be updated
    where: block_bool_exp!
  ): block_mutation_response

  # update single row of the table: "block"
  update_block_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: block_set_input
    pk_columns: block_pk_columns_input!
  ): block

  # update data of the table: "bug"
  update_bug(
    # sets the columns of the filtered rows to the given values
    _set: bug_set_input

    # filter the rows which have to be updated
    where: bug_bool_exp!
  ): bug_mutation_response

  # update single row of the table: "bug"
  update_bug_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: bug_set_input
    pk_columns: bug_pk_columns_input!
  ): bug

  # update data of the table: "chat"
  update_chat(
    # increments the integer columns with given value of the filtered values
    _inc: chat_inc_input

    # sets the columns of the filtered rows to the given values
    _set: chat_set_input

    # filter the rows which have to be updated
    where: chat_bool_exp!
  ): chat_mutation_response

  # update single row of the table: "chat"
  update_chat_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: chat_inc_input

    # sets the columns of the filtered rows to the given values
    _set: chat_set_input
    pk_columns: chat_pk_columns_input!
  ): chat

  # update data of the table: "comment"
  update_comment(
    # increments the integer columns with given value of the filtered values
    _inc: comment_inc_input

    # sets the columns of the filtered rows to the given values
    _set: comment_set_input

    # filter the rows which have to be updated
    where: comment_bool_exp!
  ): comment_mutation_response

  # update single row of the table: "comment"
  update_comment_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: comment_inc_input

    # sets the columns of the filtered rows to the given values
    _set: comment_set_input
    pk_columns: comment_pk_columns_input!
  ): comment

  # update data of the table: "event"
  update_event(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: event_append_input

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _delete_at_path: event_delete_at_path_input

    # delete the array element with specified index (negative integers count from
    # the end). throws an error if top level container is not an array
    _delete_elem: event_delete_elem_input

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _delete_key: event_delete_key_input

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: event_prepend_input

    # sets the columns of the filtered rows to the given values
    _set: event_set_input

    # filter the rows which have to be updated
    where: event_bool_exp!
  ): event_mutation_response

  # update data of the table: "eventQuestion"
  update_eventQuestion(
    # increments the integer columns with given value of the filtered values
    _inc: eventQuestion_inc_input

    # sets the columns of the filtered rows to the given values
    _set: eventQuestion_set_input

    # filter the rows which have to be updated
    where: eventQuestion_bool_exp!
  ): eventQuestion_mutation_response

  # update single row of the table: "eventQuestion"
  update_eventQuestion_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: eventQuestion_inc_input

    # sets the columns of the filtered rows to the given values
    _set: eventQuestion_set_input
    pk_columns: eventQuestion_pk_columns_input!
  ): eventQuestion

  # update data of the table: "friend"
  update_friend(
    # sets the columns of the filtered rows to the given values
    _set: friend_set_input

    # filter the rows which have to be updated
    where: friend_bool_exp!
  ): friend_mutation_response

  # update data of the table: "friendRequest"
  update_friendRequest(
    # sets the columns of the filtered rows to the given values
    _set: friendRequest_set_input

    # filter the rows which have to be updated
    where: friendRequest_bool_exp!
  ): friendRequest_mutation_response

  # update single row of the table: "friendRequest"
  update_friendRequest_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: friendRequest_set_input
    pk_columns: friendRequest_pk_columns_input!
  ): friendRequest

  # update single row of the table: "friend"
  update_friend_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: friend_set_input
    pk_columns: friend_pk_columns_input!
  ): friend

  # update data of the table: "group"
  update_group(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: group_append_input

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _delete_at_path: group_delete_at_path_input

    # delete the array element with specified index (negative integers count from
    # the end). throws an error if top level container is not an array
    _delete_elem: group_delete_elem_input

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _delete_key: group_delete_key_input

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: group_prepend_input

    # sets the columns of the filtered rows to the given values
    _set: group_set_input

    # filter the rows which have to be updated
    where: group_bool_exp!
  ): group_mutation_response

  # update data of the table: "groupChats"
  update_groupChats(
    # increments the integer columns with given value of the filtered values
    _inc: groupChats_inc_input

    # sets the columns of the filtered rows to the given values
    _set: groupChats_set_input

    # filter the rows which have to be updated
    where: groupChats_bool_exp!
  ): groupChats_mutation_response

  # update single row of the table: "groupChats"
  update_groupChats_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: groupChats_inc_input

    # sets the columns of the filtered rows to the given values
    _set: groupChats_set_input
    pk_columns: groupChats_pk_columns_input!
  ): groupChats

  # update data of the table: "groupEvent"
  update_groupEvent(
    # sets the columns of the filtered rows to the given values
    _set: groupEvent_set_input

    # filter the rows which have to be updated
    where: groupEvent_bool_exp!
  ): groupEvent_mutation_response

  # update single row of the table: "groupEvent"
  update_groupEvent_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: groupEvent_set_input
    pk_columns: groupEvent_pk_columns_input!
  ): groupEvent

  # update data of the table: "groupInterest"
  update_groupInterest(
    # increments the integer columns with given value of the filtered values
    _inc: groupInterest_inc_input

    # sets the columns of the filtered rows to the given values
    _set: groupInterest_set_input

    # filter the rows which have to be updated
    where: groupInterest_bool_exp!
  ): groupInterest_mutation_response

  # update single row of the table: "groupInterest"
  update_groupInterest_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: groupInterest_inc_input

    # sets the columns of the filtered rows to the given values
    _set: groupInterest_set_input
    pk_columns: groupInterest_pk_columns_input!
  ): groupInterest

  # update data of the table: "groupQuestion"
  update_groupQuestion(
    # increments the integer columns with given value of the filtered values
    _inc: groupQuestion_inc_input

    # sets the columns of the filtered rows to the given values
    _set: groupQuestion_set_input

    # filter the rows which have to be updated
    where: groupQuestion_bool_exp!
  ): groupQuestion_mutation_response

  # update single row of the table: "groupQuestion"
  update_groupQuestion_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: groupQuestion_inc_input

    # sets the columns of the filtered rows to the given values
    _set: groupQuestion_set_input
    pk_columns: groupQuestion_pk_columns_input!
  ): groupQuestion

  # update data of the table: "groupTrophy"
  update_groupTrophy(
    # sets the columns of the filtered rows to the given values
    _set: groupTrophy_set_input

    # filter the rows which have to be updated
    where: groupTrophy_bool_exp!
  ): groupTrophy_mutation_response

  # update single row of the table: "groupTrophy"
  update_groupTrophy_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: groupTrophy_set_input
    pk_columns: groupTrophy_pk_columns_input!
  ): groupTrophy

  # update data of the table: "interest"
  update_interest(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: interest_append_input

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _delete_at_path: interest_delete_at_path_input

    # delete the array element with specified index (negative integers count from
    # the end). throws an error if top level container is not an array
    _delete_elem: interest_delete_elem_input

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _delete_key: interest_delete_key_input

    # increments the integer columns with given value of the filtered values
    _inc: interest_inc_input

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: interest_prepend_input

    # sets the columns of the filtered rows to the given values
    _set: interest_set_input

    # filter the rows which have to be updated
    where: interest_bool_exp!
  ): interest_mutation_response

  # update single row of the table: "interest"
  update_interest_by_pk(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: interest_append_input

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _delete_at_path: interest_delete_at_path_input

    # delete the array element with specified index (negative integers count from
    # the end). throws an error if top level container is not an array
    _delete_elem: interest_delete_elem_input

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _delete_key: interest_delete_key_input

    # increments the integer columns with given value of the filtered values
    _inc: interest_inc_input

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: interest_prepend_input

    # sets the columns of the filtered rows to the given values
    _set: interest_set_input
    pk_columns: interest_pk_columns_input!
  ): interest

  # update data of the table: "like"
  update_like(
    # increments the integer columns with given value of the filtered values
    _inc: like_inc_input

    # sets the columns of the filtered rows to the given values
    _set: like_set_input

    # filter the rows which have to be updated
    where: like_bool_exp!
  ): like_mutation_response

  # update single row of the table: "like"
  update_like_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: like_inc_input

    # sets the columns of the filtered rows to the given values
    _set: like_set_input
    pk_columns: like_pk_columns_input!
  ): like

  # update data of the table: "message"
  update_message(
    # increments the integer columns with given value of the filtered values
    _inc: message_inc_input

    # sets the columns of the filtered rows to the given values
    _set: message_set_input

    # filter the rows which have to be updated
    where: message_bool_exp!
  ): message_mutation_response

  # update single row of the table: "message"
  update_message_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: message_inc_input

    # sets the columns of the filtered rows to the given values
    _set: message_set_input
    pk_columns: message_pk_columns_input!
  ): message

  # update data of the table: "notification"
  update_notification(
    # increments the integer columns with given value of the filtered values
    _inc: notification_inc_input

    # sets the columns of the filtered rows to the given values
    _set: notification_set_input

    # filter the rows which have to be updated
    where: notification_bool_exp!
  ): notification_mutation_response

  # update single row of the table: "notification"
  update_notification_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: notification_inc_input

    # sets the columns of the filtered rows to the given values
    _set: notification_set_input
    pk_columns: notification_pk_columns_input!
  ): notification

  # update data of the table: "post"
  update_post(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: post_append_input

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _delete_at_path: post_delete_at_path_input

    # delete the array element with specified index (negative integers count from
    # the end). throws an error if top level container is not an array
    _delete_elem: post_delete_elem_input

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _delete_key: post_delete_key_input

    # increments the integer columns with given value of the filtered values
    _inc: post_inc_input

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: post_prepend_input

    # sets the columns of the filtered rows to the given values
    _set: post_set_input

    # filter the rows which have to be updated
    where: post_bool_exp!
  ): post_mutation_response

  # update single row of the table: "post"
  update_post_by_pk(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: post_append_input

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _delete_at_path: post_delete_at_path_input

    # delete the array element with specified index (negative integers count from
    # the end). throws an error if top level container is not an array
    _delete_elem: post_delete_elem_input

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _delete_key: post_delete_key_input

    # increments the integer columns with given value of the filtered values
    _inc: post_inc_input

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: post_prepend_input

    # sets the columns of the filtered rows to the given values
    _set: post_set_input
    pk_columns: post_pk_columns_input!
  ): post

  # update data of the table: "program"
  update_program(
    # increments the integer columns with given value of the filtered values
    _inc: program_inc_input

    # sets the columns of the filtered rows to the given values
    _set: program_set_input

    # filter the rows which have to be updated
    where: program_bool_exp!
  ): program_mutation_response

  # update single row of the table: "program"
  update_program_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: program_inc_input

    # sets the columns of the filtered rows to the given values
    _set: program_set_input
    pk_columns: program_pk_columns_input!
  ): program

  # update data of the table: "question"
  update_question(
    # increments the integer columns with given value of the filtered values
    _inc: question_inc_input

    # sets the columns of the filtered rows to the given values
    _set: question_set_input

    # filter the rows which have to be updated
    where: question_bool_exp!
  ): question_mutation_response

  # update single row of the table: "question"
  update_question_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: question_inc_input

    # sets the columns of the filtered rows to the given values
    _set: question_set_input
    pk_columns: question_pk_columns_input!
  ): question

  # update data of the table: "report"
  update_report(
    # increments the integer columns with given value of the filtered values
    _inc: report_inc_input

    # sets the columns of the filtered rows to the given values
    _set: report_set_input

    # filter the rows which have to be updated
    where: report_bool_exp!
  ): report_mutation_response

  # update data of the table: "review"
  update_review(
    # increments the integer columns with given value of the filtered values
    _inc: review_inc_input

    # sets the columns of the filtered rows to the given values
    _set: review_set_input

    # filter the rows which have to be updated
    where: review_bool_exp!
  ): review_mutation_response

  # update single row of the table: "review"
  update_review_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: review_inc_input

    # sets the columns of the filtered rows to the given values
    _set: review_set_input
    pk_columns: review_pk_columns_input!
  ): review

  # update data of the table: "trophy"
  update_trophy(
    # increments the integer columns with given value of the filtered values
    _inc: trophy_inc_input

    # sets the columns of the filtered rows to the given values
    _set: trophy_set_input

    # filter the rows which have to be updated
    where: trophy_bool_exp!
  ): trophy_mutation_response

  # update single row of the table: "trophy"
  update_trophy_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: trophy_inc_input

    # sets the columns of the filtered rows to the given values
    _set: trophy_set_input
    pk_columns: trophy_pk_columns_input!
  ): trophy

  # update data of the table: "user"
  update_user(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: user_append_input

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _delete_at_path: user_delete_at_path_input

    # delete the array element with specified index (negative integers count from
    # the end). throws an error if top level container is not an array
    _delete_elem: user_delete_elem_input

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _delete_key: user_delete_key_input

    # increments the integer columns with given value of the filtered values
    _inc: user_inc_input

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: user_prepend_input

    # sets the columns of the filtered rows to the given values
    _set: user_set_input

    # filter the rows which have to be updated
    where: user_bool_exp!
  ): user_mutation_response

  # update data of the table: "userChat"
  update_userChat(
    # increments the integer columns with given value of the filtered values
    _inc: userChat_inc_input

    # sets the columns of the filtered rows to the given values
    _set: userChat_set_input

    # filter the rows which have to be updated
    where: userChat_bool_exp!
  ): userChat_mutation_response

  # update single row of the table: "userChat"
  update_userChat_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: userChat_inc_input

    # sets the columns of the filtered rows to the given values
    _set: userChat_set_input
    pk_columns: userChat_pk_columns_input!
  ): userChat

  # update data of the table: "userEvent"
  update_userEvent(
    # sets the columns of the filtered rows to the given values
    _set: userEvent_set_input

    # filter the rows which have to be updated
    where: userEvent_bool_exp!
  ): userEvent_mutation_response

  # update data of the table: "userGroup"
  update_userGroup(
    # sets the columns of the filtered rows to the given values
    _set: userGroup_set_input

    # filter the rows which have to be updated
    where: userGroup_bool_exp!
  ): userGroup_mutation_response

  # update data of the table: "userInterest"
  update_userInterest(
    # increments the integer columns with given value of the filtered values
    _inc: userInterest_inc_input

    # sets the columns of the filtered rows to the given values
    _set: userInterest_set_input

    # filter the rows which have to be updated
    where: userInterest_bool_exp!
  ): userInterest_mutation_response

  # update single row of the table: "userInterest"
  update_userInterest_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: userInterest_inc_input

    # sets the columns of the filtered rows to the given values
    _set: userInterest_set_input
    pk_columns: userInterest_pk_columns_input!
  ): userInterest

  # update data of the table: "userNotification"
  update_userNotification(
    # increments the integer columns with given value of the filtered values
    _inc: userNotification_inc_input

    # sets the columns of the filtered rows to the given values
    _set: userNotification_set_input

    # filter the rows which have to be updated
    where: userNotification_bool_exp!
  ): userNotification_mutation_response

  # update single row of the table: "userNotification"
  update_userNotification_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: userNotification_inc_input

    # sets the columns of the filtered rows to the given values
    _set: userNotification_set_input
    pk_columns: userNotification_pk_columns_input!
  ): userNotification

  # update data of the table: "userProgram"
  update_userProgram(
    # increments the integer columns with given value of the filtered values
    _inc: userProgram_inc_input

    # sets the columns of the filtered rows to the given values
    _set: userProgram_set_input

    # filter the rows which have to be updated
    where: userProgram_bool_exp!
  ): userProgram_mutation_response

  # update single row of the table: "userProgram"
  update_userProgram_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: userProgram_inc_input

    # sets the columns of the filtered rows to the given values
    _set: userProgram_set_input
    pk_columns: userProgram_pk_columns_input!
  ): userProgram
}

# columns and relationships of "notification"
type notification {
  id: Int!
  seen: Boolean!
  timestamp: timestamptz!
  type: String!
  typeId: String!

  # An array relationship
  userNotifications(
    # distinct select on columns
    distinct_on: [userNotification_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userNotification_order_by!]

    # filter the rows returned
    where: userNotification_bool_exp
  ): [userNotification!]!

  # An aggregated array relationship
  userNotifications_aggregate(
    # distinct select on columns
    distinct_on: [userNotification_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userNotification_order_by!]

    # filter the rows returned
    where: userNotification_bool_exp
  ): userNotification_aggregate!
}

# aggregated selection of "notification"
type notification_aggregate {
  aggregate: notification_aggregate_fields
  nodes: [notification!]!
}

# aggregate fields of "notification"
type notification_aggregate_fields {
  avg: notification_avg_fields
  count(columns: [notification_select_column!], distinct: Boolean): Int
  max: notification_max_fields
  min: notification_min_fields
  stddev: notification_stddev_fields
  stddev_pop: notification_stddev_pop_fields
  stddev_samp: notification_stddev_samp_fields
  sum: notification_sum_fields
  var_pop: notification_var_pop_fields
  var_samp: notification_var_samp_fields
  variance: notification_variance_fields
}

# order by aggregate values of table "notification"
input notification_aggregate_order_by {
  avg: notification_avg_order_by
  count: order_by
  max: notification_max_order_by
  min: notification_min_order_by
  stddev: notification_stddev_order_by
  stddev_pop: notification_stddev_pop_order_by
  stddev_samp: notification_stddev_samp_order_by
  sum: notification_sum_order_by
  var_pop: notification_var_pop_order_by
  var_samp: notification_var_samp_order_by
  variance: notification_variance_order_by
}

# input type for inserting array relation for remote table "notification"
input notification_arr_rel_insert_input {
  data: [notification_insert_input!]!
  on_conflict: notification_on_conflict
}

# aggregate avg on columns
type notification_avg_fields {
  id: Float
}

# order by avg() on columns of table "notification"
input notification_avg_order_by {
  id: order_by
}

# Boolean expression to filter rows from the table "notification". All fields are combined with a logical 'AND'.
input notification_bool_exp {
  _and: [notification_bool_exp]
  _not: notification_bool_exp
  _or: [notification_bool_exp]
  id: Int_comparison_exp
  seen: Boolean_comparison_exp
  timestamp: timestamptz_comparison_exp
  type: String_comparison_exp
  typeId: String_comparison_exp
  userNotifications: userNotification_bool_exp
}

# unique or primary key constraints on table "notification"
enum notification_constraint {
  # unique or primary key constraint
  notifications_pkey
}

# input type for incrementing integer column in table "notification"
input notification_inc_input {
  id: Int
}

# input type for inserting data into table "notification"
input notification_insert_input {
  id: Int
  seen: Boolean
  timestamp: timestamptz
  type: String
  typeId: String
  userNotifications: userNotification_arr_rel_insert_input
}

# aggregate max on columns
type notification_max_fields {
  id: Int
  timestamp: timestamptz
  type: String
  typeId: String
}

# order by max() on columns of table "notification"
input notification_max_order_by {
  id: order_by
  timestamp: order_by
  type: order_by
  typeId: order_by
}

# aggregate min on columns
type notification_min_fields {
  id: Int
  timestamp: timestamptz
  type: String
  typeId: String
}

# order by min() on columns of table "notification"
input notification_min_order_by {
  id: order_by
  timestamp: order_by
  type: order_by
  typeId: order_by
}

# response of any mutation on the table "notification"
type notification_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [notification!]!
}

# input type for inserting object relation for remote table "notification"
input notification_obj_rel_insert_input {
  data: notification_insert_input!
  on_conflict: notification_on_conflict
}

# on conflict condition type for table "notification"
input notification_on_conflict {
  constraint: notification_constraint!
  update_columns: [notification_update_column!]!
  where: notification_bool_exp
}

# ordering options when selecting data from "notification"
input notification_order_by {
  id: order_by
  seen: order_by
  timestamp: order_by
  type: order_by
  typeId: order_by
  userNotifications_aggregate: userNotification_aggregate_order_by
}

# primary key columns input for table: "notification"
input notification_pk_columns_input {
  id: Int!
}

# select columns of table "notification"
enum notification_select_column {
  # column name
  id

  # column name
  seen

  # column name
  timestamp

  # column name
  type

  # column name
  typeId
}

# input type for updating data in table "notification"
input notification_set_input {
  id: Int
  seen: Boolean
  timestamp: timestamptz
  type: String
  typeId: String
}

# aggregate stddev on columns
type notification_stddev_fields {
  id: Float
}

# order by stddev() on columns of table "notification"
input notification_stddev_order_by {
  id: order_by
}

# aggregate stddev_pop on columns
type notification_stddev_pop_fields {
  id: Float
}

# order by stddev_pop() on columns of table "notification"
input notification_stddev_pop_order_by {
  id: order_by
}

# aggregate stddev_samp on columns
type notification_stddev_samp_fields {
  id: Float
}

# order by stddev_samp() on columns of table "notification"
input notification_stddev_samp_order_by {
  id: order_by
}

# aggregate sum on columns
type notification_sum_fields {
  id: Int
}

# order by sum() on columns of table "notification"
input notification_sum_order_by {
  id: order_by
}

# update columns of table "notification"
enum notification_update_column {
  # column name
  id

  # column name
  seen

  # column name
  timestamp

  # column name
  type

  # column name
  typeId
}

# aggregate var_pop on columns
type notification_var_pop_fields {
  id: Float
}

# order by var_pop() on columns of table "notification"
input notification_var_pop_order_by {
  id: order_by
}

# aggregate var_samp on columns
type notification_var_samp_fields {
  id: Float
}

# order by var_samp() on columns of table "notification"
input notification_var_samp_order_by {
  id: order_by
}

# aggregate variance on columns
type notification_variance_fields {
  id: Float
}

# order by variance() on columns of table "notification"
input notification_variance_order_by {
  id: order_by
}

# columns and relationships of "notificationTokenView"
type notificationTokenView {
  notificationId: Int
  notificationToken: String
  userId: String
}

# aggregated selection of "notificationTokenView"
type notificationTokenView_aggregate {
  aggregate: notificationTokenView_aggregate_fields
  nodes: [notificationTokenView!]!
}

# aggregate fields of "notificationTokenView"
type notificationTokenView_aggregate_fields {
  avg: notificationTokenView_avg_fields
  count(columns: [notificationTokenView_select_column!], distinct: Boolean): Int
  max: notificationTokenView_max_fields
  min: notificationTokenView_min_fields
  stddev: notificationTokenView_stddev_fields
  stddev_pop: notificationTokenView_stddev_pop_fields
  stddev_samp: notificationTokenView_stddev_samp_fields
  sum: notificationTokenView_sum_fields
  var_pop: notificationTokenView_var_pop_fields
  var_samp: notificationTokenView_var_samp_fields
  variance: notificationTokenView_variance_fields
}

# order by aggregate values of table "notificationTokenView"
input notificationTokenView_aggregate_order_by {
  avg: notificationTokenView_avg_order_by
  count: order_by
  max: notificationTokenView_max_order_by
  min: notificationTokenView_min_order_by
  stddev: notificationTokenView_stddev_order_by
  stddev_pop: notificationTokenView_stddev_pop_order_by
  stddev_samp: notificationTokenView_stddev_samp_order_by
  sum: notificationTokenView_sum_order_by
  var_pop: notificationTokenView_var_pop_order_by
  var_samp: notificationTokenView_var_samp_order_by
  variance: notificationTokenView_variance_order_by
}

# aggregate avg on columns
type notificationTokenView_avg_fields {
  notificationId: Float
}

# order by avg() on columns of table "notificationTokenView"
input notificationTokenView_avg_order_by {
  notificationId: order_by
}

# Boolean expression to filter rows from the table "notificationTokenView". All fields are combined with a logical 'AND'.
input notificationTokenView_bool_exp {
  _and: [notificationTokenView_bool_exp]
  _not: notificationTokenView_bool_exp
  _or: [notificationTokenView_bool_exp]
  notificationId: Int_comparison_exp
  notificationToken: String_comparison_exp
  userId: String_comparison_exp
}

# aggregate max on columns
type notificationTokenView_max_fields {
  notificationId: Int
  notificationToken: String
  userId: String
}

# order by max() on columns of table "notificationTokenView"
input notificationTokenView_max_order_by {
  notificationId: order_by
  notificationToken: order_by
  userId: order_by
}

# aggregate min on columns
type notificationTokenView_min_fields {
  notificationId: Int
  notificationToken: String
  userId: String
}

# order by min() on columns of table "notificationTokenView"
input notificationTokenView_min_order_by {
  notificationId: order_by
  notificationToken: order_by
  userId: order_by
}

# ordering options when selecting data from "notificationTokenView"
input notificationTokenView_order_by {
  notificationId: order_by
  notificationToken: order_by
  userId: order_by
}

# select columns of table "notificationTokenView"
enum notificationTokenView_select_column {
  # column name
  notificationId

  # column name
  notificationToken

  # column name
  userId
}

# aggregate stddev on columns
type notificationTokenView_stddev_fields {
  notificationId: Float
}

# order by stddev() on columns of table "notificationTokenView"
input notificationTokenView_stddev_order_by {
  notificationId: order_by
}

# aggregate stddev_pop on columns
type notificationTokenView_stddev_pop_fields {
  notificationId: Float
}

# order by stddev_pop() on columns of table "notificationTokenView"
input notificationTokenView_stddev_pop_order_by {
  notificationId: order_by
}

# aggregate stddev_samp on columns
type notificationTokenView_stddev_samp_fields {
  notificationId: Float
}

# order by stddev_samp() on columns of table "notificationTokenView"
input notificationTokenView_stddev_samp_order_by {
  notificationId: order_by
}

# aggregate sum on columns
type notificationTokenView_sum_fields {
  notificationId: Int
}

# order by sum() on columns of table "notificationTokenView"
input notificationTokenView_sum_order_by {
  notificationId: order_by
}

# aggregate var_pop on columns
type notificationTokenView_var_pop_fields {
  notificationId: Float
}

# order by var_pop() on columns of table "notificationTokenView"
input notificationTokenView_var_pop_order_by {
  notificationId: order_by
}

# aggregate var_samp on columns
type notificationTokenView_var_samp_fields {
  notificationId: Float
}

# order by var_samp() on columns of table "notificationTokenView"
input notificationTokenView_var_samp_order_by {
  notificationId: order_by
}

# aggregate variance on columns
type notificationTokenView_variance_fields {
  notificationId: Float
}

# order by variance() on columns of table "notificationTokenView"
input notificationTokenView_variance_order_by {
  notificationId: order_by
}

# column ordering options
enum order_by {
  # in the ascending order, nulls last
  asc

  # in the ascending order, nulls first
  asc_nulls_first

  # in the ascending order, nulls last
  asc_nulls_last

  # in the descending order, nulls first
  desc

  # in the descending order, nulls first
  desc_nulls_first

  # in the descending order, nulls last
  desc_nulls_last
}

# Made by Zach so correct if not right
#
#
# columns and relationships of "post"
#
type post {
  authorId: String!

  # An array relationship
  comments(
    # distinct select on columns
    distinct_on: [comment_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [comment_order_by!]

    # filter the rows returned
    where: comment_bool_exp
  ): [comment!]!

  # An aggregated array relationship
  comments_aggregate(
    # distinct select on columns
    distinct_on: [comment_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [comment_order_by!]

    # filter the rows returned
    where: comment_bool_exp
  ): comment_aggregate!

  # An object relationship
  group: group!
  groupId: uuid!
  id: Int!
  images(
    # JSON select path
    path: String
  ): jsonb

  # An array relationship
  likes(
    # distinct select on columns
    distinct_on: [like_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [like_order_by!]

    # filter the rows returned
    where: like_bool_exp
  ): [like!]!

  # An aggregated array relationship
  likes_aggregate(
    # distinct select on columns
    distinct_on: [like_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [like_order_by!]

    # filter the rows returned
    where: like_bool_exp
  ): like_aggregate!
  link: String
  text: String!
  time: timestamptz!

  # An object relationship
  user: user!
}

# aggregated selection of "post"
type post_aggregate {
  aggregate: post_aggregate_fields
  nodes: [post!]!
}

# aggregate fields of "post"
type post_aggregate_fields {
  avg: post_avg_fields
  count(columns: [post_select_column!], distinct: Boolean): Int
  max: post_max_fields
  min: post_min_fields
  stddev: post_stddev_fields
  stddev_pop: post_stddev_pop_fields
  stddev_samp: post_stddev_samp_fields
  sum: post_sum_fields
  var_pop: post_var_pop_fields
  var_samp: post_var_samp_fields
  variance: post_variance_fields
}

# order by aggregate values of table "post"
input post_aggregate_order_by {
  avg: post_avg_order_by
  count: order_by
  max: post_max_order_by
  min: post_min_order_by
  stddev: post_stddev_order_by
  stddev_pop: post_stddev_pop_order_by
  stddev_samp: post_stddev_samp_order_by
  sum: post_sum_order_by
  var_pop: post_var_pop_order_by
  var_samp: post_var_samp_order_by
  variance: post_variance_order_by
}

# append existing jsonb value of filtered columns with new jsonb value
input post_append_input {
  images: jsonb
}

# input type for inserting array relation for remote table "post"
input post_arr_rel_insert_input {
  data: [post_insert_input!]!
  on_conflict: post_on_conflict
}

# aggregate avg on columns
type post_avg_fields {
  id: Float
}

# order by avg() on columns of table "post"
input post_avg_order_by {
  id: order_by
}

# Boolean expression to filter rows from the table "post". All fields are combined with a logical 'AND'.
input post_bool_exp {
  _and: [post_bool_exp]
  _not: post_bool_exp
  _or: [post_bool_exp]
  authorId: String_comparison_exp
  comments: comment_bool_exp
  group: group_bool_exp
  groupId: uuid_comparison_exp
  id: Int_comparison_exp
  images: jsonb_comparison_exp
  likes: like_bool_exp
  link: String_comparison_exp
  text: String_comparison_exp
  time: timestamptz_comparison_exp
  user: user_bool_exp
}

# unique or primary key constraints on table "post"
enum post_constraint {
  # unique or primary key constraint
  post_id_key

  # unique or primary key constraint
  post_pkey
}

# delete the field or element with specified path (for JSON arrays, negative integers count from the end)
input post_delete_at_path_input {
  images: [String]
}

# delete the array element with specified index (negative integers count from the
# end). throws an error if top level container is not an array
input post_delete_elem_input {
  images: Int
}

# delete key/value pair or string element. key/value pairs are matched based on their key value
input post_delete_key_input {
  images: String
}

# input type for incrementing integer column in table "post"
input post_inc_input {
  id: Int
}

# input type for inserting data into table "post"
input post_insert_input {
  authorId: String
  comments: comment_arr_rel_insert_input
  group: group_obj_rel_insert_input
  groupId: uuid
  id: Int
  images: jsonb
  likes: like_arr_rel_insert_input
  link: String
  text: String
  time: timestamptz
  user: user_obj_rel_insert_input
}

# aggregate max on columns
type post_max_fields {
  authorId: String
  groupId: uuid
  id: Int
  link: String
  text: String
  time: timestamptz
}

# order by max() on columns of table "post"
input post_max_order_by {
  authorId: order_by
  groupId: order_by
  id: order_by
  link: order_by
  text: order_by
  time: order_by
}

# aggregate min on columns
type post_min_fields {
  authorId: String
  groupId: uuid
  id: Int
  link: String
  text: String
  time: timestamptz
}

# order by min() on columns of table "post"
input post_min_order_by {
  authorId: order_by
  groupId: order_by
  id: order_by
  link: order_by
  text: order_by
  time: order_by
}

# response of any mutation on the table "post"
type post_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [post!]!
}

# input type for inserting object relation for remote table "post"
input post_obj_rel_insert_input {
  data: post_insert_input!
  on_conflict: post_on_conflict
}

# on conflict condition type for table "post"
input post_on_conflict {
  constraint: post_constraint!
  update_columns: [post_update_column!]!
  where: post_bool_exp
}

# ordering options when selecting data from "post"
input post_order_by {
  authorId: order_by
  comments_aggregate: comment_aggregate_order_by
  group: group_order_by
  groupId: order_by
  id: order_by
  images: order_by
  likes_aggregate: like_aggregate_order_by
  link: order_by
  text: order_by
  time: order_by
  user: user_order_by
}

# primary key columns input for table: "post"
input post_pk_columns_input {
  id: Int!
}

# prepend existing jsonb value of filtered columns with new jsonb value
input post_prepend_input {
  images: jsonb
}

# select columns of table "post"
enum post_select_column {
  # column name
  authorId

  # column name
  groupId

  # column name
  id

  # column name
  images

  # column name
  link

  # column name
  text

  # column name
  time
}

# input type for updating data in table "post"
input post_set_input {
  authorId: String
  groupId: uuid
  id: Int
  images: jsonb
  link: String
  text: String
  time: timestamptz
}

# aggregate stddev on columns
type post_stddev_fields {
  id: Float
}

# order by stddev() on columns of table "post"
input post_stddev_order_by {
  id: order_by
}

# aggregate stddev_pop on columns
type post_stddev_pop_fields {
  id: Float
}

# order by stddev_pop() on columns of table "post"
input post_stddev_pop_order_by {
  id: order_by
}

# aggregate stddev_samp on columns
type post_stddev_samp_fields {
  id: Float
}

# order by stddev_samp() on columns of table "post"
input post_stddev_samp_order_by {
  id: order_by
}

# aggregate sum on columns
type post_sum_fields {
  id: Int
}

# order by sum() on columns of table "post"
input post_sum_order_by {
  id: order_by
}

# update columns of table "post"
enum post_update_column {
  # column name
  authorId

  # column name
  groupId

  # column name
  id

  # column name
  images

  # column name
  link

  # column name
  text

  # column name
  time
}

# aggregate var_pop on columns
type post_var_pop_fields {
  id: Float
}

# order by var_pop() on columns of table "post"
input post_var_pop_order_by {
  id: order_by
}

# aggregate var_samp on columns
type post_var_samp_fields {
  id: Float
}

# order by var_samp() on columns of table "post"
input post_var_samp_order_by {
  id: order_by
}

# aggregate variance on columns
type post_variance_fields {
  id: Float
}

# order by variance() on columns of table "post"
input post_variance_order_by {
  id: order_by
}

# columns and relationships of "program"
type program {
  id: Int!
  name: String!

  # An array relationship
  users(
    # distinct select on columns
    distinct_on: [userProgram_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userProgram_order_by!]

    # filter the rows returned
    where: userProgram_bool_exp
  ): [userProgram!]!

  # An aggregated array relationship
  users_aggregate(
    # distinct select on columns
    distinct_on: [userProgram_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userProgram_order_by!]

    # filter the rows returned
    where: userProgram_bool_exp
  ): userProgram_aggregate!
}

# aggregated selection of "program"
type program_aggregate {
  aggregate: program_aggregate_fields
  nodes: [program!]!
}

# aggregate fields of "program"
type program_aggregate_fields {
  avg: program_avg_fields
  count(columns: [program_select_column!], distinct: Boolean): Int
  max: program_max_fields
  min: program_min_fields
  stddev: program_stddev_fields
  stddev_pop: program_stddev_pop_fields
  stddev_samp: program_stddev_samp_fields
  sum: program_sum_fields
  var_pop: program_var_pop_fields
  var_samp: program_var_samp_fields
  variance: program_variance_fields
}

# order by aggregate values of table "program"
input program_aggregate_order_by {
  avg: program_avg_order_by
  count: order_by
  max: program_max_order_by
  min: program_min_order_by
  stddev: program_stddev_order_by
  stddev_pop: program_stddev_pop_order_by
  stddev_samp: program_stddev_samp_order_by
  sum: program_sum_order_by
  var_pop: program_var_pop_order_by
  var_samp: program_var_samp_order_by
  variance: program_variance_order_by
}

# input type for inserting array relation for remote table "program"
input program_arr_rel_insert_input {
  data: [program_insert_input!]!
  on_conflict: program_on_conflict
}

# aggregate avg on columns
type program_avg_fields {
  id: Float
}

# order by avg() on columns of table "program"
input program_avg_order_by {
  id: order_by
}

# Boolean expression to filter rows from the table "program". All fields are combined with a logical 'AND'.
input program_bool_exp {
  _and: [program_bool_exp]
  _not: program_bool_exp
  _or: [program_bool_exp]
  id: Int_comparison_exp
  name: String_comparison_exp
  users: userProgram_bool_exp
}

# unique or primary key constraints on table "program"
enum program_constraint {
  # unique or primary key constraint
  program_id_key

  # unique or primary key constraint
  program_name_key

  # unique or primary key constraint
  program_pkey
}

# input type for incrementing integer column in table "program"
input program_inc_input {
  id: Int
}

# input type for inserting data into table "program"
input program_insert_input {
  id: Int
  name: String
  users: userProgram_arr_rel_insert_input
}

# aggregate max on columns
type program_max_fields {
  id: Int
  name: String
}

# order by max() on columns of table "program"
input program_max_order_by {
  id: order_by
  name: order_by
}

# aggregate min on columns
type program_min_fields {
  id: Int
  name: String
}

# order by min() on columns of table "program"
input program_min_order_by {
  id: order_by
  name: order_by
}

# response of any mutation on the table "program"
type program_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [program!]!
}

# input type for inserting object relation for remote table "program"
input program_obj_rel_insert_input {
  data: program_insert_input!
  on_conflict: program_on_conflict
}

# on conflict condition type for table "program"
input program_on_conflict {
  constraint: program_constraint!
  update_columns: [program_update_column!]!
  where: program_bool_exp
}

# ordering options when selecting data from "program"
input program_order_by {
  id: order_by
  name: order_by
  users_aggregate: userProgram_aggregate_order_by
}

# primary key columns input for table: "program"
input program_pk_columns_input {
  name: String!
}

# select columns of table "program"
enum program_select_column {
  # column name
  id

  # column name
  name
}

# input type for updating data in table "program"
input program_set_input {
  id: Int
  name: String
}

# aggregate stddev on columns
type program_stddev_fields {
  id: Float
}

# order by stddev() on columns of table "program"
input program_stddev_order_by {
  id: order_by
}

# aggregate stddev_pop on columns
type program_stddev_pop_fields {
  id: Float
}

# order by stddev_pop() on columns of table "program"
input program_stddev_pop_order_by {
  id: order_by
}

# aggregate stddev_samp on columns
type program_stddev_samp_fields {
  id: Float
}

# order by stddev_samp() on columns of table "program"
input program_stddev_samp_order_by {
  id: order_by
}

# aggregate sum on columns
type program_sum_fields {
  id: Int
}

# order by sum() on columns of table "program"
input program_sum_order_by {
  id: order_by
}

# update columns of table "program"
enum program_update_column {
  # column name
  id

  # column name
  name
}

# aggregate var_pop on columns
type program_var_pop_fields {
  id: Float
}

# order by var_pop() on columns of table "program"
input program_var_pop_order_by {
  id: order_by
}

# aggregate var_samp on columns
type program_var_samp_fields {
  id: Float
}

# order by var_samp() on columns of table "program"
input program_var_samp_order_by {
  id: order_by
}

# aggregate variance on columns
type program_variance_fields {
  id: Float
}

# order by variance() on columns of table "program"
input program_variance_order_by {
  id: order_by
}

# query root
type query_root {
  # fetch data from the table: "block"
  block(
    # distinct select on columns
    distinct_on: [block_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [block_order_by!]

    # filter the rows returned
    where: block_bool_exp
  ): [block!]!

  # fetch aggregated fields from the table: "block"
  block_aggregate(
    # distinct select on columns
    distinct_on: [block_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [block_order_by!]

    # filter the rows returned
    where: block_bool_exp
  ): block_aggregate!

  # fetch data from the table: "block" using primary key columns
  block_by_pk(blockedId: String!, blockerId: String!): block

  # fetch data from the table: "bug"
  bug(
    # distinct select on columns
    distinct_on: [bug_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [bug_order_by!]

    # filter the rows returned
    where: bug_bool_exp
  ): [bug!]!

  # fetch aggregated fields from the table: "bug"
  bug_aggregate(
    # distinct select on columns
    distinct_on: [bug_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [bug_order_by!]

    # filter the rows returned
    where: bug_bool_exp
  ): bug_aggregate!

  # fetch data from the table: "bug" using primary key columns
  bug_by_pk(reporter: String!): bug

  # fetch data from the table: "chat" using primary key columns
  chat(id: Int!): chat

  # fetch data from the table: "chatUserView"
  chatUserView(
    # distinct select on columns
    distinct_on: [chatUserView_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [chatUserView_order_by!]

    # filter the rows returned
    where: chatUserView_bool_exp
  ): [chatUserView!]!

  # fetch aggregated fields from the table: "chatUserView"
  chatUserView_aggregate(
    # distinct select on columns
    distinct_on: [chatUserView_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [chatUserView_order_by!]

    # filter the rows returned
    where: chatUserView_bool_exp
  ): chatUserView_aggregate!

  # fetch aggregated fields from the table: "chat"
  chat_aggregate(
    # distinct select on columns
    distinct_on: [chat_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [chat_order_by!]

    # filter the rows returned
    where: chat_bool_exp
  ): chat_aggregate!

  # fetch data from the table: "chat"
  chats(
    # distinct select on columns
    distinct_on: [chat_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [chat_order_by!]

    # filter the rows returned
    where: chat_bool_exp
  ): [chat!]!

  # fetch data from the table: "comment"
  comment(
    # distinct select on columns
    distinct_on: [comment_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [comment_order_by!]

    # filter the rows returned
    where: comment_bool_exp
  ): [comment!]!

  # fetch aggregated fields from the table: "comment"
  comment_aggregate(
    # distinct select on columns
    distinct_on: [comment_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [comment_order_by!]

    # filter the rows returned
    where: comment_bool_exp
  ): comment_aggregate!

  # fetch data from the table: "comment" using primary key columns
  comment_by_pk(id: Int!): comment

  # fetch data from the table: "event" using primary key columns
  event(id: uuid!): event

  # fetch data from the table: "eventQuestion"
  eventQuestion(
    # distinct select on columns
    distinct_on: [eventQuestion_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [eventQuestion_order_by!]

    # filter the rows returned
    where: eventQuestion_bool_exp
  ): [eventQuestion!]!

  # fetch aggregated fields from the table: "eventQuestion"
  eventQuestion_aggregate(
    # distinct select on columns
    distinct_on: [eventQuestion_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [eventQuestion_order_by!]

    # filter the rows returned
    where: eventQuestion_bool_exp
  ): eventQuestion_aggregate!

  # fetch data from the table: "eventQuestion" using primary key columns
  eventQuestion_by_pk(eventId: uuid!, questionId: Int!): eventQuestion

  # fetch aggregated fields from the table: "event"
  event_aggregate(
    # distinct select on columns
    distinct_on: [event_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [event_order_by!]

    # filter the rows returned
    where: event_bool_exp
  ): event_aggregate!

  # fetch data from the table: "event"
  events(
    # distinct select on columns
    distinct_on: [event_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [event_order_by!]

    # filter the rows returned
    where: event_bool_exp
  ): [event!]!

  # fetch data from the table: "friend"
  friend(
    # distinct select on columns
    distinct_on: [friend_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [friend_order_by!]

    # filter the rows returned
    where: friend_bool_exp
  ): [friend!]!

  # fetch data from the table: "friendRequest"
  friendRequest(
    # distinct select on columns
    distinct_on: [friendRequest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [friendRequest_order_by!]

    # filter the rows returned
    where: friendRequest_bool_exp
  ): [friendRequest!]!

  # fetch aggregated fields from the table: "friendRequest"
  friendRequest_aggregate(
    # distinct select on columns
    distinct_on: [friendRequest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [friendRequest_order_by!]

    # filter the rows returned
    where: friendRequest_bool_exp
  ): friendRequest_aggregate!

  # fetch data from the table: "friendRequest" using primary key columns
  friendRequest_by_pk(recipient: String!, sender: String!): friendRequest

  # fetch aggregated fields from the table: "friendView"
  friendView_aggregate(
    # distinct select on columns
    distinct_on: [friendView_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [friendView_order_by!]

    # filter the rows returned
    where: friendView_bool_exp
  ): friendView_aggregate!

  # fetch aggregated fields from the table: "friend"
  friend_aggregate(
    # distinct select on columns
    distinct_on: [friend_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [friend_order_by!]

    # filter the rows returned
    where: friend_bool_exp
  ): friend_aggregate!

  # fetch data from the table: "friend" using primary key columns
  friend_by_pk(friendId: String!, userId: String!): friend

  # fetch data from the table: "friendView"
  friends(
    # distinct select on columns
    distinct_on: [friendView_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [friendView_order_by!]

    # filter the rows returned
    where: friendView_bool_exp
  ): [friendView!]!

  # fetch data from the table: "groupTrophy"
  getTrophies(
    # distinct select on columns
    distinct_on: [groupTrophy_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupTrophy_order_by!]

    # filter the rows returned
    where: groupTrophy_bool_exp
  ): [groupTrophy!]!

  # execute function "getrandomusers" which returns "user"
  getrandomusers(
    # input parameters for function "getrandomusers"
    args: getrandomusers_args!

    # distinct select on columns
    distinct_on: [user_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [user_order_by!]

    # filter the rows returned
    where: user_bool_exp
  ): [user!]!

  # execute function "getrandomusers" and query aggregates on result of table type "user"
  getrandomusers_aggregate(
    # input parameters for function "getrandomusers"
    args: getrandomusers_args!

    # distinct select on columns
    distinct_on: [user_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [user_order_by!]

    # filter the rows returned
    where: user_bool_exp
  ): user_aggregate!

  # fetch data from the table: "group" using primary key columns
  group(id: uuid!): group

  # fetch data from the table: "groupChats"
  groupChats(
    # distinct select on columns
    distinct_on: [groupChats_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupChats_order_by!]

    # filter the rows returned
    where: groupChats_bool_exp
  ): [groupChats!]!

  # fetch aggregated fields from the table: "groupChats"
  groupChats_aggregate(
    # distinct select on columns
    distinct_on: [groupChats_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupChats_order_by!]

    # filter the rows returned
    where: groupChats_bool_exp
  ): groupChats_aggregate!

  # fetch data from the table: "groupChats" using primary key columns
  groupChats_by_pk(chatId: Int!, groupId: uuid!): groupChats

  # fetch data from the table: "groupEvent"
  groupEvent(
    # distinct select on columns
    distinct_on: [groupEvent_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupEvent_order_by!]

    # filter the rows returned
    where: groupEvent_bool_exp
  ): [groupEvent!]!

  # fetch aggregated fields from the table: "groupEvent"
  groupEvent_aggregate(
    # distinct select on columns
    distinct_on: [groupEvent_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupEvent_order_by!]

    # filter the rows returned
    where: groupEvent_bool_exp
  ): groupEvent_aggregate!

  # fetch data from the table: "groupEvent" using primary key columns
  groupEvent_by_pk(eventId: uuid!, groupId: uuid!): groupEvent

  # fetch data from the table: "groupInterest"
  groupInterest(
    # distinct select on columns
    distinct_on: [groupInterest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupInterest_order_by!]

    # filter the rows returned
    where: groupInterest_bool_exp
  ): [groupInterest!]!

  # fetch aggregated fields from the table: "groupInterest"
  groupInterest_aggregate(
    # distinct select on columns
    distinct_on: [groupInterest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupInterest_order_by!]

    # filter the rows returned
    where: groupInterest_bool_exp
  ): groupInterest_aggregate!

  # fetch data from the table: "groupInterest" using primary key columns
  groupInterest_by_pk(groupId: uuid!, interestId: Int!): groupInterest

  # fetch data from the table: "groupQuestion"
  groupQuestion(
    # distinct select on columns
    distinct_on: [groupQuestion_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupQuestion_order_by!]

    # filter the rows returned
    where: groupQuestion_bool_exp
  ): [groupQuestion!]!

  # fetch aggregated fields from the table: "groupQuestion"
  groupQuestion_aggregate(
    # distinct select on columns
    distinct_on: [groupQuestion_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupQuestion_order_by!]

    # filter the rows returned
    where: groupQuestion_bool_exp
  ): groupQuestion_aggregate!

  # fetch data from the table: "groupQuestion" using primary key columns
  groupQuestion_by_pk(groupId: uuid!, questionId: Int!): groupQuestion

  # fetch aggregated fields from the table: "groupTrophy"
  groupTrophy_aggregate(
    # distinct select on columns
    distinct_on: [groupTrophy_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupTrophy_order_by!]

    # filter the rows returned
    where: groupTrophy_bool_exp
  ): groupTrophy_aggregate!

  # fetch data from the table: "groupTrophy" using primary key columns
  groupTrophy_by_pk(groupId: uuid!, trophyId: uuid!): groupTrophy

  # fetch aggregated fields from the table: "group"
  group_aggregate(
    # distinct select on columns
    distinct_on: [group_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [group_order_by!]

    # filter the rows returned
    where: group_bool_exp
  ): group_aggregate!

  # fetch data from the table: "group"
  groups(
    # distinct select on columns
    distinct_on: [group_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [group_order_by!]

    # filter the rows returned
    where: group_bool_exp
  ): [group!]!

  # fetch data from the table: "interest" using primary key columns
  interest(name: String!): interest

  # fetch aggregated fields from the table: "interest"
  interest_aggregate(
    # distinct select on columns
    distinct_on: [interest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [interest_order_by!]

    # filter the rows returned
    where: interest_bool_exp
  ): interest_aggregate!

  # fetch data from the table: "interest"
  interests(
    # distinct select on columns
    distinct_on: [interest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [interest_order_by!]

    # filter the rows returned
    where: interest_bool_exp
  ): [interest!]!

  # fetch data from the table: "like"
  like(
    # distinct select on columns
    distinct_on: [like_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [like_order_by!]

    # filter the rows returned
    where: like_bool_exp
  ): [like!]!

  # fetch aggregated fields from the table: "like"
  like_aggregate(
    # distinct select on columns
    distinct_on: [like_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [like_order_by!]

    # filter the rows returned
    where: like_bool_exp
  ): like_aggregate!

  # fetch data from the table: "like" using primary key columns
  like_by_pk(postId: Int!, userId: String!): like

  # fetch data from the table: "message" using primary key columns
  message(id: Int!): message

  # fetch aggregated fields from the table: "message"
  message_aggregate(
    # distinct select on columns
    distinct_on: [message_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [message_order_by!]

    # filter the rows returned
    where: message_bool_exp
  ): message_aggregate!

  # fetch data from the table: "message"
  messages(
    # distinct select on columns
    distinct_on: [message_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [message_order_by!]

    # filter the rows returned
    where: message_bool_exp
  ): [message!]!

  # fetch data from the table: "notification" using primary key columns
  notification(id: Int!): notification

  # fetch data from the table: "notificationTokenView"
  notificationTokenView(
    # distinct select on columns
    distinct_on: [notificationTokenView_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [notificationTokenView_order_by!]

    # filter the rows returned
    where: notificationTokenView_bool_exp
  ): [notificationTokenView!]!

  # fetch aggregated fields from the table: "notificationTokenView"
  notificationTokenView_aggregate(
    # distinct select on columns
    distinct_on: [notificationTokenView_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [notificationTokenView_order_by!]

    # filter the rows returned
    where: notificationTokenView_bool_exp
  ): notificationTokenView_aggregate!

  # fetch aggregated fields from the table: "notification"
  notification_aggregate(
    # distinct select on columns
    distinct_on: [notification_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [notification_order_by!]

    # filter the rows returned
    where: notification_bool_exp
  ): notification_aggregate!

  # fetch data from the table: "notification"
  notifications(
    # distinct select on columns
    distinct_on: [notification_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [notification_order_by!]

    # filter the rows returned
    where: notification_bool_exp
  ): [notification!]!

  # fetch data from the table: "post"
  post(
    # distinct select on columns
    distinct_on: [post_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [post_order_by!]

    # filter the rows returned
    where: post_bool_exp
  ): [post!]!

  # fetch aggregated fields from the table: "post"
  post_aggregate(
    # distinct select on columns
    distinct_on: [post_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [post_order_by!]

    # filter the rows returned
    where: post_bool_exp
  ): post_aggregate!

  # fetch data from the table: "post" using primary key columns
  post_by_pk(id: Int!): post

  # fetch data from the table: "program" using primary key columns
  program(name: String!): program

  # fetch aggregated fields from the table: "program"
  program_aggregate(
    # distinct select on columns
    distinct_on: [program_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [program_order_by!]

    # filter the rows returned
    where: program_bool_exp
  ): program_aggregate!

  # fetch data from the table: "program"
  programs(
    # distinct select on columns
    distinct_on: [program_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [program_order_by!]

    # filter the rows returned
    where: program_bool_exp
  ): [program!]!

  # fetch aggregated fields from the table: "question"
  question_aggregate(
    # distinct select on columns
    distinct_on: [question_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [question_order_by!]

    # filter the rows returned
    where: question_bool_exp
  ): question_aggregate!

  # fetch data from the table: "question" using primary key columns
  question_by_pk(id: Int!): question

  # fetch data from the table: "question"
  questions(
    # distinct select on columns
    distinct_on: [question_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [question_order_by!]

    # filter the rows returned
    where: question_bool_exp
  ): [question!]!

  # fetch data from the table: "report"
  report(
    # distinct select on columns
    distinct_on: [report_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [report_order_by!]

    # filter the rows returned
    where: report_bool_exp
  ): [report!]!

  # fetch aggregated fields from the table: "report"
  report_aggregate(
    # distinct select on columns
    distinct_on: [report_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [report_order_by!]

    # filter the rows returned
    where: report_bool_exp
  ): report_aggregate!

  # fetch data from the table: "review"
  review(
    # distinct select on columns
    distinct_on: [review_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [review_order_by!]

    # filter the rows returned
    where: review_bool_exp
  ): [review!]!

  # fetch aggregated fields from the table: "review"
  review_aggregate(
    # distinct select on columns
    distinct_on: [review_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [review_order_by!]

    # filter the rows returned
    where: review_bool_exp
  ): review_aggregate!

  # fetch data from the table: "review" using primary key columns
  review_by_pk(id: Int!): review

  # fetch data from the table: "trophy"
  trophy(
    # distinct select on columns
    distinct_on: [trophy_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [trophy_order_by!]

    # filter the rows returned
    where: trophy_bool_exp
  ): [trophy!]!

  # fetch data from the table: "trophyGroupView"
  trophyGroupView(
    # distinct select on columns
    distinct_on: [trophyGroupView_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [trophyGroupView_order_by!]

    # filter the rows returned
    where: trophyGroupView_bool_exp
  ): [trophyGroupView!]!

  # fetch aggregated fields from the table: "trophyGroupView"
  trophyGroupView_aggregate(
    # distinct select on columns
    distinct_on: [trophyGroupView_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [trophyGroupView_order_by!]

    # filter the rows returned
    where: trophyGroupView_bool_exp
  ): trophyGroupView_aggregate!

  # fetch aggregated fields from the table: "trophy"
  trophy_aggregate(
    # distinct select on columns
    distinct_on: [trophy_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [trophy_order_by!]

    # filter the rows returned
    where: trophy_bool_exp
  ): trophy_aggregate!

  # fetch data from the table: "trophy" using primary key columns
  trophy_by_pk(id: uuid!): trophy

  # fetch data from the table: "user" using primary key columns
  user(id: String!): user

  # fetch data from the table: "userChat"
  userChat(
    # distinct select on columns
    distinct_on: [userChat_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userChat_order_by!]

    # filter the rows returned
    where: userChat_bool_exp
  ): [userChat!]!

  # fetch aggregated fields from the table: "userChat"
  userChat_aggregate(
    # distinct select on columns
    distinct_on: [userChat_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userChat_order_by!]

    # filter the rows returned
    where: userChat_bool_exp
  ): userChat_aggregate!

  # fetch data from the table: "userChat" using primary key columns
  userChat_by_pk(chatId: Int!, userId: String!): userChat

  # fetch data from the table: "userEvent"
  userEvent(
    # distinct select on columns
    distinct_on: [userEvent_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userEvent_order_by!]

    # filter the rows returned
    where: userEvent_bool_exp
  ): [userEvent!]!

  # fetch aggregated fields from the table: "userEvent"
  userEvent_aggregate(
    # distinct select on columns
    distinct_on: [userEvent_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userEvent_order_by!]

    # filter the rows returned
    where: userEvent_bool_exp
  ): userEvent_aggregate!

  # fetch data from the table: "userEvent" using primary key columns
  userEvent_by_pk(eventId: uuid!, userId: String!): userEvent

  # fetch data from the table: "userGroup"
  userGroup(
    # distinct select on columns
    distinct_on: [userGroup_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userGroup_order_by!]

    # filter the rows returned
    where: userGroup_bool_exp
  ): [userGroup!]!

  # fetch aggregated fields from the table: "userGroup"
  userGroup_aggregate(
    # distinct select on columns
    distinct_on: [userGroup_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userGroup_order_by!]

    # filter the rows returned
    where: userGroup_bool_exp
  ): userGroup_aggregate!

  # fetch data from the table: "userGroup" using primary key columns
  userGroup_by_pk(groupId: uuid!, userId: String!): userGroup

  # fetch data from the table: "userInterest"
  userInterest(
    # distinct select on columns
    distinct_on: [userInterest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userInterest_order_by!]

    # filter the rows returned
    where: userInterest_bool_exp
  ): [userInterest!]!

  # fetch aggregated fields from the table: "userInterest"
  userInterest_aggregate(
    # distinct select on columns
    distinct_on: [userInterest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userInterest_order_by!]

    # filter the rows returned
    where: userInterest_bool_exp
  ): userInterest_aggregate!

  # fetch data from the table: "userInterest" using primary key columns
  userInterest_by_pk(interestId: Int!, userId: String!): userInterest

  # fetch data from the table: "userNotification"
  userNotification(
    # distinct select on columns
    distinct_on: [userNotification_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userNotification_order_by!]

    # filter the rows returned
    where: userNotification_bool_exp
  ): [userNotification!]!

  # fetch data from the table: "userNotificationView"
  userNotificationView(
    # distinct select on columns
    distinct_on: [userNotificationView_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userNotificationView_order_by!]

    # filter the rows returned
    where: userNotificationView_bool_exp
  ): [userNotificationView!]!

  # fetch aggregated fields from the table: "userNotificationView"
  userNotificationView_aggregate(
    # distinct select on columns
    distinct_on: [userNotificationView_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userNotificationView_order_by!]

    # filter the rows returned
    where: userNotificationView_bool_exp
  ): userNotificationView_aggregate!

  # fetch aggregated fields from the table: "userNotification"
  userNotification_aggregate(
    # distinct select on columns
    distinct_on: [userNotification_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userNotification_order_by!]

    # filter the rows returned
    where: userNotification_bool_exp
  ): userNotification_aggregate!

  # fetch data from the table: "userNotification" using primary key columns
  userNotification_by_pk(notificationId: Int!, userId: String!): userNotification

  # fetch data from the table: "userProgram"
  userProgram(
    # distinct select on columns
    distinct_on: [userProgram_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userProgram_order_by!]

    # filter the rows returned
    where: userProgram_bool_exp
  ): [userProgram!]!

  # fetch aggregated fields from the table: "userProgram"
  userProgram_aggregate(
    # distinct select on columns
    distinct_on: [userProgram_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userProgram_order_by!]

    # filter the rows returned
    where: userProgram_bool_exp
  ): userProgram_aggregate!

  # fetch data from the table: "userProgram" using primary key columns
  userProgram_by_pk(programId: Int!, userId: String!): userProgram

  # fetch aggregated fields from the table: "user"
  user_aggregate(
    # distinct select on columns
    distinct_on: [user_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [user_order_by!]

    # filter the rows returned
    where: user_bool_exp
  ): user_aggregate!

  # fetch data from the table: "user"
  users(
    # distinct select on columns
    distinct_on: [user_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [user_order_by!]

    # filter the rows returned
    where: user_bool_exp
  ): [user!]!
}

# columns and relationships of "question"
type question {
  answer: String!
  author: String!

  # An array relationship
  eventQuestions(
    # distinct select on columns
    distinct_on: [eventQuestion_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [eventQuestion_order_by!]

    # filter the rows returned
    where: eventQuestion_bool_exp
  ): [eventQuestion!]!

  # An aggregated array relationship
  eventQuestions_aggregate(
    # distinct select on columns
    distinct_on: [eventQuestion_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [eventQuestion_order_by!]

    # filter the rows returned
    where: eventQuestion_bool_exp
  ): eventQuestion_aggregate!

  # An array relationship
  groupQuestions(
    # distinct select on columns
    distinct_on: [groupQuestion_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupQuestion_order_by!]

    # filter the rows returned
    where: groupQuestion_bool_exp
  ): [groupQuestion!]!

  # An aggregated array relationship
  groupQuestions_aggregate(
    # distinct select on columns
    distinct_on: [groupQuestion_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupQuestion_order_by!]

    # filter the rows returned
    where: groupQuestion_bool_exp
  ): groupQuestion_aggregate!
  id: Int!
  question: String!

  # An object relationship
  user: user!
}

# aggregated selection of "question"
type question_aggregate {
  aggregate: question_aggregate_fields
  nodes: [question!]!
}

# aggregate fields of "question"
type question_aggregate_fields {
  avg: question_avg_fields
  count(columns: [question_select_column!], distinct: Boolean): Int
  max: question_max_fields
  min: question_min_fields
  stddev: question_stddev_fields
  stddev_pop: question_stddev_pop_fields
  stddev_samp: question_stddev_samp_fields
  sum: question_sum_fields
  var_pop: question_var_pop_fields
  var_samp: question_var_samp_fields
  variance: question_variance_fields
}

# order by aggregate values of table "question"
input question_aggregate_order_by {
  avg: question_avg_order_by
  count: order_by
  max: question_max_order_by
  min: question_min_order_by
  stddev: question_stddev_order_by
  stddev_pop: question_stddev_pop_order_by
  stddev_samp: question_stddev_samp_order_by
  sum: question_sum_order_by
  var_pop: question_var_pop_order_by
  var_samp: question_var_samp_order_by
  variance: question_variance_order_by
}

# input type for inserting array relation for remote table "question"
input question_arr_rel_insert_input {
  data: [question_insert_input!]!
  on_conflict: question_on_conflict
}

# aggregate avg on columns
type question_avg_fields {
  id: Float
}

# order by avg() on columns of table "question"
input question_avg_order_by {
  id: order_by
}

# Boolean expression to filter rows from the table "question". All fields are combined with a logical 'AND'.
input question_bool_exp {
  _and: [question_bool_exp]
  _not: question_bool_exp
  _or: [question_bool_exp]
  answer: String_comparison_exp
  author: String_comparison_exp
  eventQuestions: eventQuestion_bool_exp
  groupQuestions: groupQuestion_bool_exp
  id: Int_comparison_exp
  question: String_comparison_exp
  user: user_bool_exp
}

# unique or primary key constraints on table "question"
enum question_constraint {
  # unique or primary key constraint
  question_pkey
}

# input type for incrementing integer column in table "question"
input question_inc_input {
  id: Int
}

# input type for inserting data into table "question"
input question_insert_input {
  answer: String
  author: String
  eventQuestions: eventQuestion_arr_rel_insert_input
  groupQuestions: groupQuestion_arr_rel_insert_input
  id: Int
  question: String
  user: user_obj_rel_insert_input
}

# aggregate max on columns
type question_max_fields {
  answer: String
  author: String
  id: Int
  question: String
}

# order by max() on columns of table "question"
input question_max_order_by {
  answer: order_by
  author: order_by
  id: order_by
  question: order_by
}

# aggregate min on columns
type question_min_fields {
  answer: String
  author: String
  id: Int
  question: String
}

# order by min() on columns of table "question"
input question_min_order_by {
  answer: order_by
  author: order_by
  id: order_by
  question: order_by
}

# response of any mutation on the table "question"
type question_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [question!]!
}

# input type for inserting object relation for remote table "question"
input question_obj_rel_insert_input {
  data: question_insert_input!
  on_conflict: question_on_conflict
}

# on conflict condition type for table "question"
input question_on_conflict {
  constraint: question_constraint!
  update_columns: [question_update_column!]!
  where: question_bool_exp
}

# ordering options when selecting data from "question"
input question_order_by {
  answer: order_by
  author: order_by
  eventQuestions_aggregate: eventQuestion_aggregate_order_by
  groupQuestions_aggregate: groupQuestion_aggregate_order_by
  id: order_by
  question: order_by
  user: user_order_by
}

# primary key columns input for table: "question"
input question_pk_columns_input {
  id: Int!
}

# select columns of table "question"
enum question_select_column {
  # column name
  answer

  # column name
  author

  # column name
  id

  # column name
  question
}

# input type for updating data in table "question"
input question_set_input {
  answer: String
  author: String
  id: Int
  question: String
}

# aggregate stddev on columns
type question_stddev_fields {
  id: Float
}

# order by stddev() on columns of table "question"
input question_stddev_order_by {
  id: order_by
}

# aggregate stddev_pop on columns
type question_stddev_pop_fields {
  id: Float
}

# order by stddev_pop() on columns of table "question"
input question_stddev_pop_order_by {
  id: order_by
}

# aggregate stddev_samp on columns
type question_stddev_samp_fields {
  id: Float
}

# order by stddev_samp() on columns of table "question"
input question_stddev_samp_order_by {
  id: order_by
}

# aggregate sum on columns
type question_sum_fields {
  id: Int
}

# order by sum() on columns of table "question"
input question_sum_order_by {
  id: order_by
}

# update columns of table "question"
enum question_update_column {
  # column name
  answer

  # column name
  author

  # column name
  id

  # column name
  question
}

# aggregate var_pop on columns
type question_var_pop_fields {
  id: Float
}

# order by var_pop() on columns of table "question"
input question_var_pop_order_by {
  id: order_by
}

# aggregate var_samp on columns
type question_var_samp_fields {
  id: Float
}

# order by var_samp() on columns of table "question"
input question_var_samp_order_by {
  id: order_by
}

# aggregate variance on columns
type question_variance_fields {
  id: Float
}

# order by variance() on columns of table "question"
input question_variance_order_by {
  id: order_by
}

# columns and relationships of "report"
type report {
  chat: Int
  comment: Int
  post: Int
  reported: String
  reporter: String!
  time: timestamptz!
}

# aggregated selection of "report"
type report_aggregate {
  aggregate: report_aggregate_fields
  nodes: [report!]!
}

# aggregate fields of "report"
type report_aggregate_fields {
  avg: report_avg_fields
  count(columns: [report_select_column!], distinct: Boolean): Int
  max: report_max_fields
  min: report_min_fields
  stddev: report_stddev_fields
  stddev_pop: report_stddev_pop_fields
  stddev_samp: report_stddev_samp_fields
  sum: report_sum_fields
  var_pop: report_var_pop_fields
  var_samp: report_var_samp_fields
  variance: report_variance_fields
}

# order by aggregate values of table "report"
input report_aggregate_order_by {
  avg: report_avg_order_by
  count: order_by
  max: report_max_order_by
  min: report_min_order_by
  stddev: report_stddev_order_by
  stddev_pop: report_stddev_pop_order_by
  stddev_samp: report_stddev_samp_order_by
  sum: report_sum_order_by
  var_pop: report_var_pop_order_by
  var_samp: report_var_samp_order_by
  variance: report_variance_order_by
}

# input type for inserting array relation for remote table "report"
input report_arr_rel_insert_input {
  data: [report_insert_input!]!
}

# aggregate avg on columns
type report_avg_fields {
  chat: Float
  comment: Float
  post: Float
}

# order by avg() on columns of table "report"
input report_avg_order_by {
  chat: order_by
  comment: order_by
  post: order_by
}

# Boolean expression to filter rows from the table "report". All fields are combined with a logical 'AND'.
input report_bool_exp {
  _and: [report_bool_exp]
  _not: report_bool_exp
  _or: [report_bool_exp]
  chat: Int_comparison_exp
  comment: Int_comparison_exp
  post: Int_comparison_exp
  reported: String_comparison_exp
  reporter: String_comparison_exp
  time: timestamptz_comparison_exp
}

# input type for incrementing integer column in table "report"
input report_inc_input {
  chat: Int
  comment: Int
  post: Int
}

# input type for inserting data into table "report"
input report_insert_input {
  chat: Int
  comment: Int
  post: Int
  reported: String
  reporter: String
  time: timestamptz
}

# aggregate max on columns
type report_max_fields {
  chat: Int
  comment: Int
  post: Int
  reported: String
  reporter: String
  time: timestamptz
}

# order by max() on columns of table "report"
input report_max_order_by {
  chat: order_by
  comment: order_by
  post: order_by
  reported: order_by
  reporter: order_by
  time: order_by
}

# aggregate min on columns
type report_min_fields {
  chat: Int
  comment: Int
  post: Int
  reported: String
  reporter: String
  time: timestamptz
}

# order by min() on columns of table "report"
input report_min_order_by {
  chat: order_by
  comment: order_by
  post: order_by
  reported: order_by
  reporter: order_by
  time: order_by
}

# response of any mutation on the table "report"
type report_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [report!]!
}

# input type for inserting object relation for remote table "report"
input report_obj_rel_insert_input {
  data: report_insert_input!
}

# ordering options when selecting data from "report"
input report_order_by {
  chat: order_by
  comment: order_by
  post: order_by
  reported: order_by
  reporter: order_by
  time: order_by
}

# select columns of table "report"
enum report_select_column {
  # column name
  chat

  # column name
  comment

  # column name
  post

  # column name
  reported

  # column name
  reporter

  # column name
  time
}

# input type for updating data in table "report"
input report_set_input {
  chat: Int
  comment: Int
  post: Int
  reported: String
  reporter: String
  time: timestamptz
}

# aggregate stddev on columns
type report_stddev_fields {
  chat: Float
  comment: Float
  post: Float
}

# order by stddev() on columns of table "report"
input report_stddev_order_by {
  chat: order_by
  comment: order_by
  post: order_by
}

# aggregate stddev_pop on columns
type report_stddev_pop_fields {
  chat: Float
  comment: Float
  post: Float
}

# order by stddev_pop() on columns of table "report"
input report_stddev_pop_order_by {
  chat: order_by
  comment: order_by
  post: order_by
}

# aggregate stddev_samp on columns
type report_stddev_samp_fields {
  chat: Float
  comment: Float
  post: Float
}

# order by stddev_samp() on columns of table "report"
input report_stddev_samp_order_by {
  chat: order_by
  comment: order_by
  post: order_by
}

# aggregate sum on columns
type report_sum_fields {
  chat: Int
  comment: Int
  post: Int
}

# order by sum() on columns of table "report"
input report_sum_order_by {
  chat: order_by
  comment: order_by
  post: order_by
}

# aggregate var_pop on columns
type report_var_pop_fields {
  chat: Float
  comment: Float
  post: Float
}

# order by var_pop() on columns of table "report"
input report_var_pop_order_by {
  chat: order_by
  comment: order_by
  post: order_by
}

# aggregate var_samp on columns
type report_var_samp_fields {
  chat: Float
  comment: Float
  post: Float
}

# order by var_samp() on columns of table "report"
input report_var_samp_order_by {
  chat: order_by
  comment: order_by
  post: order_by
}

# aggregate variance on columns
type report_variance_fields {
  chat: Float
  comment: Float
  post: Float
}

# order by variance() on columns of table "report"
input report_variance_order_by {
  chat: order_by
  comment: order_by
  post: order_by
}

# columns and relationships of "review"
type review {
  author: String!
  comment: String
  group: uuid!

  # An object relationship
  groupByGroup: group!
  id: Int!
  rating: Int!

  # An object relationship
  user: user!
}

# aggregated selection of "review"
type review_aggregate {
  aggregate: review_aggregate_fields
  nodes: [review!]!
}

# aggregate fields of "review"
type review_aggregate_fields {
  avg: review_avg_fields
  count(columns: [review_select_column!], distinct: Boolean): Int
  max: review_max_fields
  min: review_min_fields
  stddev: review_stddev_fields
  stddev_pop: review_stddev_pop_fields
  stddev_samp: review_stddev_samp_fields
  sum: review_sum_fields
  var_pop: review_var_pop_fields
  var_samp: review_var_samp_fields
  variance: review_variance_fields
}

# order by aggregate values of table "review"
input review_aggregate_order_by {
  avg: review_avg_order_by
  count: order_by
  max: review_max_order_by
  min: review_min_order_by
  stddev: review_stddev_order_by
  stddev_pop: review_stddev_pop_order_by
  stddev_samp: review_stddev_samp_order_by
  sum: review_sum_order_by
  var_pop: review_var_pop_order_by
  var_samp: review_var_samp_order_by
  variance: review_variance_order_by
}

# input type for inserting array relation for remote table "review"
input review_arr_rel_insert_input {
  data: [review_insert_input!]!
  on_conflict: review_on_conflict
}

# aggregate avg on columns
type review_avg_fields {
  id: Float
  rating: Float
}

# order by avg() on columns of table "review"
input review_avg_order_by {
  id: order_by
  rating: order_by
}

# Boolean expression to filter rows from the table "review". All fields are combined with a logical 'AND'.
input review_bool_exp {
  _and: [review_bool_exp]
  _not: review_bool_exp
  _or: [review_bool_exp]
  author: String_comparison_exp
  comment: String_comparison_exp
  group: uuid_comparison_exp
  groupByGroup: group_bool_exp
  id: Int_comparison_exp
  rating: Int_comparison_exp
  user: user_bool_exp
}

# unique or primary key constraints on table "review"
enum review_constraint {
  # unique or primary key constraint
  review_id1_key

  # unique or primary key constraint
  review_pkey
}

# input type for incrementing integer column in table "review"
input review_inc_input {
  id: Int
  rating: Int
}

# input type for inserting data into table "review"
input review_insert_input {
  author: String
  comment: String
  group: uuid
  groupByGroup: group_obj_rel_insert_input
  id: Int
  rating: Int
  user: user_obj_rel_insert_input
}

# aggregate max on columns
type review_max_fields {
  author: String
  comment: String
  group: uuid
  id: Int
  rating: Int
}

# order by max() on columns of table "review"
input review_max_order_by {
  author: order_by
  comment: order_by
  group: order_by
  id: order_by
  rating: order_by
}

# aggregate min on columns
type review_min_fields {
  author: String
  comment: String
  group: uuid
  id: Int
  rating: Int
}

# order by min() on columns of table "review"
input review_min_order_by {
  author: order_by
  comment: order_by
  group: order_by
  id: order_by
  rating: order_by
}

# response of any mutation on the table "review"
type review_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [review!]!
}

# input type for inserting object relation for remote table "review"
input review_obj_rel_insert_input {
  data: review_insert_input!
  on_conflict: review_on_conflict
}

# on conflict condition type for table "review"
input review_on_conflict {
  constraint: review_constraint!
  update_columns: [review_update_column!]!
  where: review_bool_exp
}

# ordering options when selecting data from "review"
input review_order_by {
  author: order_by
  comment: order_by
  group: order_by
  groupByGroup: group_order_by
  id: order_by
  rating: order_by
  user: user_order_by
}

# primary key columns input for table: "review"
input review_pk_columns_input {
  id: Int!
}

# select columns of table "review"
enum review_select_column {
  # column name
  author

  # column name
  comment

  # column name
  group

  # column name
  id

  # column name
  rating
}

# input type for updating data in table "review"
input review_set_input {
  author: String
  comment: String
  group: uuid
  id: Int
  rating: Int
}

# aggregate stddev on columns
type review_stddev_fields {
  id: Float
  rating: Float
}

# order by stddev() on columns of table "review"
input review_stddev_order_by {
  id: order_by
  rating: order_by
}

# aggregate stddev_pop on columns
type review_stddev_pop_fields {
  id: Float
  rating: Float
}

# order by stddev_pop() on columns of table "review"
input review_stddev_pop_order_by {
  id: order_by
  rating: order_by
}

# aggregate stddev_samp on columns
type review_stddev_samp_fields {
  id: Float
  rating: Float
}

# order by stddev_samp() on columns of table "review"
input review_stddev_samp_order_by {
  id: order_by
  rating: order_by
}

# aggregate sum on columns
type review_sum_fields {
  id: Int
  rating: Int
}

# order by sum() on columns of table "review"
input review_sum_order_by {
  id: order_by
  rating: order_by
}

# update columns of table "review"
enum review_update_column {
  # column name
  author

  # column name
  comment

  # column name
  group

  # column name
  id

  # column name
  rating
}

# aggregate var_pop on columns
type review_var_pop_fields {
  id: Float
  rating: Float
}

# order by var_pop() on columns of table "review"
input review_var_pop_order_by {
  id: order_by
  rating: order_by
}

# aggregate var_samp on columns
type review_var_samp_fields {
  id: Float
  rating: Float
}

# order by var_samp() on columns of table "review"
input review_var_samp_order_by {
  id: order_by
  rating: order_by
}

# aggregate variance on columns
type review_variance_fields {
  id: Float
  rating: Float
}

# order by variance() on columns of table "review"
input review_variance_order_by {
  id: order_by
  rating: order_by
}

# expression to compare columns of type String. All fields are combined with logical 'AND'.
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  _ilike: String
  _in: [String!]
  _is_null: Boolean
  _like: String
  _lt: String
  _lte: String
  _neq: String
  _nilike: String
  _nin: [String!]
  _nlike: String
  _nsimilar: String
  _similar: String
}

# subscription root
type subscription_root {
  # fetch data from the table: "block"
  block(
    # distinct select on columns
    distinct_on: [block_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [block_order_by!]

    # filter the rows returned
    where: block_bool_exp
  ): [block!]!

  # fetch aggregated fields from the table: "block"
  block_aggregate(
    # distinct select on columns
    distinct_on: [block_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [block_order_by!]

    # filter the rows returned
    where: block_bool_exp
  ): block_aggregate!

  # fetch data from the table: "block" using primary key columns
  block_by_pk(blockedId: String!, blockerId: String!): block

  # fetch data from the table: "bug"
  bug(
    # distinct select on columns
    distinct_on: [bug_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [bug_order_by!]

    # filter the rows returned
    where: bug_bool_exp
  ): [bug!]!

  # fetch aggregated fields from the table: "bug"
  bug_aggregate(
    # distinct select on columns
    distinct_on: [bug_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [bug_order_by!]

    # filter the rows returned
    where: bug_bool_exp
  ): bug_aggregate!

  # fetch data from the table: "bug" using primary key columns
  bug_by_pk(reporter: String!): bug

  # fetch data from the table: "chat" using primary key columns
  chat(id: Int!): chat

  # fetch data from the table: "chatUserView"
  chatUserView(
    # distinct select on columns
    distinct_on: [chatUserView_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [chatUserView_order_by!]

    # filter the rows returned
    where: chatUserView_bool_exp
  ): [chatUserView!]!

  # fetch aggregated fields from the table: "chatUserView"
  chatUserView_aggregate(
    # distinct select on columns
    distinct_on: [chatUserView_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [chatUserView_order_by!]

    # filter the rows returned
    where: chatUserView_bool_exp
  ): chatUserView_aggregate!

  # fetch aggregated fields from the table: "chat"
  chat_aggregate(
    # distinct select on columns
    distinct_on: [chat_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [chat_order_by!]

    # filter the rows returned
    where: chat_bool_exp
  ): chat_aggregate!

  # fetch data from the table: "chat"
  chats(
    # distinct select on columns
    distinct_on: [chat_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [chat_order_by!]

    # filter the rows returned
    where: chat_bool_exp
  ): [chat!]!

  # fetch data from the table: "comment"
  comment(
    # distinct select on columns
    distinct_on: [comment_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [comment_order_by!]

    # filter the rows returned
    where: comment_bool_exp
  ): [comment!]!

  # fetch aggregated fields from the table: "comment"
  comment_aggregate(
    # distinct select on columns
    distinct_on: [comment_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [comment_order_by!]

    # filter the rows returned
    where: comment_bool_exp
  ): comment_aggregate!

  # fetch data from the table: "comment" using primary key columns
  comment_by_pk(id: Int!): comment

  # fetch data from the table: "event" using primary key columns
  event(id: uuid!): event

  # fetch data from the table: "eventQuestion"
  eventQuestion(
    # distinct select on columns
    distinct_on: [eventQuestion_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [eventQuestion_order_by!]

    # filter the rows returned
    where: eventQuestion_bool_exp
  ): [eventQuestion!]!

  # fetch aggregated fields from the table: "eventQuestion"
  eventQuestion_aggregate(
    # distinct select on columns
    distinct_on: [eventQuestion_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [eventQuestion_order_by!]

    # filter the rows returned
    where: eventQuestion_bool_exp
  ): eventQuestion_aggregate!

  # fetch data from the table: "eventQuestion" using primary key columns
  eventQuestion_by_pk(eventId: uuid!, questionId: Int!): eventQuestion

  # fetch aggregated fields from the table: "event"
  event_aggregate(
    # distinct select on columns
    distinct_on: [event_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [event_order_by!]

    # filter the rows returned
    where: event_bool_exp
  ): event_aggregate!

  # fetch data from the table: "event"
  events(
    # distinct select on columns
    distinct_on: [event_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [event_order_by!]

    # filter the rows returned
    where: event_bool_exp
  ): [event!]!

  # fetch data from the table: "friend"
  friend(
    # distinct select on columns
    distinct_on: [friend_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [friend_order_by!]

    # filter the rows returned
    where: friend_bool_exp
  ): [friend!]!

  # fetch data from the table: "friendRequest"
  friendRequest(
    # distinct select on columns
    distinct_on: [friendRequest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [friendRequest_order_by!]

    # filter the rows returned
    where: friendRequest_bool_exp
  ): [friendRequest!]!

  # fetch aggregated fields from the table: "friendRequest"
  friendRequest_aggregate(
    # distinct select on columns
    distinct_on: [friendRequest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [friendRequest_order_by!]

    # filter the rows returned
    where: friendRequest_bool_exp
  ): friendRequest_aggregate!

  # fetch data from the table: "friendRequest" using primary key columns
  friendRequest_by_pk(recipient: String!, sender: String!): friendRequest

  # fetch aggregated fields from the table: "friendView"
  friendView_aggregate(
    # distinct select on columns
    distinct_on: [friendView_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [friendView_order_by!]

    # filter the rows returned
    where: friendView_bool_exp
  ): friendView_aggregate!

  # fetch aggregated fields from the table: "friend"
  friend_aggregate(
    # distinct select on columns
    distinct_on: [friend_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [friend_order_by!]

    # filter the rows returned
    where: friend_bool_exp
  ): friend_aggregate!

  # fetch data from the table: "friend" using primary key columns
  friend_by_pk(friendId: String!, userId: String!): friend

  # fetch data from the table: "friendView"
  friends(
    # distinct select on columns
    distinct_on: [friendView_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [friendView_order_by!]

    # filter the rows returned
    where: friendView_bool_exp
  ): [friendView!]!

  # fetch data from the table: "groupTrophy"
  getTrophies(
    # distinct select on columns
    distinct_on: [groupTrophy_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupTrophy_order_by!]

    # filter the rows returned
    where: groupTrophy_bool_exp
  ): [groupTrophy!]!

  # execute function "getrandomusers" which returns "user"
  getrandomusers(
    # input parameters for function "getrandomusers"
    args: getrandomusers_args!

    # distinct select on columns
    distinct_on: [user_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [user_order_by!]

    # filter the rows returned
    where: user_bool_exp
  ): [user!]!

  # execute function "getrandomusers" and query aggregates on result of table type "user"
  getrandomusers_aggregate(
    # input parameters for function "getrandomusers"
    args: getrandomusers_args!

    # distinct select on columns
    distinct_on: [user_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [user_order_by!]

    # filter the rows returned
    where: user_bool_exp
  ): user_aggregate!

  # fetch data from the table: "group" using primary key columns
  group(id: uuid!): group

  # fetch data from the table: "groupChats"
  groupChats(
    # distinct select on columns
    distinct_on: [groupChats_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupChats_order_by!]

    # filter the rows returned
    where: groupChats_bool_exp
  ): [groupChats!]!

  # fetch aggregated fields from the table: "groupChats"
  groupChats_aggregate(
    # distinct select on columns
    distinct_on: [groupChats_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupChats_order_by!]

    # filter the rows returned
    where: groupChats_bool_exp
  ): groupChats_aggregate!

  # fetch data from the table: "groupChats" using primary key columns
  groupChats_by_pk(chatId: Int!, groupId: uuid!): groupChats

  # fetch data from the table: "groupEvent"
  groupEvent(
    # distinct select on columns
    distinct_on: [groupEvent_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupEvent_order_by!]

    # filter the rows returned
    where: groupEvent_bool_exp
  ): [groupEvent!]!

  # fetch aggregated fields from the table: "groupEvent"
  groupEvent_aggregate(
    # distinct select on columns
    distinct_on: [groupEvent_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupEvent_order_by!]

    # filter the rows returned
    where: groupEvent_bool_exp
  ): groupEvent_aggregate!

  # fetch data from the table: "groupEvent" using primary key columns
  groupEvent_by_pk(eventId: uuid!, groupId: uuid!): groupEvent

  # fetch data from the table: "groupInterest"
  groupInterest(
    # distinct select on columns
    distinct_on: [groupInterest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupInterest_order_by!]

    # filter the rows returned
    where: groupInterest_bool_exp
  ): [groupInterest!]!

  # fetch aggregated fields from the table: "groupInterest"
  groupInterest_aggregate(
    # distinct select on columns
    distinct_on: [groupInterest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupInterest_order_by!]

    # filter the rows returned
    where: groupInterest_bool_exp
  ): groupInterest_aggregate!

  # fetch data from the table: "groupInterest" using primary key columns
  groupInterest_by_pk(groupId: uuid!, interestId: Int!): groupInterest

  # fetch data from the table: "groupQuestion"
  groupQuestion(
    # distinct select on columns
    distinct_on: [groupQuestion_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupQuestion_order_by!]

    # filter the rows returned
    where: groupQuestion_bool_exp
  ): [groupQuestion!]!

  # fetch aggregated fields from the table: "groupQuestion"
  groupQuestion_aggregate(
    # distinct select on columns
    distinct_on: [groupQuestion_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupQuestion_order_by!]

    # filter the rows returned
    where: groupQuestion_bool_exp
  ): groupQuestion_aggregate!

  # fetch data from the table: "groupQuestion" using primary key columns
  groupQuestion_by_pk(groupId: uuid!, questionId: Int!): groupQuestion

  # fetch aggregated fields from the table: "groupTrophy"
  groupTrophy_aggregate(
    # distinct select on columns
    distinct_on: [groupTrophy_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupTrophy_order_by!]

    # filter the rows returned
    where: groupTrophy_bool_exp
  ): groupTrophy_aggregate!

  # fetch data from the table: "groupTrophy" using primary key columns
  groupTrophy_by_pk(groupId: uuid!, trophyId: uuid!): groupTrophy

  # fetch aggregated fields from the table: "group"
  group_aggregate(
    # distinct select on columns
    distinct_on: [group_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [group_order_by!]

    # filter the rows returned
    where: group_bool_exp
  ): group_aggregate!

  # fetch data from the table: "group"
  groups(
    # distinct select on columns
    distinct_on: [group_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [group_order_by!]

    # filter the rows returned
    where: group_bool_exp
  ): [group!]!

  # fetch data from the table: "interest" using primary key columns
  interest(name: String!): interest

  # fetch aggregated fields from the table: "interest"
  interest_aggregate(
    # distinct select on columns
    distinct_on: [interest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [interest_order_by!]

    # filter the rows returned
    where: interest_bool_exp
  ): interest_aggregate!

  # fetch data from the table: "interest"
  interests(
    # distinct select on columns
    distinct_on: [interest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [interest_order_by!]

    # filter the rows returned
    where: interest_bool_exp
  ): [interest!]!

  # fetch data from the table: "like"
  like(
    # distinct select on columns
    distinct_on: [like_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [like_order_by!]

    # filter the rows returned
    where: like_bool_exp
  ): [like!]!

  # fetch aggregated fields from the table: "like"
  like_aggregate(
    # distinct select on columns
    distinct_on: [like_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [like_order_by!]

    # filter the rows returned
    where: like_bool_exp
  ): like_aggregate!

  # fetch data from the table: "like" using primary key columns
  like_by_pk(postId: Int!, userId: String!): like

  # fetch data from the table: "message" using primary key columns
  message(id: Int!): message

  # fetch aggregated fields from the table: "message"
  message_aggregate(
    # distinct select on columns
    distinct_on: [message_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [message_order_by!]

    # filter the rows returned
    where: message_bool_exp
  ): message_aggregate!

  # fetch data from the table: "message"
  messages(
    # distinct select on columns
    distinct_on: [message_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [message_order_by!]

    # filter the rows returned
    where: message_bool_exp
  ): [message!]!

  # fetch data from the table: "notification" using primary key columns
  notification(id: Int!): notification

  # fetch data from the table: "notificationTokenView"
  notificationTokenView(
    # distinct select on columns
    distinct_on: [notificationTokenView_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [notificationTokenView_order_by!]

    # filter the rows returned
    where: notificationTokenView_bool_exp
  ): [notificationTokenView!]!

  # fetch aggregated fields from the table: "notificationTokenView"
  notificationTokenView_aggregate(
    # distinct select on columns
    distinct_on: [notificationTokenView_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [notificationTokenView_order_by!]

    # filter the rows returned
    where: notificationTokenView_bool_exp
  ): notificationTokenView_aggregate!

  # fetch aggregated fields from the table: "notification"
  notification_aggregate(
    # distinct select on columns
    distinct_on: [notification_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [notification_order_by!]

    # filter the rows returned
    where: notification_bool_exp
  ): notification_aggregate!

  # fetch data from the table: "notification"
  notifications(
    # distinct select on columns
    distinct_on: [notification_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [notification_order_by!]

    # filter the rows returned
    where: notification_bool_exp
  ): [notification!]!

  # fetch data from the table: "post"
  post(
    # distinct select on columns
    distinct_on: [post_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [post_order_by!]

    # filter the rows returned
    where: post_bool_exp
  ): [post!]!

  # fetch aggregated fields from the table: "post"
  post_aggregate(
    # distinct select on columns
    distinct_on: [post_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [post_order_by!]

    # filter the rows returned
    where: post_bool_exp
  ): post_aggregate!

  # fetch data from the table: "post" using primary key columns
  post_by_pk(id: Int!): post

  # fetch data from the table: "program" using primary key columns
  program(name: String!): program

  # fetch aggregated fields from the table: "program"
  program_aggregate(
    # distinct select on columns
    distinct_on: [program_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [program_order_by!]

    # filter the rows returned
    where: program_bool_exp
  ): program_aggregate!

  # fetch data from the table: "program"
  programs(
    # distinct select on columns
    distinct_on: [program_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [program_order_by!]

    # filter the rows returned
    where: program_bool_exp
  ): [program!]!

  # fetch aggregated fields from the table: "question"
  question_aggregate(
    # distinct select on columns
    distinct_on: [question_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [question_order_by!]

    # filter the rows returned
    where: question_bool_exp
  ): question_aggregate!

  # fetch data from the table: "question" using primary key columns
  question_by_pk(id: Int!): question

  # fetch data from the table: "question"
  questions(
    # distinct select on columns
    distinct_on: [question_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [question_order_by!]

    # filter the rows returned
    where: question_bool_exp
  ): [question!]!

  # fetch data from the table: "report"
  report(
    # distinct select on columns
    distinct_on: [report_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [report_order_by!]

    # filter the rows returned
    where: report_bool_exp
  ): [report!]!

  # fetch aggregated fields from the table: "report"
  report_aggregate(
    # distinct select on columns
    distinct_on: [report_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [report_order_by!]

    # filter the rows returned
    where: report_bool_exp
  ): report_aggregate!

  # fetch data from the table: "review"
  review(
    # distinct select on columns
    distinct_on: [review_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [review_order_by!]

    # filter the rows returned
    where: review_bool_exp
  ): [review!]!

  # fetch aggregated fields from the table: "review"
  review_aggregate(
    # distinct select on columns
    distinct_on: [review_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [review_order_by!]

    # filter the rows returned
    where: review_bool_exp
  ): review_aggregate!

  # fetch data from the table: "review" using primary key columns
  review_by_pk(id: Int!): review

  # fetch data from the table: "trophy"
  trophy(
    # distinct select on columns
    distinct_on: [trophy_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [trophy_order_by!]

    # filter the rows returned
    where: trophy_bool_exp
  ): [trophy!]!

  # fetch data from the table: "trophyGroupView"
  trophyGroupView(
    # distinct select on columns
    distinct_on: [trophyGroupView_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [trophyGroupView_order_by!]

    # filter the rows returned
    where: trophyGroupView_bool_exp
  ): [trophyGroupView!]!

  # fetch aggregated fields from the table: "trophyGroupView"
  trophyGroupView_aggregate(
    # distinct select on columns
    distinct_on: [trophyGroupView_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [trophyGroupView_order_by!]

    # filter the rows returned
    where: trophyGroupView_bool_exp
  ): trophyGroupView_aggregate!

  # fetch aggregated fields from the table: "trophy"
  trophy_aggregate(
    # distinct select on columns
    distinct_on: [trophy_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [trophy_order_by!]

    # filter the rows returned
    where: trophy_bool_exp
  ): trophy_aggregate!

  # fetch data from the table: "trophy" using primary key columns
  trophy_by_pk(id: uuid!): trophy

  # fetch data from the table: "user" using primary key columns
  user(id: String!): user

  # fetch data from the table: "userChat"
  userChat(
    # distinct select on columns
    distinct_on: [userChat_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userChat_order_by!]

    # filter the rows returned
    where: userChat_bool_exp
  ): [userChat!]!

  # fetch aggregated fields from the table: "userChat"
  userChat_aggregate(
    # distinct select on columns
    distinct_on: [userChat_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userChat_order_by!]

    # filter the rows returned
    where: userChat_bool_exp
  ): userChat_aggregate!

  # fetch data from the table: "userChat" using primary key columns
  userChat_by_pk(chatId: Int!, userId: String!): userChat

  # fetch data from the table: "userEvent"
  userEvent(
    # distinct select on columns
    distinct_on: [userEvent_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userEvent_order_by!]

    # filter the rows returned
    where: userEvent_bool_exp
  ): [userEvent!]!

  # fetch aggregated fields from the table: "userEvent"
  userEvent_aggregate(
    # distinct select on columns
    distinct_on: [userEvent_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userEvent_order_by!]

    # filter the rows returned
    where: userEvent_bool_exp
  ): userEvent_aggregate!

  # fetch data from the table: "userEvent" using primary key columns
  userEvent_by_pk(eventId: uuid!, userId: String!): userEvent

  # fetch data from the table: "userGroup"
  userGroup(
    # distinct select on columns
    distinct_on: [userGroup_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userGroup_order_by!]

    # filter the rows returned
    where: userGroup_bool_exp
  ): [userGroup!]!

  # fetch aggregated fields from the table: "userGroup"
  userGroup_aggregate(
    # distinct select on columns
    distinct_on: [userGroup_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userGroup_order_by!]

    # filter the rows returned
    where: userGroup_bool_exp
  ): userGroup_aggregate!

  # fetch data from the table: "userGroup" using primary key columns
  userGroup_by_pk(groupId: uuid!, userId: String!): userGroup

  # fetch data from the table: "userInterest"
  userInterest(
    # distinct select on columns
    distinct_on: [userInterest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userInterest_order_by!]

    # filter the rows returned
    where: userInterest_bool_exp
  ): [userInterest!]!

  # fetch aggregated fields from the table: "userInterest"
  userInterest_aggregate(
    # distinct select on columns
    distinct_on: [userInterest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userInterest_order_by!]

    # filter the rows returned
    where: userInterest_bool_exp
  ): userInterest_aggregate!

  # fetch data from the table: "userInterest" using primary key columns
  userInterest_by_pk(interestId: Int!, userId: String!): userInterest

  # fetch data from the table: "userNotification"
  userNotification(
    # distinct select on columns
    distinct_on: [userNotification_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userNotification_order_by!]

    # filter the rows returned
    where: userNotification_bool_exp
  ): [userNotification!]!

  # fetch data from the table: "userNotificationView"
  userNotificationView(
    # distinct select on columns
    distinct_on: [userNotificationView_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userNotificationView_order_by!]

    # filter the rows returned
    where: userNotificationView_bool_exp
  ): [userNotificationView!]!

  # fetch aggregated fields from the table: "userNotificationView"
  userNotificationView_aggregate(
    # distinct select on columns
    distinct_on: [userNotificationView_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userNotificationView_order_by!]

    # filter the rows returned
    where: userNotificationView_bool_exp
  ): userNotificationView_aggregate!

  # fetch aggregated fields from the table: "userNotification"
  userNotification_aggregate(
    # distinct select on columns
    distinct_on: [userNotification_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userNotification_order_by!]

    # filter the rows returned
    where: userNotification_bool_exp
  ): userNotification_aggregate!

  # fetch data from the table: "userNotification" using primary key columns
  userNotification_by_pk(notificationId: Int!, userId: String!): userNotification

  # fetch data from the table: "userProgram"
  userProgram(
    # distinct select on columns
    distinct_on: [userProgram_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userProgram_order_by!]

    # filter the rows returned
    where: userProgram_bool_exp
  ): [userProgram!]!

  # fetch aggregated fields from the table: "userProgram"
  userProgram_aggregate(
    # distinct select on columns
    distinct_on: [userProgram_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userProgram_order_by!]

    # filter the rows returned
    where: userProgram_bool_exp
  ): userProgram_aggregate!

  # fetch data from the table: "userProgram" using primary key columns
  userProgram_by_pk(programId: Int!, userId: String!): userProgram

  # fetch aggregated fields from the table: "user"
  user_aggregate(
    # distinct select on columns
    distinct_on: [user_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [user_order_by!]

    # filter the rows returned
    where: user_bool_exp
  ): user_aggregate!

  # fetch data from the table: "user"
  users(
    # distinct select on columns
    distinct_on: [user_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [user_order_by!]

    # filter the rows returned
    where: user_bool_exp
  ): [user!]!
}

scalar timestamptz

# expression to compare columns of type timestamptz. All fields are combined with logical 'AND'.
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

# columns and relationships of "trophy"
type trophy {
  description: String!

  # An array relationship
  groupTrophies(
    # distinct select on columns
    distinct_on: [groupTrophy_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupTrophy_order_by!]

    # filter the rows returned
    where: groupTrophy_bool_exp
  ): [groupTrophy!]!

  # An aggregated array relationship
  groupTrophies_aggregate(
    # distinct select on columns
    distinct_on: [groupTrophy_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [groupTrophy_order_by!]

    # filter the rows returned
    where: groupTrophy_bool_exp
  ): groupTrophy_aggregate!
  id: uuid!
  name: String!
  score: Int!
}

# aggregated selection of "trophy"
type trophy_aggregate {
  aggregate: trophy_aggregate_fields
  nodes: [trophy!]!
}

# aggregate fields of "trophy"
type trophy_aggregate_fields {
  avg: trophy_avg_fields
  count(columns: [trophy_select_column!], distinct: Boolean): Int
  max: trophy_max_fields
  min: trophy_min_fields
  stddev: trophy_stddev_fields
  stddev_pop: trophy_stddev_pop_fields
  stddev_samp: trophy_stddev_samp_fields
  sum: trophy_sum_fields
  var_pop: trophy_var_pop_fields
  var_samp: trophy_var_samp_fields
  variance: trophy_variance_fields
}

# order by aggregate values of table "trophy"
input trophy_aggregate_order_by {
  avg: trophy_avg_order_by
  count: order_by
  max: trophy_max_order_by
  min: trophy_min_order_by
  stddev: trophy_stddev_order_by
  stddev_pop: trophy_stddev_pop_order_by
  stddev_samp: trophy_stddev_samp_order_by
  sum: trophy_sum_order_by
  var_pop: trophy_var_pop_order_by
  var_samp: trophy_var_samp_order_by
  variance: trophy_variance_order_by
}

# input type for inserting array relation for remote table "trophy"
input trophy_arr_rel_insert_input {
  data: [trophy_insert_input!]!
  on_conflict: trophy_on_conflict
}

# aggregate avg on columns
type trophy_avg_fields {
  score: Float
}

# order by avg() on columns of table "trophy"
input trophy_avg_order_by {
  score: order_by
}

# Boolean expression to filter rows from the table "trophy". All fields are combined with a logical 'AND'.
input trophy_bool_exp {
  _and: [trophy_bool_exp]
  _not: trophy_bool_exp
  _or: [trophy_bool_exp]
  description: String_comparison_exp
  groupTrophies: groupTrophy_bool_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  score: Int_comparison_exp
}

# unique or primary key constraints on table "trophy"
enum trophy_constraint {
  # unique or primary key constraint
  trophy_pkey
}

# input type for incrementing integer column in table "trophy"
input trophy_inc_input {
  score: Int
}

# input type for inserting data into table "trophy"
input trophy_insert_input {
  description: String
  groupTrophies: groupTrophy_arr_rel_insert_input
  id: uuid
  name: String
  score: Int
}

# aggregate max on columns
type trophy_max_fields {
  description: String
  id: uuid
  name: String
  score: Int
}

# order by max() on columns of table "trophy"
input trophy_max_order_by {
  description: order_by
  id: order_by
  name: order_by
  score: order_by
}

# aggregate min on columns
type trophy_min_fields {
  description: String
  id: uuid
  name: String
  score: Int
}

# order by min() on columns of table "trophy"
input trophy_min_order_by {
  description: order_by
  id: order_by
  name: order_by
  score: order_by
}

# response of any mutation on the table "trophy"
type trophy_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [trophy!]!
}

# input type for inserting object relation for remote table "trophy"
input trophy_obj_rel_insert_input {
  data: trophy_insert_input!
  on_conflict: trophy_on_conflict
}

# on conflict condition type for table "trophy"
input trophy_on_conflict {
  constraint: trophy_constraint!
  update_columns: [trophy_update_column!]!
  where: trophy_bool_exp
}

# ordering options when selecting data from "trophy"
input trophy_order_by {
  description: order_by
  groupTrophies_aggregate: groupTrophy_aggregate_order_by
  id: order_by
  name: order_by
  score: order_by
}

# primary key columns input for table: "trophy"
input trophy_pk_columns_input {
  id: uuid!
}

# select columns of table "trophy"
enum trophy_select_column {
  # column name
  description

  # column name
  id

  # column name
  name

  # column name
  score
}

# input type for updating data in table "trophy"
input trophy_set_input {
  description: String
  id: uuid
  name: String
  score: Int
}

# aggregate stddev on columns
type trophy_stddev_fields {
  score: Float
}

# order by stddev() on columns of table "trophy"
input trophy_stddev_order_by {
  score: order_by
}

# aggregate stddev_pop on columns
type trophy_stddev_pop_fields {
  score: Float
}

# order by stddev_pop() on columns of table "trophy"
input trophy_stddev_pop_order_by {
  score: order_by
}

# aggregate stddev_samp on columns
type trophy_stddev_samp_fields {
  score: Float
}

# order by stddev_samp() on columns of table "trophy"
input trophy_stddev_samp_order_by {
  score: order_by
}

# aggregate sum on columns
type trophy_sum_fields {
  score: Int
}

# order by sum() on columns of table "trophy"
input trophy_sum_order_by {
  score: order_by
}

# update columns of table "trophy"
enum trophy_update_column {
  # column name
  description

  # column name
  id

  # column name
  name

  # column name
  score
}

# aggregate var_pop on columns
type trophy_var_pop_fields {
  score: Float
}

# order by var_pop() on columns of table "trophy"
input trophy_var_pop_order_by {
  score: order_by
}

# aggregate var_samp on columns
type trophy_var_samp_fields {
  score: Float
}

# order by var_samp() on columns of table "trophy"
input trophy_var_samp_order_by {
  score: order_by
}

# aggregate variance on columns
type trophy_variance_fields {
  score: Float
}

# order by variance() on columns of table "trophy"
input trophy_variance_order_by {
  score: order_by
}

# columns and relationships of "trophyGroupView"
type trophyGroupView {
  description: String
  groupId: uuid
  id: uuid
  name: String
  score: Int
}

# aggregated selection of "trophyGroupView"
type trophyGroupView_aggregate {
  aggregate: trophyGroupView_aggregate_fields
  nodes: [trophyGroupView!]!
}

# aggregate fields of "trophyGroupView"
type trophyGroupView_aggregate_fields {
  avg: trophyGroupView_avg_fields
  count(columns: [trophyGroupView_select_column!], distinct: Boolean): Int
  max: trophyGroupView_max_fields
  min: trophyGroupView_min_fields
  stddev: trophyGroupView_stddev_fields
  stddev_pop: trophyGroupView_stddev_pop_fields
  stddev_samp: trophyGroupView_stddev_samp_fields
  sum: trophyGroupView_sum_fields
  var_pop: trophyGroupView_var_pop_fields
  var_samp: trophyGroupView_var_samp_fields
  variance: trophyGroupView_variance_fields
}

# order by aggregate values of table "trophyGroupView"
input trophyGroupView_aggregate_order_by {
  avg: trophyGroupView_avg_order_by
  count: order_by
  max: trophyGroupView_max_order_by
  min: trophyGroupView_min_order_by
  stddev: trophyGroupView_stddev_order_by
  stddev_pop: trophyGroupView_stddev_pop_order_by
  stddev_samp: trophyGroupView_stddev_samp_order_by
  sum: trophyGroupView_sum_order_by
  var_pop: trophyGroupView_var_pop_order_by
  var_samp: trophyGroupView_var_samp_order_by
  variance: trophyGroupView_variance_order_by
}

# aggregate avg on columns
type trophyGroupView_avg_fields {
  score: Float
}

# order by avg() on columns of table "trophyGroupView"
input trophyGroupView_avg_order_by {
  score: order_by
}

# Boolean expression to filter rows from the table "trophyGroupView". All fields are combined with a logical 'AND'.
input trophyGroupView_bool_exp {
  _and: [trophyGroupView_bool_exp]
  _not: trophyGroupView_bool_exp
  _or: [trophyGroupView_bool_exp]
  description: String_comparison_exp
  groupId: uuid_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  score: Int_comparison_exp
}

# aggregate max on columns
type trophyGroupView_max_fields {
  description: String
  groupId: uuid
  id: uuid
  name: String
  score: Int
}

# order by max() on columns of table "trophyGroupView"
input trophyGroupView_max_order_by {
  description: order_by
  groupId: order_by
  id: order_by
  name: order_by
  score: order_by
}

# aggregate min on columns
type trophyGroupView_min_fields {
  description: String
  groupId: uuid
  id: uuid
  name: String
  score: Int
}

# order by min() on columns of table "trophyGroupView"
input trophyGroupView_min_order_by {
  description: order_by
  groupId: order_by
  id: order_by
  name: order_by
  score: order_by
}

# ordering options when selecting data from "trophyGroupView"
input trophyGroupView_order_by {
  description: order_by
  groupId: order_by
  id: order_by
  name: order_by
  score: order_by
}

# select columns of table "trophyGroupView"
enum trophyGroupView_select_column {
  # column name
  description

  # column name
  groupId

  # column name
  id

  # column name
  name

  # column name
  score
}

# aggregate stddev on columns
type trophyGroupView_stddev_fields {
  score: Float
}

# order by stddev() on columns of table "trophyGroupView"
input trophyGroupView_stddev_order_by {
  score: order_by
}

# aggregate stddev_pop on columns
type trophyGroupView_stddev_pop_fields {
  score: Float
}

# order by stddev_pop() on columns of table "trophyGroupView"
input trophyGroupView_stddev_pop_order_by {
  score: order_by
}

# aggregate stddev_samp on columns
type trophyGroupView_stddev_samp_fields {
  score: Float
}

# order by stddev_samp() on columns of table "trophyGroupView"
input trophyGroupView_stddev_samp_order_by {
  score: order_by
}

# aggregate sum on columns
type trophyGroupView_sum_fields {
  score: Int
}

# order by sum() on columns of table "trophyGroupView"
input trophyGroupView_sum_order_by {
  score: order_by
}

# aggregate var_pop on columns
type trophyGroupView_var_pop_fields {
  score: Float
}

# order by var_pop() on columns of table "trophyGroupView"
input trophyGroupView_var_pop_order_by {
  score: order_by
}

# aggregate var_samp on columns
type trophyGroupView_var_samp_fields {
  score: Float
}

# order by var_samp() on columns of table "trophyGroupView"
input trophyGroupView_var_samp_order_by {
  score: order_by
}

# aggregate variance on columns
type trophyGroupView_variance_fields {
  score: Float
}

# order by variance() on columns of table "trophyGroupView"
input trophyGroupView_variance_order_by {
  score: order_by
}

# columns and relationships of "user"
type user {
  # An array relationship
  blockedBy(
    # distinct select on columns
    distinct_on: [block_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [block_order_by!]

    # filter the rows returned
    where: block_bool_exp
  ): [block!]!

  # An aggregated array relationship
  blockedBy_aggregate(
    # distinct select on columns
    distinct_on: [block_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [block_order_by!]

    # filter the rows returned
    where: block_bool_exp
  ): block_aggregate!

  # An array relationship
  blocker(
    # distinct select on columns
    distinct_on: [block_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [block_order_by!]

    # filter the rows returned
    where: block_bool_exp
  ): [block!]!

  # An aggregated array relationship
  blocker_aggregate(
    # distinct select on columns
    distinct_on: [block_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [block_order_by!]

    # filter the rows returned
    where: block_bool_exp
  ): block_aggregate!
  college: String
  description: String
  email: String!

  # An array relationship
  events(
    # distinct select on columns
    distinct_on: [userEvent_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userEvent_order_by!]

    # filter the rows returned
    where: userEvent_bool_exp
  ): [userEvent!]!

  # An aggregated array relationship
  events_aggregate(
    # distinct select on columns
    distinct_on: [userEvent_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userEvent_order_by!]

    # filter the rows returned
    where: userEvent_bool_exp
  ): userEvent_aggregate!

  # An array relationship
  friendRequestsReceived(
    # distinct select on columns
    distinct_on: [friendRequest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [friendRequest_order_by!]

    # filter the rows returned
    where: friendRequest_bool_exp
  ): [friendRequest!]!

  # An aggregated array relationship
  friendRequestsReceived_aggregate(
    # distinct select on columns
    distinct_on: [friendRequest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [friendRequest_order_by!]

    # filter the rows returned
    where: friendRequest_bool_exp
  ): friendRequest_aggregate!

  # An array relationship
  friendRequestsSent(
    # distinct select on columns
    distinct_on: [friendRequest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [friendRequest_order_by!]

    # filter the rows returned
    where: friendRequest_bool_exp
  ): [friendRequest!]!

  # An aggregated array relationship
  friendRequestsSent_aggregate(
    # distinct select on columns
    distinct_on: [friendRequest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [friendRequest_order_by!]

    # filter the rows returned
    where: friendRequest_bool_exp
  ): friendRequest_aggregate!

  # An array relationship
  friends(
    # distinct select on columns
    distinct_on: [friend_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [friend_order_by!]

    # filter the rows returned
    where: friend_bool_exp
  ): [friend!]!

  # An array relationship
  friendsByFriendid(
    # distinct select on columns
    distinct_on: [friend_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [friend_order_by!]

    # filter the rows returned
    where: friend_bool_exp
  ): [friend!]!

  # An aggregated array relationship
  friendsByFriendid_aggregate(
    # distinct select on columns
    distinct_on: [friend_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [friend_order_by!]

    # filter the rows returned
    where: friend_bool_exp
  ): friend_aggregate!

  # An aggregated array relationship
  friends_aggregate(
    # distinct select on columns
    distinct_on: [friend_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [friend_order_by!]

    # filter the rows returned
    where: friend_bool_exp
  ): friend_aggregate!
  id: String!
  image: String!

  # An array relationship
  interests(
    # distinct select on columns
    distinct_on: [userInterest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userInterest_order_by!]

    # filter the rows returned
    where: userInterest_bool_exp
  ): [userInterest!]!

  # An aggregated array relationship
  interests_aggregate(
    # distinct select on columns
    distinct_on: [userInterest_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userInterest_order_by!]

    # filter the rows returned
    where: userInterest_bool_exp
  ): userInterest_aggregate!
  isAdmin: Boolean!
  isLeader: Boolean!
  links(
    # JSON select path
    path: String
  ): jsonb!

  # An array relationship
  member(
    # distinct select on columns
    distinct_on: [userGroup_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userGroup_order_by!]

    # filter the rows returned
    where: userGroup_bool_exp
  ): [userGroup!]!

  # An aggregated array relationship
  member_aggregate(
    # distinct select on columns
    distinct_on: [userGroup_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userGroup_order_by!]

    # filter the rows returned
    where: userGroup_bool_exp
  ): userGroup_aggregate!

  # An array relationship
  messages(
    # distinct select on columns
    distinct_on: [message_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [message_order_by!]

    # filter the rows returned
    where: message_bool_exp
  ): [message!]!

  # An aggregated array relationship
  messages_aggregate(
    # distinct select on columns
    distinct_on: [message_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [message_order_by!]

    # filter the rows returned
    where: message_bool_exp
  ): message_aggregate!
  muteEvents: Boolean!
  muteGroups: Boolean!
  muteMessages: Boolean!
  name: String!
  notificationToken: String

  # An array relationship
  notifications(
    # distinct select on columns
    distinct_on: [userNotificationView_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userNotificationView_order_by!]

    # filter the rows returned
    where: userNotificationView_bool_exp
  ): [userNotificationView!]!

  # An aggregated array relationship
  notifications_aggregate(
    # distinct select on columns
    distinct_on: [userNotificationView_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userNotificationView_order_by!]

    # filter the rows returned
    where: userNotificationView_bool_exp
  ): userNotificationView_aggregate!
  onlyFriendsCanMessage: Boolean!

  # An array relationship
  programs(
    # distinct select on columns
    distinct_on: [userProgram_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userProgram_order_by!]

    # filter the rows returned
    where: userProgram_bool_exp
  ): [userProgram!]!

  # An aggregated array relationship
  programs_aggregate(
    # distinct select on columns
    distinct_on: [userProgram_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userProgram_order_by!]

    # filter the rows returned
    where: userProgram_bool_exp
  ): userProgram_aggregate!

  # An array relationship
  questions(
    # distinct select on columns
    distinct_on: [question_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [question_order_by!]

    # filter the rows returned
    where: question_bool_exp
  ): [question!]!

  # An aggregated array relationship
  questions_aggregate(
    # distinct select on columns
    distinct_on: [question_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [question_order_by!]

    # filter the rows returned
    where: question_bool_exp
  ): question_aggregate!

  # An array relationship
  reviews(
    # distinct select on columns
    distinct_on: [review_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [review_order_by!]

    # filter the rows returned
    where: review_bool_exp
  ): [review!]!

  # An aggregated array relationship
  reviews_aggregate(
    # distinct select on columns
    distinct_on: [review_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [review_order_by!]

    # filter the rows returned
    where: review_bool_exp
  ): review_aggregate!
  timezone: String

  # An array relationship
  userChats(
    # distinct select on columns
    distinct_on: [userChat_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userChat_order_by!]

    # filter the rows returned
    where: userChat_bool_exp
  ): [userChat!]!

  # An aggregated array relationship
  userChats_aggregate(
    # distinct select on columns
    distinct_on: [userChat_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userChat_order_by!]

    # filter the rows returned
    where: userChat_bool_exp
  ): userChat_aggregate!

  # An array relationship
  userNotifications(
    # distinct select on columns
    distinct_on: [userNotification_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userNotification_order_by!]

    # filter the rows returned
    where: userNotification_bool_exp
  ): [userNotification!]!

  # An aggregated array relationship
  userNotifications_aggregate(
    # distinct select on columns
    distinct_on: [userNotification_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [userNotification_order_by!]

    # filter the rows returned
    where: userNotification_bool_exp
  ): userNotification_aggregate!
  year: Int!
}

# aggregated selection of "user"
type user_aggregate {
  aggregate: user_aggregate_fields
  nodes: [user!]!
}

# aggregate fields of "user"
type user_aggregate_fields {
  avg: user_avg_fields
  count(columns: [user_select_column!], distinct: Boolean): Int
  max: user_max_fields
  min: user_min_fields
  stddev: user_stddev_fields
  stddev_pop: user_stddev_pop_fields
  stddev_samp: user_stddev_samp_fields
  sum: user_sum_fields
  var_pop: user_var_pop_fields
  var_samp: user_var_samp_fields
  variance: user_variance_fields
}

# order by aggregate values of table "user"
input user_aggregate_order_by {
  avg: user_avg_order_by
  count: order_by
  max: user_max_order_by
  min: user_min_order_by
  stddev: user_stddev_order_by
  stddev_pop: user_stddev_pop_order_by
  stddev_samp: user_stddev_samp_order_by
  sum: user_sum_order_by
  var_pop: user_var_pop_order_by
  var_samp: user_var_samp_order_by
  variance: user_variance_order_by
}

# append existing jsonb value of filtered columns with new jsonb value
input user_append_input {
  links: jsonb
}

# input type for inserting array relation for remote table "user"
input user_arr_rel_insert_input {
  data: [user_insert_input!]!
  on_conflict: user_on_conflict
}

# aggregate avg on columns
type user_avg_fields {
  year: Float
}

# order by avg() on columns of table "user"
input user_avg_order_by {
  year: order_by
}

# Boolean expression to filter rows from the table "user". All fields are combined with a logical 'AND'.
input user_bool_exp {
  _and: [user_bool_exp]
  _not: user_bool_exp
  _or: [user_bool_exp]
  blockedBy: block_bool_exp
  blocker: block_bool_exp
  college: String_comparison_exp
  description: String_comparison_exp
  email: String_comparison_exp
  events: userEvent_bool_exp
  friendRequestsReceived: friendRequest_bool_exp
  friendRequestsSent: friendRequest_bool_exp
  friends: friend_bool_exp
  friendsByFriendid: friend_bool_exp
  id: String_comparison_exp
  image: String_comparison_exp
  interests: userInterest_bool_exp
  isAdmin: Boolean_comparison_exp
  isLeader: Boolean_comparison_exp
  links: jsonb_comparison_exp
  member: userGroup_bool_exp
  messages: message_bool_exp
  muteEvents: Boolean_comparison_exp
  muteGroups: Boolean_comparison_exp
  muteMessages: Boolean_comparison_exp
  name: String_comparison_exp
  notificationToken: String_comparison_exp
  notifications: userNotificationView_bool_exp
  onlyFriendsCanMessage: Boolean_comparison_exp
  programs: userProgram_bool_exp
  questions: question_bool_exp
  reviews: review_bool_exp
  timezone: String_comparison_exp
  userChats: userChat_bool_exp
  userNotifications: userNotification_bool_exp
  year: Int_comparison_exp
}

# unique or primary key constraints on table "user"
enum user_constraint {
  # unique or primary key constraint
  user_pkey
}

# delete the field or element with specified path (for JSON arrays, negative integers count from the end)
input user_delete_at_path_input {
  links: [String]
}

# delete the array element with specified index (negative integers count from the
# end). throws an error if top level container is not an array
input user_delete_elem_input {
  links: Int
}

# delete key/value pair or string element. key/value pairs are matched based on their key value
input user_delete_key_input {
  links: String
}

# input type for incrementing integer column in table "user"
input user_inc_input {
  year: Int
}

# input type for inserting data into table "user"
input user_insert_input {
  blockedBy: block_arr_rel_insert_input
  blocker: block_arr_rel_insert_input
  college: String
  description: String
  email: String
  events: userEvent_arr_rel_insert_input
  friendRequestsReceived: friendRequest_arr_rel_insert_input
  friendRequestsSent: friendRequest_arr_rel_insert_input
  friends: friend_arr_rel_insert_input
  friendsByFriendid: friend_arr_rel_insert_input
  id: String
  image: String
  interests: userInterest_arr_rel_insert_input
  isAdmin: Boolean
  isLeader: Boolean
  links: jsonb
  member: userGroup_arr_rel_insert_input
  messages: message_arr_rel_insert_input
  muteEvents: Boolean
  muteGroups: Boolean
  muteMessages: Boolean
  name: String
  notificationToken: String
  onlyFriendsCanMessage: Boolean
  programs: userProgram_arr_rel_insert_input
  questions: question_arr_rel_insert_input
  reviews: review_arr_rel_insert_input
  timezone: String
  userChats: userChat_arr_rel_insert_input
  userNotifications: userNotification_arr_rel_insert_input
  year: Int
}

# aggregate max on columns
type user_max_fields {
  college: String
  description: String
  email: String
  id: String
  image: String
  name: String
  notificationToken: String
  timezone: String
  year: Int
}

# order by max() on columns of table "user"
input user_max_order_by {
  college: order_by
  description: order_by
  email: order_by
  id: order_by
  image: order_by
  name: order_by
  notificationToken: order_by
  timezone: order_by
  year: order_by
}

# aggregate min on columns
type user_min_fields {
  college: String
  description: String
  email: String
  id: String
  image: String
  name: String
  notificationToken: String
  timezone: String
  year: Int
}

# order by min() on columns of table "user"
input user_min_order_by {
  college: order_by
  description: order_by
  email: order_by
  id: order_by
  image: order_by
  name: order_by
  notificationToken: order_by
  timezone: order_by
  year: order_by
}

# response of any mutation on the table "user"
type user_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [user!]!
}

# input type for inserting object relation for remote table "user"
input user_obj_rel_insert_input {
  data: user_insert_input!
  on_conflict: user_on_conflict
}

# on conflict condition type for table "user"
input user_on_conflict {
  constraint: user_constraint!
  update_columns: [user_update_column!]!
  where: user_bool_exp
}

# ordering options when selecting data from "user"
input user_order_by {
  blockedBy_aggregate: block_aggregate_order_by
  blocker_aggregate: block_aggregate_order_by
  college: order_by
  description: order_by
  email: order_by
  events_aggregate: userEvent_aggregate_order_by
  friendRequestsReceived_aggregate: friendRequest_aggregate_order_by
  friendRequestsSent_aggregate: friendRequest_aggregate_order_by
  friendsByFriendid_aggregate: friend_aggregate_order_by
  friends_aggregate: friend_aggregate_order_by
  id: order_by
  image: order_by
  interests_aggregate: userInterest_aggregate_order_by
  isAdmin: order_by
  isLeader: order_by
  links: order_by
  member_aggregate: userGroup_aggregate_order_by
  messages_aggregate: message_aggregate_order_by
  muteEvents: order_by
  muteGroups: order_by
  muteMessages: order_by
  name: order_by
  notificationToken: order_by
  notifications_aggregate: userNotificationView_aggregate_order_by
  onlyFriendsCanMessage: order_by
  programs_aggregate: userProgram_aggregate_order_by
  questions_aggregate: question_aggregate_order_by
  reviews_aggregate: review_aggregate_order_by
  timezone: order_by
  userChats_aggregate: userChat_aggregate_order_by
  userNotifications_aggregate: userNotification_aggregate_order_by
  year: order_by
}

# primary key columns input for table: "user"
input user_pk_columns_input {
  id: String!
}

# prepend existing jsonb value of filtered columns with new jsonb value
input user_prepend_input {
  links: jsonb
}

# select columns of table "user"
enum user_select_column {
  # column name
  college

  # column name
  description

  # column name
  email

  # column name
  id

  # column name
  image

  # column name
  isAdmin

  # column name
  isLeader

  # column name
  links

  # column name
  muteEvents

  # column name
  muteGroups

  # column name
  muteMessages

  # column name
  name

  # column name
  notificationToken

  # column name
  onlyFriendsCanMessage

  # column name
  timezone

  # column name
  year
}

# input type for updating data in table "user"
input user_set_input {
  college: String
  description: String
  email: String
  id: String
  image: String
  isAdmin: Boolean
  isLeader: Boolean
  links: jsonb
  muteEvents: Boolean
  muteGroups: Boolean
  muteMessages: Boolean
  name: String
  notificationToken: String
  onlyFriendsCanMessage: Boolean
  timezone: String
  year: Int
}

# aggregate stddev on columns
type user_stddev_fields {
  year: Float
}

# order by stddev() on columns of table "user"
input user_stddev_order_by {
  year: order_by
}

# aggregate stddev_pop on columns
type user_stddev_pop_fields {
  year: Float
}

# order by stddev_pop() on columns of table "user"
input user_stddev_pop_order_by {
  year: order_by
}

# aggregate stddev_samp on columns
type user_stddev_samp_fields {
  year: Float
}

# order by stddev_samp() on columns of table "user"
input user_stddev_samp_order_by {
  year: order_by
}

# aggregate sum on columns
type user_sum_fields {
  year: Int
}

# order by sum() on columns of table "user"
input user_sum_order_by {
  year: order_by
}

# update columns of table "user"
enum user_update_column {
  # column name
  college

  # column name
  description

  # column name
  email

  # column name
  id

  # column name
  image

  # column name
  isAdmin

  # column name
  isLeader

  # column name
  links

  # column name
  muteEvents

  # column name
  muteGroups

  # column name
  muteMessages

  # column name
  name

  # column name
  notificationToken

  # column name
  onlyFriendsCanMessage

  # column name
  timezone

  # column name
  year
}

# aggregate var_pop on columns
type user_var_pop_fields {
  year: Float
}

# order by var_pop() on columns of table "user"
input user_var_pop_order_by {
  year: order_by
}

# aggregate var_samp on columns
type user_var_samp_fields {
  year: Float
}

# order by var_samp() on columns of table "user"
input user_var_samp_order_by {
  year: order_by
}

# aggregate variance on columns
type user_variance_fields {
  year: Float
}

# order by variance() on columns of table "user"
input user_variance_order_by {
  year: order_by
}

# columns and relationships of "userChat"
type userChat {
  # An object relationship
  chat: chat!
  chatId: Int!
  muted: Boolean!
  seen: Boolean!

  # An object relationship
  user: user!
  userId: String!
}

# aggregated selection of "userChat"
type userChat_aggregate {
  aggregate: userChat_aggregate_fields
  nodes: [userChat!]!
}

# aggregate fields of "userChat"
type userChat_aggregate_fields {
  avg: userChat_avg_fields
  count(columns: [userChat_select_column!], distinct: Boolean): Int
  max: userChat_max_fields
  min: userChat_min_fields
  stddev: userChat_stddev_fields
  stddev_pop: userChat_stddev_pop_fields
  stddev_samp: userChat_stddev_samp_fields
  sum: userChat_sum_fields
  var_pop: userChat_var_pop_fields
  var_samp: userChat_var_samp_fields
  variance: userChat_variance_fields
}

# order by aggregate values of table "userChat"
input userChat_aggregate_order_by {
  avg: userChat_avg_order_by
  count: order_by
  max: userChat_max_order_by
  min: userChat_min_order_by
  stddev: userChat_stddev_order_by
  stddev_pop: userChat_stddev_pop_order_by
  stddev_samp: userChat_stddev_samp_order_by
  sum: userChat_sum_order_by
  var_pop: userChat_var_pop_order_by
  var_samp: userChat_var_samp_order_by
  variance: userChat_variance_order_by
}

# input type for inserting array relation for remote table "userChat"
input userChat_arr_rel_insert_input {
  data: [userChat_insert_input!]!
  on_conflict: userChat_on_conflict
}

# aggregate avg on columns
type userChat_avg_fields {
  chatId: Float
}

# order by avg() on columns of table "userChat"
input userChat_avg_order_by {
  chatId: order_by
}

# Boolean expression to filter rows from the table "userChat". All fields are combined with a logical 'AND'.
input userChat_bool_exp {
  _and: [userChat_bool_exp]
  _not: userChat_bool_exp
  _or: [userChat_bool_exp]
  chat: chat_bool_exp
  chatId: Int_comparison_exp
  muted: Boolean_comparison_exp
  seen: Boolean_comparison_exp
  user: user_bool_exp
  userId: String_comparison_exp
}

# unique or primary key constraints on table "userChat"
enum userChat_constraint {
  # unique or primary key constraint
  userChat_pkey
}

# input type for incrementing integer column in table "userChat"
input userChat_inc_input {
  chatId: Int
}

# input type for inserting data into table "userChat"
input userChat_insert_input {
  chat: chat_obj_rel_insert_input
  chatId: Int
  muted: Boolean
  seen: Boolean
  user: user_obj_rel_insert_input
  userId: String
}

# aggregate max on columns
type userChat_max_fields {
  chatId: Int
  userId: String
}

# order by max() on columns of table "userChat"
input userChat_max_order_by {
  chatId: order_by
  userId: order_by
}

# aggregate min on columns
type userChat_min_fields {
  chatId: Int
  userId: String
}

# order by min() on columns of table "userChat"
input userChat_min_order_by {
  chatId: order_by
  userId: order_by
}

# response of any mutation on the table "userChat"
type userChat_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [userChat!]!
}

# input type for inserting object relation for remote table "userChat"
input userChat_obj_rel_insert_input {
  data: userChat_insert_input!
  on_conflict: userChat_on_conflict
}

# on conflict condition type for table "userChat"
input userChat_on_conflict {
  constraint: userChat_constraint!
  update_columns: [userChat_update_column!]!
  where: userChat_bool_exp
}

# ordering options when selecting data from "userChat"
input userChat_order_by {
  chat: chat_order_by
  chatId: order_by
  muted: order_by
  seen: order_by
  user: user_order_by
  userId: order_by
}

# primary key columns input for table: "userChat"
input userChat_pk_columns_input {
  chatId: Int!
  userId: String!
}

# select columns of table "userChat"
enum userChat_select_column {
  # column name
  chatId

  # column name
  muted

  # column name
  seen

  # column name
  userId
}

# input type for updating data in table "userChat"
input userChat_set_input {
  chatId: Int
  muted: Boolean
  seen: Boolean
  userId: String
}

# aggregate stddev on columns
type userChat_stddev_fields {
  chatId: Float
}

# order by stddev() on columns of table "userChat"
input userChat_stddev_order_by {
  chatId: order_by
}

# aggregate stddev_pop on columns
type userChat_stddev_pop_fields {
  chatId: Float
}

# order by stddev_pop() on columns of table "userChat"
input userChat_stddev_pop_order_by {
  chatId: order_by
}

# aggregate stddev_samp on columns
type userChat_stddev_samp_fields {
  chatId: Float
}

# order by stddev_samp() on columns of table "userChat"
input userChat_stddev_samp_order_by {
  chatId: order_by
}

# aggregate sum on columns
type userChat_sum_fields {
  chatId: Int
}

# order by sum() on columns of table "userChat"
input userChat_sum_order_by {
  chatId: order_by
}

# update columns of table "userChat"
enum userChat_update_column {
  # column name
  chatId

  # column name
  muted

  # column name
  seen

  # column name
  userId
}

# aggregate var_pop on columns
type userChat_var_pop_fields {
  chatId: Float
}

# order by var_pop() on columns of table "userChat"
input userChat_var_pop_order_by {
  chatId: order_by
}

# aggregate var_samp on columns
type userChat_var_samp_fields {
  chatId: Float
}

# order by var_samp() on columns of table "userChat"
input userChat_var_samp_order_by {
  chatId: order_by
}

# aggregate variance on columns
type userChat_variance_fields {
  chatId: Float
}

# order by variance() on columns of table "userChat"
input userChat_variance_order_by {
  chatId: order_by
}

# columns and relationships of "userEvent"
type userEvent {
  didAccept: Boolean!

  # An object relationship
  event: event!
  eventId: uuid!

  # An object relationship
  user: user!
  userId: String!
}

# aggregated selection of "userEvent"
type userEvent_aggregate {
  aggregate: userEvent_aggregate_fields
  nodes: [userEvent!]!
}

# aggregate fields of "userEvent"
type userEvent_aggregate_fields {
  count(columns: [userEvent_select_column!], distinct: Boolean): Int
  max: userEvent_max_fields
  min: userEvent_min_fields
}

# order by aggregate values of table "userEvent"
input userEvent_aggregate_order_by {
  count: order_by
  max: userEvent_max_order_by
  min: userEvent_min_order_by
}

# input type for inserting array relation for remote table "userEvent"
input userEvent_arr_rel_insert_input {
  data: [userEvent_insert_input!]!
  on_conflict: userEvent_on_conflict
}

# Boolean expression to filter rows from the table "userEvent". All fields are combined with a logical 'AND'.
input userEvent_bool_exp {
  _and: [userEvent_bool_exp]
  _not: userEvent_bool_exp
  _or: [userEvent_bool_exp]
  didAccept: Boolean_comparison_exp
  event: event_bool_exp
  eventId: uuid_comparison_exp
  user: user_bool_exp
  userId: String_comparison_exp
}

# unique or primary key constraints on table "userEvent"
enum userEvent_constraint {
  # unique or primary key constraint
  userEvent_pkey
}

# input type for inserting data into table "userEvent"
input userEvent_insert_input {
  didAccept: Boolean
  event: event_obj_rel_insert_input
  eventId: uuid
  user: user_obj_rel_insert_input
  userId: String
}

# aggregate max on columns
type userEvent_max_fields {
  eventId: uuid
  userId: String
}

# order by max() on columns of table "userEvent"
input userEvent_max_order_by {
  eventId: order_by
  userId: order_by
}

# aggregate min on columns
type userEvent_min_fields {
  eventId: uuid
  userId: String
}

# order by min() on columns of table "userEvent"
input userEvent_min_order_by {
  eventId: order_by
  userId: order_by
}

# response of any mutation on the table "userEvent"
type userEvent_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [userEvent!]!
}

# input type for inserting object relation for remote table "userEvent"
input userEvent_obj_rel_insert_input {
  data: userEvent_insert_input!
  on_conflict: userEvent_on_conflict
}

# on conflict condition type for table "userEvent"
input userEvent_on_conflict {
  constraint: userEvent_constraint!
  update_columns: [userEvent_update_column!]!
  where: userEvent_bool_exp
}

# ordering options when selecting data from "userEvent"
input userEvent_order_by {
  didAccept: order_by
  event: event_order_by
  eventId: order_by
  user: user_order_by
  userId: order_by
}

# primary key columns input for table: "userEvent"
input userEvent_pk_columns_input {
  eventId: uuid!
  userId: String!
}

# select columns of table "userEvent"
enum userEvent_select_column {
  # column name
  didAccept

  # column name
  eventId

  # column name
  userId
}

# input type for updating data in table "userEvent"
input userEvent_set_input {
  didAccept: Boolean
  eventId: uuid
  userId: String
}

# update columns of table "userEvent"
enum userEvent_update_column {
  # column name
  didAccept

  # column name
  eventId

  # column name
  userId
}

# columns and relationships of "userGroup"
type userGroup {
  # An object relationship
  group: group!
  groupId: uuid!
  isOwner: Boolean!
  onCalendar: Boolean!

  # An object relationship
  user: user!
  userId: String!
}

# aggregated selection of "userGroup"
type userGroup_aggregate {
  aggregate: userGroup_aggregate_fields
  nodes: [userGroup!]!
}

# aggregate fields of "userGroup"
type userGroup_aggregate_fields {
  count(columns: [userGroup_select_column!], distinct: Boolean): Int
  max: userGroup_max_fields
  min: userGroup_min_fields
}

# order by aggregate values of table "userGroup"
input userGroup_aggregate_order_by {
  count: order_by
  max: userGroup_max_order_by
  min: userGroup_min_order_by
}

# input type for inserting array relation for remote table "userGroup"
input userGroup_arr_rel_insert_input {
  data: [userGroup_insert_input!]!
  on_conflict: userGroup_on_conflict
}

# Boolean expression to filter rows from the table "userGroup". All fields are combined with a logical 'AND'.
input userGroup_bool_exp {
  _and: [userGroup_bool_exp]
  _not: userGroup_bool_exp
  _or: [userGroup_bool_exp]
  group: group_bool_exp
  groupId: uuid_comparison_exp
  isOwner: Boolean_comparison_exp
  onCalendar: Boolean_comparison_exp
  user: user_bool_exp
  userId: String_comparison_exp
}

# unique or primary key constraints on table "userGroup"
enum userGroup_constraint {
  # unique or primary key constraint
  userMember_pkey
}

# input type for inserting data into table "userGroup"
input userGroup_insert_input {
  group: group_obj_rel_insert_input
  groupId: uuid
  isOwner: Boolean
  onCalendar: Boolean
  user: user_obj_rel_insert_input
  userId: String
}

# aggregate max on columns
type userGroup_max_fields {
  groupId: uuid
  userId: String
}

# order by max() on columns of table "userGroup"
input userGroup_max_order_by {
  groupId: order_by
  userId: order_by
}

# aggregate min on columns
type userGroup_min_fields {
  groupId: uuid
  userId: String
}

# order by min() on columns of table "userGroup"
input userGroup_min_order_by {
  groupId: order_by
  userId: order_by
}

# response of any mutation on the table "userGroup"
type userGroup_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [userGroup!]!
}

# input type for inserting object relation for remote table "userGroup"
input userGroup_obj_rel_insert_input {
  data: userGroup_insert_input!
  on_conflict: userGroup_on_conflict
}

# on conflict condition type for table "userGroup"
input userGroup_on_conflict {
  constraint: userGroup_constraint!
  update_columns: [userGroup_update_column!]!
  where: userGroup_bool_exp
}

# ordering options when selecting data from "userGroup"
input userGroup_order_by {
  group: group_order_by
  groupId: order_by
  isOwner: order_by
  onCalendar: order_by
  user: user_order_by
  userId: order_by
}

# primary key columns input for table: "userGroup"
input userGroup_pk_columns_input {
  groupId: uuid!
  userId: String!
}

# select columns of table "userGroup"
enum userGroup_select_column {
  # column name
  groupId

  # column name
  isOwner

  # column name
  onCalendar

  # column name
  userId
}

# input type for updating data in table "userGroup"
input userGroup_set_input {
  groupId: uuid
  isOwner: Boolean
  onCalendar: Boolean
  userId: String
}

# update columns of table "userGroup"
enum userGroup_update_column {
  # column name
  groupId

  # column name
  isOwner

  # column name
  onCalendar

  # column name
  userId
}

# columns and relationships of "userInterest"
type userInterest {
  # An object relationship
  interest: interest!
  interestId: Int!

  # An object relationship
  user: user!
  userId: String!
}

# aggregated selection of "userInterest"
type userInterest_aggregate {
  aggregate: userInterest_aggregate_fields
  nodes: [userInterest!]!
}

# aggregate fields of "userInterest"
type userInterest_aggregate_fields {
  avg: userInterest_avg_fields
  count(columns: [userInterest_select_column!], distinct: Boolean): Int
  max: userInterest_max_fields
  min: userInterest_min_fields
  stddev: userInterest_stddev_fields
  stddev_pop: userInterest_stddev_pop_fields
  stddev_samp: userInterest_stddev_samp_fields
  sum: userInterest_sum_fields
  var_pop: userInterest_var_pop_fields
  var_samp: userInterest_var_samp_fields
  variance: userInterest_variance_fields
}

# order by aggregate values of table "userInterest"
input userInterest_aggregate_order_by {
  avg: userInterest_avg_order_by
  count: order_by
  max: userInterest_max_order_by
  min: userInterest_min_order_by
  stddev: userInterest_stddev_order_by
  stddev_pop: userInterest_stddev_pop_order_by
  stddev_samp: userInterest_stddev_samp_order_by
  sum: userInterest_sum_order_by
  var_pop: userInterest_var_pop_order_by
  var_samp: userInterest_var_samp_order_by
  variance: userInterest_variance_order_by
}

# input type for inserting array relation for remote table "userInterest"
input userInterest_arr_rel_insert_input {
  data: [userInterest_insert_input!]!
  on_conflict: userInterest_on_conflict
}

# aggregate avg on columns
type userInterest_avg_fields {
  interestId: Float
}

# order by avg() on columns of table "userInterest"
input userInterest_avg_order_by {
  interestId: order_by
}

# Boolean expression to filter rows from the table "userInterest". All fields are combined with a logical 'AND'.
input userInterest_bool_exp {
  _and: [userInterest_bool_exp]
  _not: userInterest_bool_exp
  _or: [userInterest_bool_exp]
  interest: interest_bool_exp
  interestId: Int_comparison_exp
  user: user_bool_exp
  userId: String_comparison_exp
}

# unique or primary key constraints on table "userInterest"
enum userInterest_constraint {
  # unique or primary key constraint
  userInterest_pkey
}

# input type for incrementing integer column in table "userInterest"
input userInterest_inc_input {
  interestId: Int
}

# input type for inserting data into table "userInterest"
input userInterest_insert_input {
  interest: interest_obj_rel_insert_input
  interestId: Int
  user: user_obj_rel_insert_input
  userId: String
}

# aggregate max on columns
type userInterest_max_fields {
  interestId: Int
  userId: String
}

# order by max() on columns of table "userInterest"
input userInterest_max_order_by {
  interestId: order_by
  userId: order_by
}

# aggregate min on columns
type userInterest_min_fields {
  interestId: Int
  userId: String
}

# order by min() on columns of table "userInterest"
input userInterest_min_order_by {
  interestId: order_by
  userId: order_by
}

# response of any mutation on the table "userInterest"
type userInterest_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [userInterest!]!
}

# input type for inserting object relation for remote table "userInterest"
input userInterest_obj_rel_insert_input {
  data: userInterest_insert_input!
  on_conflict: userInterest_on_conflict
}

# on conflict condition type for table "userInterest"
input userInterest_on_conflict {
  constraint: userInterest_constraint!
  update_columns: [userInterest_update_column!]!
  where: userInterest_bool_exp
}

# ordering options when selecting data from "userInterest"
input userInterest_order_by {
  interest: interest_order_by
  interestId: order_by
  user: user_order_by
  userId: order_by
}

# primary key columns input for table: "userInterest"
input userInterest_pk_columns_input {
  interestId: Int!
  userId: String!
}

# select columns of table "userInterest"
enum userInterest_select_column {
  # column name
  interestId

  # column name
  userId
}

# input type for updating data in table "userInterest"
input userInterest_set_input {
  interestId: Int
  userId: String
}

# aggregate stddev on columns
type userInterest_stddev_fields {
  interestId: Float
}

# order by stddev() on columns of table "userInterest"
input userInterest_stddev_order_by {
  interestId: order_by
}

# aggregate stddev_pop on columns
type userInterest_stddev_pop_fields {
  interestId: Float
}

# order by stddev_pop() on columns of table "userInterest"
input userInterest_stddev_pop_order_by {
  interestId: order_by
}

# aggregate stddev_samp on columns
type userInterest_stddev_samp_fields {
  interestId: Float
}

# order by stddev_samp() on columns of table "userInterest"
input userInterest_stddev_samp_order_by {
  interestId: order_by
}

# aggregate sum on columns
type userInterest_sum_fields {
  interestId: Int
}

# order by sum() on columns of table "userInterest"
input userInterest_sum_order_by {
  interestId: order_by
}

# update columns of table "userInterest"
enum userInterest_update_column {
  # column name
  interestId

  # column name
  userId
}

# aggregate var_pop on columns
type userInterest_var_pop_fields {
  interestId: Float
}

# order by var_pop() on columns of table "userInterest"
input userInterest_var_pop_order_by {
  interestId: order_by
}

# aggregate var_samp on columns
type userInterest_var_samp_fields {
  interestId: Float
}

# order by var_samp() on columns of table "userInterest"
input userInterest_var_samp_order_by {
  interestId: order_by
}

# aggregate variance on columns
type userInterest_variance_fields {
  interestId: Float
}

# order by variance() on columns of table "userInterest"
input userInterest_variance_order_by {
  interestId: order_by
}

# columns and relationships of "userNotification"
type userNotification {
  # An object relationship
  notification: notification!
  notificationId: Int!

  # An object relationship
  user: user!
  userId: String!
}

# aggregated selection of "userNotification"
type userNotification_aggregate {
  aggregate: userNotification_aggregate_fields
  nodes: [userNotification!]!
}

# aggregate fields of "userNotification"
type userNotification_aggregate_fields {
  avg: userNotification_avg_fields
  count(columns: [userNotification_select_column!], distinct: Boolean): Int
  max: userNotification_max_fields
  min: userNotification_min_fields
  stddev: userNotification_stddev_fields
  stddev_pop: userNotification_stddev_pop_fields
  stddev_samp: userNotification_stddev_samp_fields
  sum: userNotification_sum_fields
  var_pop: userNotification_var_pop_fields
  var_samp: userNotification_var_samp_fields
  variance: userNotification_variance_fields
}

# order by aggregate values of table "userNotification"
input userNotification_aggregate_order_by {
  avg: userNotification_avg_order_by
  count: order_by
  max: userNotification_max_order_by
  min: userNotification_min_order_by
  stddev: userNotification_stddev_order_by
  stddev_pop: userNotification_stddev_pop_order_by
  stddev_samp: userNotification_stddev_samp_order_by
  sum: userNotification_sum_order_by
  var_pop: userNotification_var_pop_order_by
  var_samp: userNotification_var_samp_order_by
  variance: userNotification_variance_order_by
}

# input type for inserting array relation for remote table "userNotification"
input userNotification_arr_rel_insert_input {
  data: [userNotification_insert_input!]!
  on_conflict: userNotification_on_conflict
}

# aggregate avg on columns
type userNotification_avg_fields {
  notificationId: Float
}

# order by avg() on columns of table "userNotification"
input userNotification_avg_order_by {
  notificationId: order_by
}

# Boolean expression to filter rows from the table "userNotification". All fields are combined with a logical 'AND'.
input userNotification_bool_exp {
  _and: [userNotification_bool_exp]
  _not: userNotification_bool_exp
  _or: [userNotification_bool_exp]
  notification: notification_bool_exp
  notificationId: Int_comparison_exp
  user: user_bool_exp
  userId: String_comparison_exp
}

# unique or primary key constraints on table "userNotification"
enum userNotification_constraint {
  # unique or primary key constraint
  userNotification_pkey
}

# input type for incrementing integer column in table "userNotification"
input userNotification_inc_input {
  notificationId: Int
}

# input type for inserting data into table "userNotification"
input userNotification_insert_input {
  notification: notification_obj_rel_insert_input
  notificationId: Int
  user: user_obj_rel_insert_input
  userId: String
}

# aggregate max on columns
type userNotification_max_fields {
  notificationId: Int
  userId: String
}

# order by max() on columns of table "userNotification"
input userNotification_max_order_by {
  notificationId: order_by
  userId: order_by
}

# aggregate min on columns
type userNotification_min_fields {
  notificationId: Int
  userId: String
}

# order by min() on columns of table "userNotification"
input userNotification_min_order_by {
  notificationId: order_by
  userId: order_by
}

# response of any mutation on the table "userNotification"
type userNotification_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [userNotification!]!
}

# input type for inserting object relation for remote table "userNotification"
input userNotification_obj_rel_insert_input {
  data: userNotification_insert_input!
  on_conflict: userNotification_on_conflict
}

# on conflict condition type for table "userNotification"
input userNotification_on_conflict {
  constraint: userNotification_constraint!
  update_columns: [userNotification_update_column!]!
  where: userNotification_bool_exp
}

# ordering options when selecting data from "userNotification"
input userNotification_order_by {
  notification: notification_order_by
  notificationId: order_by
  user: user_order_by
  userId: order_by
}

# primary key columns input for table: "userNotification"
input userNotification_pk_columns_input {
  notificationId: Int!
  userId: String!
}

# select columns of table "userNotification"
enum userNotification_select_column {
  # column name
  notificationId

  # column name
  userId
}

# input type for updating data in table "userNotification"
input userNotification_set_input {
  notificationId: Int
  userId: String
}

# aggregate stddev on columns
type userNotification_stddev_fields {
  notificationId: Float
}

# order by stddev() on columns of table "userNotification"
input userNotification_stddev_order_by {
  notificationId: order_by
}

# aggregate stddev_pop on columns
type userNotification_stddev_pop_fields {
  notificationId: Float
}

# order by stddev_pop() on columns of table "userNotification"
input userNotification_stddev_pop_order_by {
  notificationId: order_by
}

# aggregate stddev_samp on columns
type userNotification_stddev_samp_fields {
  notificationId: Float
}

# order by stddev_samp() on columns of table "userNotification"
input userNotification_stddev_samp_order_by {
  notificationId: order_by
}

# aggregate sum on columns
type userNotification_sum_fields {
  notificationId: Int
}

# order by sum() on columns of table "userNotification"
input userNotification_sum_order_by {
  notificationId: order_by
}

# update columns of table "userNotification"
enum userNotification_update_column {
  # column name
  notificationId

  # column name
  userId
}

# aggregate var_pop on columns
type userNotification_var_pop_fields {
  notificationId: Float
}

# order by var_pop() on columns of table "userNotification"
input userNotification_var_pop_order_by {
  notificationId: order_by
}

# aggregate var_samp on columns
type userNotification_var_samp_fields {
  notificationId: Float
}

# order by var_samp() on columns of table "userNotification"
input userNotification_var_samp_order_by {
  notificationId: order_by
}

# aggregate variance on columns
type userNotification_variance_fields {
  notificationId: Float
}

# order by variance() on columns of table "userNotification"
input userNotification_variance_order_by {
  notificationId: order_by
}

# columns and relationships of "userNotificationView"
type userNotificationView {
  id: Int
  seen: Boolean
  timestamp: timestamptz
  type: String
  typeId: String
  userId: String
}

# aggregated selection of "userNotificationView"
type userNotificationView_aggregate {
  aggregate: userNotificationView_aggregate_fields
  nodes: [userNotificationView!]!
}

# aggregate fields of "userNotificationView"
type userNotificationView_aggregate_fields {
  avg: userNotificationView_avg_fields
  count(columns: [userNotificationView_select_column!], distinct: Boolean): Int
  max: userNotificationView_max_fields
  min: userNotificationView_min_fields
  stddev: userNotificationView_stddev_fields
  stddev_pop: userNotificationView_stddev_pop_fields
  stddev_samp: userNotificationView_stddev_samp_fields
  sum: userNotificationView_sum_fields
  var_pop: userNotificationView_var_pop_fields
  var_samp: userNotificationView_var_samp_fields
  variance: userNotificationView_variance_fields
}

# order by aggregate values of table "userNotificationView"
input userNotificationView_aggregate_order_by {
  avg: userNotificationView_avg_order_by
  count: order_by
  max: userNotificationView_max_order_by
  min: userNotificationView_min_order_by
  stddev: userNotificationView_stddev_order_by
  stddev_pop: userNotificationView_stddev_pop_order_by
  stddev_samp: userNotificationView_stddev_samp_order_by
  sum: userNotificationView_sum_order_by
  var_pop: userNotificationView_var_pop_order_by
  var_samp: userNotificationView_var_samp_order_by
  variance: userNotificationView_variance_order_by
}

# aggregate avg on columns
type userNotificationView_avg_fields {
  id: Float
}

# order by avg() on columns of table "userNotificationView"
input userNotificationView_avg_order_by {
  id: order_by
}

# Boolean expression to filter rows from the table "userNotificationView". All fields are combined with a logical 'AND'.
input userNotificationView_bool_exp {
  _and: [userNotificationView_bool_exp]
  _not: userNotificationView_bool_exp
  _or: [userNotificationView_bool_exp]
  id: Int_comparison_exp
  seen: Boolean_comparison_exp
  timestamp: timestamptz_comparison_exp
  type: String_comparison_exp
  typeId: String_comparison_exp
  userId: String_comparison_exp
}

# aggregate max on columns
type userNotificationView_max_fields {
  id: Int
  timestamp: timestamptz
  type: String
  typeId: String
  userId: String
}

# order by max() on columns of table "userNotificationView"
input userNotificationView_max_order_by {
  id: order_by
  timestamp: order_by
  type: order_by
  typeId: order_by
  userId: order_by
}

# aggregate min on columns
type userNotificationView_min_fields {
  id: Int
  timestamp: timestamptz
  type: String
  typeId: String
  userId: String
}

# order by min() on columns of table "userNotificationView"
input userNotificationView_min_order_by {
  id: order_by
  timestamp: order_by
  type: order_by
  typeId: order_by
  userId: order_by
}

# ordering options when selecting data from "userNotificationView"
input userNotificationView_order_by {
  id: order_by
  seen: order_by
  timestamp: order_by
  type: order_by
  typeId: order_by
  userId: order_by
}

# select columns of table "userNotificationView"
enum userNotificationView_select_column {
  # column name
  id

  # column name
  seen

  # column name
  timestamp

  # column name
  type

  # column name
  typeId

  # column name
  userId
}

# aggregate stddev on columns
type userNotificationView_stddev_fields {
  id: Float
}

# order by stddev() on columns of table "userNotificationView"
input userNotificationView_stddev_order_by {
  id: order_by
}

# aggregate stddev_pop on columns
type userNotificationView_stddev_pop_fields {
  id: Float
}

# order by stddev_pop() on columns of table "userNotificationView"
input userNotificationView_stddev_pop_order_by {
  id: order_by
}

# aggregate stddev_samp on columns
type userNotificationView_stddev_samp_fields {
  id: Float
}

# order by stddev_samp() on columns of table "userNotificationView"
input userNotificationView_stddev_samp_order_by {
  id: order_by
}

# aggregate sum on columns
type userNotificationView_sum_fields {
  id: Int
}

# order by sum() on columns of table "userNotificationView"
input userNotificationView_sum_order_by {
  id: order_by
}

# aggregate var_pop on columns
type userNotificationView_var_pop_fields {
  id: Float
}

# order by var_pop() on columns of table "userNotificationView"
input userNotificationView_var_pop_order_by {
  id: order_by
}

# aggregate var_samp on columns
type userNotificationView_var_samp_fields {
  id: Float
}

# order by var_samp() on columns of table "userNotificationView"
input userNotificationView_var_samp_order_by {
  id: order_by
}

# aggregate variance on columns
type userNotificationView_variance_fields {
  id: Float
}

# order by variance() on columns of table "userNotificationView"
input userNotificationView_variance_order_by {
  id: order_by
}

# columns and relationships of "userProgram"
type userProgram {
  # An object relationship
  program: program!
  programId: Int!

  # An object relationship
  user: user!
  userId: String!
}

# aggregated selection of "userProgram"
type userProgram_aggregate {
  aggregate: userProgram_aggregate_fields
  nodes: [userProgram!]!
}

# aggregate fields of "userProgram"
type userProgram_aggregate_fields {
  avg: userProgram_avg_fields
  count(columns: [userProgram_select_column!], distinct: Boolean): Int
  max: userProgram_max_fields
  min: userProgram_min_fields
  stddev: userProgram_stddev_fields
  stddev_pop: userProgram_stddev_pop_fields
  stddev_samp: userProgram_stddev_samp_fields
  sum: userProgram_sum_fields
  var_pop: userProgram_var_pop_fields
  var_samp: userProgram_var_samp_fields
  variance: userProgram_variance_fields
}

# order by aggregate values of table "userProgram"
input userProgram_aggregate_order_by {
  avg: userProgram_avg_order_by
  count: order_by
  max: userProgram_max_order_by
  min: userProgram_min_order_by
  stddev: userProgram_stddev_order_by
  stddev_pop: userProgram_stddev_pop_order_by
  stddev_samp: userProgram_stddev_samp_order_by
  sum: userProgram_sum_order_by
  var_pop: userProgram_var_pop_order_by
  var_samp: userProgram_var_samp_order_by
  variance: userProgram_variance_order_by
}

# input type for inserting array relation for remote table "userProgram"
input userProgram_arr_rel_insert_input {
  data: [userProgram_insert_input!]!
  on_conflict: userProgram_on_conflict
}

# aggregate avg on columns
type userProgram_avg_fields {
  programId: Float
}

# order by avg() on columns of table "userProgram"
input userProgram_avg_order_by {
  programId: order_by
}

# Boolean expression to filter rows from the table "userProgram". All fields are combined with a logical 'AND'.
input userProgram_bool_exp {
  _and: [userProgram_bool_exp]
  _not: userProgram_bool_exp
  _or: [userProgram_bool_exp]
  program: program_bool_exp
  programId: Int_comparison_exp
  user: user_bool_exp
  userId: String_comparison_exp
}

# unique or primary key constraints on table "userProgram"
enum userProgram_constraint {
  # unique or primary key constraint
  userProgram_pkey
}

# input type for incrementing integer column in table "userProgram"
input userProgram_inc_input {
  programId: Int
}

# input type for inserting data into table "userProgram"
input userProgram_insert_input {
  program: program_obj_rel_insert_input
  programId: Int
  user: user_obj_rel_insert_input
  userId: String
}

# aggregate max on columns
type userProgram_max_fields {
  programId: Int
  userId: String
}

# order by max() on columns of table "userProgram"
input userProgram_max_order_by {
  programId: order_by
  userId: order_by
}

# aggregate min on columns
type userProgram_min_fields {
  programId: Int
  userId: String
}

# order by min() on columns of table "userProgram"
input userProgram_min_order_by {
  programId: order_by
  userId: order_by
}

# response of any mutation on the table "userProgram"
type userProgram_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [userProgram!]!
}

# input type for inserting object relation for remote table "userProgram"
input userProgram_obj_rel_insert_input {
  data: userProgram_insert_input!
  on_conflict: userProgram_on_conflict
}

# on conflict condition type for table "userProgram"
input userProgram_on_conflict {
  constraint: userProgram_constraint!
  update_columns: [userProgram_update_column!]!
  where: userProgram_bool_exp
}

# ordering options when selecting data from "userProgram"
input userProgram_order_by {
  program: program_order_by
  programId: order_by
  user: user_order_by
  userId: order_by
}

# primary key columns input for table: "userProgram"
input userProgram_pk_columns_input {
  programId: Int!
  userId: String!
}

# select columns of table "userProgram"
enum userProgram_select_column {
  # column name
  programId

  # column name
  userId
}

# input type for updating data in table "userProgram"
input userProgram_set_input {
  programId: Int
  userId: String
}

# aggregate stddev on columns
type userProgram_stddev_fields {
  programId: Float
}

# order by stddev() on columns of table "userProgram"
input userProgram_stddev_order_by {
  programId: order_by
}

# aggregate stddev_pop on columns
type userProgram_stddev_pop_fields {
  programId: Float
}

# order by stddev_pop() on columns of table "userProgram"
input userProgram_stddev_pop_order_by {
  programId: order_by
}

# aggregate stddev_samp on columns
type userProgram_stddev_samp_fields {
  programId: Float
}

# order by stddev_samp() on columns of table "userProgram"
input userProgram_stddev_samp_order_by {
  programId: order_by
}

# aggregate sum on columns
type userProgram_sum_fields {
  programId: Int
}

# order by sum() on columns of table "userProgram"
input userProgram_sum_order_by {
  programId: order_by
}

# update columns of table "userProgram"
enum userProgram_update_column {
  # column name
  programId

  # column name
  userId
}

# aggregate var_pop on columns
type userProgram_var_pop_fields {
  programId: Float
}

# order by var_pop() on columns of table "userProgram"
input userProgram_var_pop_order_by {
  programId: order_by
}

# aggregate var_samp on columns
type userProgram_var_samp_fields {
  programId: Float
}

# order by var_samp() on columns of table "userProgram"
input userProgram_var_samp_order_by {
  programId: order_by
}

# aggregate variance on columns
type userProgram_variance_fields {
  programId: Float
}

# order by variance() on columns of table "userProgram"
input userProgram_variance_order_by {
  programId: order_by
}

scalar uuid

# expression to compare columns of type uuid. All fields are combined with logical 'AND'.
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

